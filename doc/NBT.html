<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-type" content="text/html; charset=utf-8">
  <link rel="stylesheet" href="./api.css" type="text/css">
  <title>NBT API v2</title>
</head>
<body>

<div id="logo">
<a name="robo_top_of_doc">NBT API v2</a>
</div>

<div id="toc">
<p>TABLE OF CONTENTS</p>
<li><a href="#NBTapi">NBT API</a></li>
<li><a href="#NBTspec">NBT Structure</a></li>
<li><a href="#NBTspecapi">NBT Structure in API</a></li>
<li><a href="#NBTpost">NBT post processing</a></li>
<li><a href="#NBTexample">NBT usage example</a></li>

<li><a href="#NBT_Parse">NBT_Parse</a></li>
<li><a href="#NBT_ParseIO">NBT_ParseIO</a></li>
<li><a href="#NBT_ParseZlib">NBT_ParseZlib</a></li>
<li><a href="#NBT_FindNode">NBT_FindNode</a></li>
<li><a href="#NBT_FindNodeFromStream">NBT_FindNodeFromStream</a></li>
<li><a href="#NBT_FindBranch">NBT_FindBranch</a></li>
<li><a href="#NBT_Save">NBT_Save</a></li>
<li><a href="#NBT_Iter">NBT_Iter</a></li>
<li><a href="#NBT_SetHdrSize">NBT_SetHdrSize</a></li>
<li><a href="#NBT_Insert">NBT_Insert</a></li>
<li><a href="#NBT_AddOrUpdateKey">NBT_AddOrUpdateKey</a></li>
<li><a href="#NBT_ToFloat">NBT_ToFloat</a></li>
<li><a href="#NBT_ToString">NBT_ToString</a></li>
<li><a href="#NBT_ToInt">NBT_ToInt</a></li>
<li><a href="#NBT_Size">NBT_Size</a></li>
<li><a href="#NBT_MarkForUpdate">NBT_MarkForUpdate</a></li>
<li><a href="#NBT_InitIter">NBT_InitIter</a></li>
<li><a href="#NBT_IterCompound">NBT_IterCompound</a></li>
<li><a href="#NBT_Payload">NBT_Payload</a></li>
<li><a href="#NBT_ArrayStart">NBT_ArrayStart</a></li>
<li><a href="#NBT_PayloadFromStream">NBT_PayloadFromStream</a></li>
<li><a href="#NBT_SetFloat">NBT_SetFloat</a></li>
<li><a href="#NBT_SetInt">NBT_SetInt</a></li>
<li><a href="#NBT_Add">NBT_Add</a></li>
<li><a href="#NBT_Delete">NBT_Delete</a></li>
<li><a href="#NBT_Copy">NBT_Copy</a></li>
<li><a href="#NBT_Compress">NBT_Compress</a></li>
<br>
<br>
</div>


<div id="content">

<h2 id="NBTapi">NBT API [ Module ]</h2>

<p class="item_name">INTRODUCTION</p>

<p>[ <a href="#content">Top</a> ]

<p>This module is used to read, write and modify NBT (<tt>Named Binary Tag</tt>) file format from disk
and/or memory. NBT is used to store arbitrary data types in a tree-like structure (ie: nested up to
any depth). In some ways, it can be seen as a binary JSON. NBT file are often being compressed using
either gzip or zlib compression, this module handle decompression by the use of the <tt>zlib</tt> library
(this module does not roll its own decompression algorithm).

<p>NBT API in this engine does not exactly follow a traditional API you might expect for manipulating
a tree of arbitrary data types. The main problem that this API was trying to solve is to keep 
everything related to an NBT tree as close as possible in memory, to benefit from cache locality.

<p>This is actually the main focus of this API: it <b>strongly</b> favors read over write access. The
rationale for this choice being that most chunks in a map will never be modified at all, and for those
that will, most of time it is simply a matter of overwriting some tables (<tt>BlockLight</tt>,
<tt>Blocks</tt>, <tt>Data</tt>, ...).

<p>There are a few lists (<tt>TileEntities</tt>, <tt>Entities</tt>, <tt>TileTicks</tt>, ...) where the
content can change significantly, and this is where this API will be a bit more tedious to use than other
APIs.

<p>The gist of how this API works is to serialize the content of a NBT file into a <b>single memory
block</b>. This block will be reallocated if the first allocation was not enough, but <b>everything</b>
will be kept into a contiguous block of memory. Therefore the binary representation of the NBT structure
in memory will actually be <b>very close</b> to how it is stored on disk (if it were uncompressed): save
a few memory alignment constraints and byte ordering, and you could write the buffer almost directly
to disk.

<p>Sadly, that also means, in order to use this API, you'll need to have a pretty good understanding
on how NBT is structured on disk, because that API is a very shallow abstraction over that. A refresher
will be available in the next section.




<div class="sep" id="NBTspec"></div>

<h2>NBT Structure [ Spec ]</h2>

<p>[ <a href="#content">Top</a> ]

<p class="item_name">INTRODUCTION</p>

<p>This section is a quick refresher on how NBT is structured (uncompressed). This format can store
arbitrary data types, in a tree-like format with branch nested as deep as you want.

<p>NBT supports <b>3 major families of types</b>:
<ol>
  <li><b>Scalar</b>: designate an immediate value, which can be an integer (1, 2, 4 or 8 bytes), a
  floating point number (32 or 64bits) or a string.
  <li><b>List</b>: contains a finite number of scalar and/or compound (all of the same type).
  <li><b>Compound</b>: an arbitrary number of scalar, list or even nested compound, one after the other:
  a field terminator is used to mark the end of the block.
</ol>

<p>Usually an NBT object/file always starts with a <b>Compound</b> or <b>List</b>, otherwise it will
be limited to a single scalar value, which is not very useful. Each type is stored using a header and
a payload. The header follows the same structure for every type, the payload is obviously specific to
each type.

<p>Also, integers bigger than 1 byte and floatting point types are stored in <b>big endian</b> format.

<p class="item_name">HEADER</p>

<p>Here is the structure of the header:
<ul>
  <li><b>1 byte</b>: the first byte encode the type of the record. Here are the possible values:
  <table>
  <thead><tr><td>Num<td>Define<td>Description
  <tbody>
    <tr><th>0<td><tt>TAG_End</tt><td>This type is used to mark the end of a compound.
	<p><span class="n">Note</span>: a <tt>TAG_End</tt> does not have any payload beyond this single byte.
    <tr><th>1<td><tt>TAG_Byte</tt><td>Used to store an <tt class="t">uint8_t</tt>.

    <tr><th>2<td><tt>TAG_Short</tt><td>Store an <tt class="t">uint16_t</tt>.
    <tr><th>3<td><tt>TAG_Int</tt><td>Store an <tt class="t">uint32_t</tt>.
    <tr><th>4<td><tt>TAG_Long</tt><td>Store an <tt class="t">uint64_t</tt>.
    <tr><th>5<td><tt>TAG_Float</tt><td>Store an <tt class="t">float</tt>.
    <tr><th>6<td><tt>TAG_Double</tt><td>Store an <tt class="t">double</tt>.
    <tr><th>7<td><tt>TAG_Byte_Array</tt><td>Store an <tt class="t">uint8_t</tt> array.
    <tr><th>8<td><tt>TAG_String</tt><td>Store an <tt class="t">uint8_t</tt> array
	<p>The main difference between <tt>TAG_ByteArray</tt> is the maximal length of the array.
	<tr><th>9<td><tt>TAG_List</tt><td>Store an arbitrary number of a given object (which can be scalar or compound).
	<p><span class="n">Note</span>: a <tt>TAG_List</tt> of <tt>TAG_End</tt> is permitted
	if the number of items is 0.

	<tr><th>10<td><tt>TAG_Compound</tt><td>Store an arbitrary number of scalar/compound, not necessarily
	of the same types.
	<p>The last item of a compound, must be a <tt>TAG_End</tt>.
    <tr><th>11<td><tt>TAG_Int_Array</tt><td>Store an <tt class="t">uint32_t</tt> array.

	<p>Why is it not stored as a <tt>TAG_List</tt> of <tt>TAG_Int</tt>, you might ask ? Well, I guess someone forgot this
	type existed...
	<p>This type is used by the <tt>HeightMap</tt> entry of a chunk to store the highest
	value where sky light is at max level.
  </ul>
  </table>

  <li><b>2 bytes</b>: all types, except <tt>TAG_End</tt>, are followed by 2 bytes, which encodes a length
  <p><span class="n">Note</span>: keep in mind, that this length is stored as a big endian number.
  <li><b>[length] bytes</b>: will contain a string that is the name of this tag (not the value itself).
  <li><b><em>remaining</em></b>: payload section.
</ul>

<p class="item_name">PAYLOAD</p>

<p>Finally, here are the structure of the different payload sections, according to each tag:
<table>
<thead><tr><td>Num<td>Define<td>Description
<tbody>
  <tr><th>1<td><tt>TAG_Byte</tt><td>Followed by 1 byte: the integer value.
  <tr><th>2<td><tt>TAG_Short</tt><td>Followed by 2 bytes: the integer value in big endian format.
  <tr><th>3<td><tt>TAG_Int</tt><td>Followed by 4 bytes.
  <tr><th>4<td><tt>TAG_Long</tt><td>Followed by 8 bytes.
  <tr><th>5<td><tt>TAG_Float</tt><td>Followed by 4 bytes, encoding a floating point in big endian using the IEEE 754 format).
  <tr><th>6<td><tt>TAG_Double</tt><td>Followed by 8 bytes.
  <tr><th>7<td><tt>TAG_Byte_Array</tt><td>followed by:
    <ul>
	  <li><b>4 bytes</b>: encodes a length.
	  <li><b>[length] bytes</b>: content of the array.
	</ul>
  <tr><th>8<td><tt>TAG_String</tt><td>Followed by:
    <ul>
	  <li><b>2 bytes</b>: encodes a length.
	  <li><b>[length] bytes</b>: content of the string (usually UTF-8 encoded, not 0-terminated).
	</ul>
  <tr><th>9<td><tt>TAG_List</tt><td>Followed by:
    <ul>
	  <li><b>1 byte</b>: object type stored in this list (any types except <tt>TAG_List</tt>).
	  <li><b>4 bytes</b>: number of items in the list.
	  <li><b>...</b>: N objects of given type. In case of scalar, it will N times the size of given scalar.
	  For compound list the size can be completely arbitrary.
	</ul>
	<p class="cont"><span class="n">Note</span>: <tt>TAG_List</tt> of <tt>TAG_Compound</tt> are a bit special though:
	<ul>
	  <li>Compounds in a list don't have name. Therefore a compound entry in a list is simply a list
	  of scalar values until a <tt>TAG_End</tt> is found.
	  <li>The list ends when [N] compounds have been read (the list itself is not terminated by a <tt>TAG_End</tt>).
	</ul>
  <tr><th>10<td><tt>TAG_Compound</tt><td>Immediately followed by NBT tags (including nested compounds),
  one after the other, until a <tt>TAG_End</tt> is found.
  <tr><th>11<td><tt>TAG_Int_Array</tt><td>Followed by:
    <ul>
	  <li><b>4 bytes</b>: length of the array.
	  <li><b>[length] <tt>TAG_Int</tt></b>: content of the array.
	</ul>
	<p>Thanks to this type, 1 (ONE) byte is saved in the uncompressed stream over using a <tt>TAG_List</tt>.
</table>

<div class="important">Knowing all of this is kind of important, because, when an NBT is read into memory, it will mimic
this structure very closely (save a few alignment adjustment and endianess conversion). Also, when you'll
have to build a NBT fragment, you'll have to match this structure.</div>

<p class="item_name">EXAMPLE</p>

<p>Let's look at a small example:
<pre><span class="t">static uint8_t</span> nbt_stream[] = {
	<v>0x0A</v>, <v>0x00</v>, <v>0x00</v>, <v>0x02</v>, <v>0x00</v>, <v>0x03</v>, <v>0x6D</v>, <v>0x61</v>, <v>0x70</v>, <v>0x00</v>, <v>0x0C</v>, <v>0x00</v>
};
</pre>

<ol>
  <li>First byte is 10, which indicates the start of a compound.
  <li>Next 2 bytes are 0, 0: this is the length of the compound name. Since it is zero, the first 3
  bytes marks are the entirety of the compound header. Immediately following, will be a list of
  NBT tags, until <tt>TAG_End</tt> is found.
  <li>Next byte is 2, which is a <tt>TAG_Short</tt>.
  <li>Next 2 bytes are 0, 3, which means this entry has a name of 3 characters.
  <li>Next 3 bytes are 'm', 'a', 'p': this is the name of this tag (not its value).
  <li>Next 2 bytes (payload of a <tt>TAG_Short</tt>) is 0, 12, therefore the value associated to this
  entry is 12.
  <li>Finally 0 marks the end of the compound, and therefore end of the file.
</ol>

<p><span class="n">Note</span>: this is the structure of the file <tt>World/data/idcounts.dat</tt>.


<div class="sep" id="NBTspecapi"></div>

<h2>NBT Structure in API [ Module ]</h2>

<p>[ <a href="#content">Top</a> ]

<p class="item_name">INTRODUCTION</p>

<p>This section will explain how this API process NBT files at a high level: some of the techniques induce
a few caveats that you need to be aware before being able to understand this API.


<p>Like said in the previous sections, once read into memory, a NBT file is just <b>a contiguous memory
buffer</b>. If you look at the main type definition for a NBT file, that's all you'll find:
<pre><span class="t">struct</span> NBTFile_t
{
	<span class="t">int</span>   usage, max;
	<span class="t">int</span>   alloc, page;
	DATA8 mem;
};
</pre>

<p><tt>mem</tt> contains the NBT tags, <tt>usage</tt> is how many bytes are stored, <tt>max</tt> is how
many bytes have been allocated. <tt>alloc</tt> and <tt>page</tt> are only needed when reading the file
(and can be ignored/repurposed after that). This has a few <b>advantages</b>:
<ul>
  <li>All the information related to a NBT file is guaranteed to be <b>close in memory</b>: this is interesting
  to benefit from the CPU cache.
  <li>Since there is just a single buffer, the only thing to do to <b>free the memory</b> is to call <tt>free()</tt>
  on the <tt>mem</tt> field: no need to recursively scan all the entries of the file.
  <li>More often than not, you can get away by just <b>keeping the <tt>mem</tt> field</b> (ie: just a single
  pointer). Indeed, if you look at the API, some functions only accept a <tt>DATA8</tt> as for the NBT
  file. This buffer contains enough information to find everything (including end of buffer).
  <li>Likewise, if the only thing you have is a raw pointer to a NBT stream, a <tt>NBTFile_t</tt> can
  be trivially constructed by just assigning the <tt>mem</tt> field to that buffer. If the only thing
  you care is reading (and not modifying), the other fields don't matter.
</ul>

<p>Obviously, there are <b>drawbacks</b> to this approach:
<ul>
  <li>The abstraction provided by the API is kind of shallow: you have to be sure to replicate exactly
  the specification of a NBT file. For example, if you create a compound, you'll have to add the
  <tt>TAG_End</tt> manually, this API won't help you. This is harder than it seems, when compounds are
  nested, it is kind of easy to forget a <tt>TAG_End</tt> in the stream.
  <li>Adding/removing tags can be expensive. This API has ways to greatly mitigate that cost, but it
  will involve quite a bit of work.
</ul>

<p>Since the buffer <tt>mem</tt> can be reallocated, the API relies <b>heavily</b> on byte offset to
get a reference of a tag or a branch. Indeed, if you look at the API, almost all the functions have an
offset parameter in their list of arguments or return an integer as their result (<v>0</v> will always
be the beginning of the file and <v>-1</v> will signal an error). <b>This is the gist of this API</b>:
you first locate what you want to read/modify/delete, and <b>get an offset to the start of the tag</b>,
then you can do whatever operation you want on that tag.

<p class="item_name">STRUCTURE</p>

<p>This part is technically not required to read for using this API, but for the sake of completeness,
it is still described. This part will described <b>how the NBT file is stored in memory</b>.

<p>All NBT tags start with the following header (using native endianess for integer more than 1 byte long):

<bits>
  <brow><hdr>0: </hdr><bitpart class="sz16" bit="32">16: <em>count</em></bitpart><bitpart class="sz8" bit="16">8: <em>minNameSz</em></bitpart><bitpart class="sz4" bit="8"><em>subtype</em></bitpart><bitpart class="sz4" bit="4"><em>type</em></bitpart><bitpart class="sz0" bit="0"><em>&nbsp;</em></bitpart></brow>
  <brow><hdr>1: </hdr><bitpart class="sz32" bit="32">32: <em>size</em> (in bytes)</bitpart><bitpart class="sz0" bit="0"><em>&nbsp;</em></bitpart></brow>
  <brow><hdr>2: </hdr><bitpart class="sz32" bit="32">32: <em>name</em> (0-terminated)</bitpart><bitpart class="sz0" bit="0"><em>&nbsp;</em></bitpart></brow>
  <brow><hdr>... </hdr><bitpart class="sz32" bit="32">optionnal: more 32bit words follow to store the name</bitpart><bitpart class="sz0" bit="0"><em>&nbsp;</em></bitpart></brow>
</bits>

<p>Or visualized as a C struct:

<pre>
<span class="t">struct</span> NBTHdr_t
{
	<span class="t">uint8_t</span>  type;             <span class="c">/* TAG_* */</span>
	<span class="t">uint8_t</span>  minNameSz;        <span class="c">/* min name len: if 255 need to scan up to 0 byte */</span>
	<span class="t">uint16_t</span> count;            <span class="c">/* number of entries after this node (TAG_List only) */</span>
	<span class="t">uint32_t</span> size;             <span class="c">/* size of entire hierarchy under this node (including header + name) */</span>
	<span class="t">uint8_t</span>  name[<v>4</v>];          <span class="c">/* name of node (4-byte alignment) */</span>
};
</pre>

<p>Each field has the following purpose:
<ul class="space">
  <li><tt>type</tt>: the <b>lower 4bits</b> store the main type of the tag stored at this location.
  If the type is <tt>TAG_List</tt>, the <b>upper 4bits</b> store the type of tags stored in the list
  itself. A very common sub-type is <tt>TAG_Compound</tt>, therefore a dedicated define exists for
  these: <tt>TAG_List_Compound</tt>.

  <li><tt>minNameSz</tt>: encodes the <b>length of the <tt>name</tt> field</b> (<b>not</b> including
  padding bytes, and <b>not</b> including final <v>0</v>). This field is used internally to quickly
  have access to the payload section of the tag. This field being 8bits, it means that the maximal
  length of a tag name must be below 255 bytes. In practice, all tag names have less 64 characters.


  <li><tt>count</tt>: if the type of the tag is a <tt>TAG_List</tt>, this field will <b>store the number
  of items</b> in the list. You might see a limitation here: in the NBT structure, this field is 4 bytes,
  whereas here it is only 2. Indeed, in theory this might cause problem, in practice however, having
  more than 65535 items in a list has never happened.<br>
  <br>
  If this is causing problem in the future, some "bits" could be borrowed from the next field (<tt>size</tt>)
  to increase the precision of this one.

  <li><tt>size</tt>: this field stores the <b>size in bytes of entire tag</b>. This size is always a multiple
  of 4 bytes. The size is the size of the payload and the header. The idea is, if you have an offset
  from the start of a tag, adding the size field will bring you to the next NBT tag.<br>
  <br>

  This field is particularly critical to quickly find tags, without needing to scan entire hierarchies
  of tags. Tags are searched in breadth-first method: first, all the tag names of a given level are
  scanned, then if nothing is found, it will recursively scan sub-level.

  <li><tt>name</tt>: <b>name of the tag</b>: it is a direct dump from NBT stream. This string will always be
  NUL-terminated and padded so that the header size is always a multiple of 4 bytes. I.e: if the name
  of a tag is 4 characters, the <tt>name</tt> will have enough space to store 8.
</ul>

<p>The structure is therefore always at the start of every NBT you'll get from this API. Therefore, the
size of the file can also be retrieved in the first <tt>size</tt> field.

<p>All tags uses this header with the exception of <tt>TAG_End</tt>: this tag is actually encoded as
4 <v>NUL</v> bytes.

<p class="item_name">PAYLOAD SECTION</p>

<p><b>Payload immediately follows the structure header</b>. It will be padded to be a multiple of 4
bytes (so that next tag will start on a 4-bytes alignment). All scalar and list of scalars will be
converted to <b>native endianess</b>. This is somewhat useful for list, because you can ask for a raw
pointer to the start of the list, avoiding the need of extra copy/allocation. However, if the list is
short (most of them are), you will be better off asking the payload to be formatted in a certain way.

<p><b>For exemple</b>: some list (especially position of objects within 3d space) can be encoded as 3 <tt>TAG_Int</tt>,
3 <tt>TAG_Float</tt> or 3 <tt>TAG_Double</tt>. If you ask for a raw pointer, you'll have to check the
type and manually do the conversion. This API has functions to copy the content of a list to a specific
format.



<div class="sep" id="NBTpost"></div>

<h2>NBT post processing [ Module ]</h2>

<p>[ <a href="#content">Top</a> ]

<p class="item_name">INTRODUCTION</p>

<p>This API works rather well when all you want to do is read some data from a NBT file. Even modifying
arrays by directly overwriting payload section of said array is perfectly fine and efficient. However,
this API is not so efficient when you have to modify potentially big list of compounds: adding, removing
and modifying such a list could potentially be very expensive, since the only way to do that is to relocate
huge chunk of memory to make room for a particular NBT fragment. While the computing power available on
a modern CPU can easily handle that kind of load, there are more efficient ways to do this.

<p>The way it is handled in this API, is the ability to marks a <tt>TAG_List_Compound</tt> as being
modified, but not changing anything to the decompressed NBT stream. When time comes to save the changes,
a callback will be triggered and ask to provided an updated version of that list.

<p>A single NBT file can have multiple lists though: a typical chunk in a <tt>Minecraft</tt> map has
at least 3: <tt>Entities</tt>, <tt>TileEntities</tt> and <tt>TileTicks</tt>. Each of them could be modified
at the same time. When the callback is triggered, it needs to be informed about which list to rebuild.

<p>The rationale behind this approach is that when you create a new entity, block with a tile entity or
tile ticks, you'll have to allocate some memory and store them in some kind of list. Therefore, you'll
already have all items of a list somewhere, you just have to format them a bit to be saved on disk.


<div class="sep" id="NBTexample"></div>

<h2>NBT usage example [ Module ]</h2>

<p>[ <a href="#content">Top</a> ]

<p class="item_name">INTRODUCTION</p>

<p>This section will show a few common examples that can serve as quick refresher, or just in case you
don't want to learn everything and just want to get some minor stuff done. If you want to modify these
snippets of code, it is strongly encouraged to look at the definition of each function involved in the
snippets.

<p class="item_name">READING FILE</p>




<div class="sep" id="NBT_Parse"></div>

<h2>NBT_Parse [ Function ]</h2>

<p>[ <a href="#content">Top</a> ]

<p class="item_name">NAME</p>

<p class="desc"><tt>NBT_Parse</tt> - parse a gzip-compressed NBT file.

<p class="item_name">SYNOPSIS</p>

<p class="desc"><code><span class="t">int</span> <b>NBT_Parse</b>(NBTFile file, <span class="t">STRPTR</span> path);</code>

<p class="item_name">FUNCTION</p>

<p class="desc">Try to parse the given file name as a gzip-compressed NBT file. File opening is handled
by zlib, which means on Windows it is not unicode aware.

<p class="item_name">RETURN VALUES</p>

<p class="desc"><v>1</v> if the file was sucessfully read, <v>0</v> if something went wrong.

<p class="desc">The <tt>file</tt> parameter will also be ovewritten to contain the content of the
decoded NBT stream. the stream will be malloc()'ed and will have to be free()'ed by the caller at
some point when not needed anymore.


<p class="item_name">SEE ALSO</p>

<p class="desc"><a href="#NBT_ParseIO">NBT_ParseIO</a>, <a href="#NBT_ParseMem">NBT_ParseZlib</a>.

<pre>
int   NBT_ParseIO(NBTFile, FILE *, int offset);
int   NBT_ParseZlib(NBTFile, DATA8 stream, int bytes);
int   NBT_FindNode(NBTFile, int offset, STRPTR name);
int   NBT_FindNodeFromStream(DATA8 nbt, int offset, STRPTR name);
int   NBT_FindBranch(NBTFile, int offset, STRPTR branch);
int   NBT_Save(NBTFile, STRPTR path, NBT_WriteCb_t cb, APTR cbparam);
int   NBT_Iter(NBTIter iter);
int   NBT_FormatSection(DATA8 mem, int y);
int   NBT_SetHdrSize(NBTFile, int offset);
int   NBT_Insert(NBTFile, STRPTR loc, int type, NBTFile fragment);
int   NBT_AddOrUpdateKey(NBTFile, STRPTR key, int type, APTR value, int offsetTagList);
Bool  NBT_ToFloat(NBTFile, int offset, float * array, int nb);
Bool  NBT_ToString(NBTFile root, int offset, STRPTR buffer, int max);
int   NBT_ToInt(NBTFile, int offset, int def);
int   NBT_Size(DATA8 fragment);
void  NBT_MarkForUpdate(NBTFile, int offset, int tag);
void  NBT_InitIter(NBTFile, int offset, NBTIter);
void  NBT_IterCompound(NBTIter, DATA8 mem);
APTR  NBT_Payload(NBTFile, int offset);
APTR  NBT_ArrayStart(NBTFile root, int offset, int * size);
APTR  NBT_PayloadFromStream(DATA8 stream, int offset, STRPTR name);
Bool  NBT_SetFloat(NBTFile, int offset, float * array, int nb);
Bool  NBT_SetInt(NBTFile, int offset, int64_t val);
Bool  NBT_Add(NBTFile nbt, ...);
Bool  NBT_Delete(NBTFile nbt, int offset, int nth);
DATA8 NBT_Copy(DATA8 mem);
DATA8 NBT_Compress(NBTFile, int * size, int page, NBT_WriteCb_t cb, APTR cbparam);
</pre>

</div> <!-- content -->
</body>
</html>
