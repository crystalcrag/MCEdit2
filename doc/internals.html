<!DOCTYPE html>

<html>
<head>
  <title>Internals</title>
  <style type="text/css">
  html { font-family: Georgia, serif; margin: 0; padding: 0; font-size: 1.2vw }
  body { counter-reset: h2; padding-left: 18%; padding-top: 40px; background: url("images/bg.jpg") fixed; background-size: 100% 100%; margin: 0 }
  div#content { width: 80%; margin: 0 auto; padding: 60px 10px 60px; border: 32px solid #eee; border-width: 46px 43px 45px 32px; border-image: url(images/Book_and_Quill.png) 46 43 45 32 fill stretch round ;
  box-shadow: 0 0 10px black inset, 0 0 10px black }
  :nth-page(1) p { margin: 80px 0 }
  :nth-page(n+2) body { padding-top: 10px }
  p { text-align: justify; margin-left: 40px; margin-right: 10px }
  dd { margin-left: 40px; text-align: justify }
  dt { margin-left: 40px; page-break-after: avoid }
  h1 { background: black; color: white; padding: 9px 0 9px 40px; margin: 0 60px; text-align: center;
       box-shadow: #888 5px 5px 5px }
  h1 span { font-variant: small-caps }
  h2 { counter-reset: h3; border-bottom: 3px solid; page-break-before: always; margin-top: 80px; margin-left: 40px }
  h3 { counter-reset: h4; page-break-after: avoid; margin-left: 40px }
  h4 { page-break-after: avoid; margin-left: 40px }
  h5 { margin-left: 40px; text-align: center }
  h5::after { content: ""; width: 50%; display: block; border-bottom: 2px solid black; margin: 2px auto }
  h2:before { counter-increment: h2; content: counter(h2) ". "; font-size: 2em }
  h3 span:before { counter-increment: h3; content: counter(h2) "." counter(h3) ". " }
  h3 { border-bottom: 1px solid #555; }
  h4:before { counter-increment: h4; content: counter(h2) "." counter(h3) "." counter(h4) ". " }
  #abstract { font-size: 1.3em; font-style: italic; border-top: 1px solid black; border-bottom: 1px solid black; margin: 120px 40px; text-shadow: 2px 2px rgba(0,0,0,0.1) }
  #auth { text-align: center; margin-bottom: 200px }
  dt { border-bottom: 2px groove #ccc; font-weight: bold; padding: 2px 0; margin-left: 40px; margin-top: 10px; page-break-after: avoid }
  pre { margin: 20px 50px; border: 5px solid rgba(0,0,0,0.3); border-width: 1px 1px 1px 5px; background: rgba(255,255,255,0.3);
        padding: 10px 20px; font-family: monospace; tab-size: 4 }
  tt { font-weight: bold }
  table pre { margin: 0 }
  #content h2:first-child { page-break-before: auto }
  .nowrap { white-space: nowrap }
  table { margin-left: 40px }
  .sep { text-align: center; margin: -20px 0 -10px }
  .sep::after { content: "~"; color: #ccc; font-size: 4em }
  hr { width: 40% }

  .error { font-weight: bold; color: red }
  dd ol { margin-left: 60px }
  dd ol > li { margin-bottom: 5px }
  ul p, ol p, table p { margin-left: 0 }
  img { vertical-align: middle }
  blockquote { margin-left: 60px; font-style: italic; border-left: 10px solid #ccc; padding-left: 5px }
  table.selfref, ul, ol { margin-left: 40px }
  table.selfref td { padding-bottom: 8px }
  table.selfref ul, table.selfref ol { margin-left: 20px }
  ul.selfref { list-style-type: none }
  .selfref .marker { margin-right: 5px }
  li { margin-bottom: 15px }
  dim { color: rgba(0,0,0,0.3) }
  .key { background-color: #ddd; font-family: monospace; padding: 0px 3px; border-radius: 5px; border: 1px outset #860 }
  .image.vspace { margin-top: 40px; margin-bottom: 50px }
  .photo, .image { position: relative; margin: 20px 40px; text-align: center }
  .image img { margin: 0 auto }
  cap { font-size: 0.9em }
  .image > div,
  .image img { margin-left: 0 10px; display: block; box-shadow: #555 0 0 5px; border: 2px solid black }
  .marker { border: 2px solid orange; border-radius: 50%; padding: 0 5px; background-color: green; color: white; font-weight: bold;
            box-shadow: black 0 0 5px; text-decoration: none }
  .marker.alt { border: 0; background-color: transparent; border-radius: 0; box-shadow: none; margin-right: 1em }
  .marker.alt::before { border: 2px solid red; background-color: blue; border-radius: 0; transform: rotate(45deg);
                        position: absolute; width: 1em; height: 1em; content: ""; box-shadow: black 0 0 5px; z-index: 1 }
  .marker.alt::after { content: attr(num); position: relative; z-index: 2; color: white; left: 0.3em }
  .marker.fat { padding: 1px 2px }
  .marker.small { font-size: 0.8em }
  .markerv { border-left: 1px solid #66f; position: absolute; top: 0; bottom: 0 }
  .image .marker { position: absolute }
  .image .marker.alt .lined,
  .image .marker.alt .lineu,
  .image .marker.alt .linel,
  .image .marker.alt .liner { border-color: red }
  .image .marker.alt .lineu { margin-left: 4px }
  .image .marker .lined { border-left: 2px solid orange; position: absolute; left: 50%; top: 100%; box-shadow: black 0 0 5px }
  .image .marker .lineu { border-left: 2px solid orange; position: absolute; left: 50%; bottom: 100%; box-shadow: black 0 0 5px }
  .image .marker .liner { border-bottom: 2px solid orange; position: absolute; left: 100%; top: 50%; box-shadow: black 0 0 5px }
  .image .marker .linel { border-bottom: 2px solid orange; position: absolute; right: 100%; top: 50%; box-shadow: black 0 0 5px }
  .image .rect { border: 2px solid orange; position: absolute; box-shadow: black 0 0 5px }
  .center { text-align: center }
  a { color: brown }
  prod { font-style: italic; color: blue; font-weight: bold }
  note { background-color: yellow }
  #toc { position: fixed; top: 0; left: 0; width: 18%; bottom: 0; overflow: auto; color: white; border-right: 2px solid rgba(255,255,255,0.2);
         background: linear-gradient(to right, rgba(0,0,0,0.3), rgba(0,0,0,0.7)), url(images/dirt.png); background-size: 100% 100%, 64px 64px;
         padding: 20px; box-sizing: border-box; counter-reset: tocH2 }
  table td { vertical-align: baseline }
  #info th { text-align: right; vertical-align: baseline }
  #toc a:hover span { text-decoration-style: solid; text-decoration: underline; color: #99ee28 }
  #toc a { display: block; margin: 5px 0; color: white; text-decoration: none }
  #toc a.sub1 span { text-decoration: underline; text-decoration-style: dotted }
  #toc a.sub1 { counter-reset: tocH3 }
  #toc a.sub2 { margin-left: 60px; counter-reset: tocH4 }
  #toc a.sub3 { margin-left: 60px; color: #ccc }
  #toc a.sub4 { margin-left: 90px; color: #ccc }
  #toc a.sub1::before { counter-increment: tocH2; content: counter(tocH2) ". " }
  #toc a.sub2::before { counter-increment: tocH3; content: counter(tocH2) "." counter(tocH3) ". ";
                        position: absolute; left: 35px; width: 40px; text-align: right }
  #toc a.sub3::before { counter-increment: tocH4; content: counter(tocH2) "." counter(tocH3) "." counter(tocH4) ". " }

  p.warning { font-family: sans-serif; font-weight: bold; color: red; font-size: 0.9em; margin-left: 60px; margin-right: 20px }

  .listview { border-collapse: collapse; margin-left: 40px }
  .listview td { border: 2px solid black }
  .listview caption { padding: 10px; font-weight: bold; border: 2px solid black; border-bottom: 0 }
  .listview caption.small { border: 0 }
  .listview caption.small::after { content: ""; width: 50%; display: block; border-bottom: 2px solid black; margin: 2px auto }
  .listview ul { margin-left: 0 }
  .listview thead td { background-color: black; color: white; text-align: center }
  .listview.BC2 tbody td:nth-child(n+2) { text-align: center }
  .listview.pad td { padding: 3px 8px }

  .danger { background-color: yellow; border: 1px solid #FF8800; border-width: 1px 0; color: red }
  .warn   { color: #aaa }
  code    { background-color: white; border: 1px solid #888; padding: 2px 5px }
  sans    { font-family: sans-serif }
  usrcls  { background-color: crimson; border-radius: 1em; padding: 0 0.5em; font-size: 0.8em; font-family: sans-serif; color: white }
  .fig { text-align: center }
  .fig cap { display: block; font-size: 0.8em }

  .imgcaption { display: inline-block }
  .imgcaption img { display: block; margin: 0 auto }
  .imgcaption .caption { display: block; text-align: center; font-size: 0.9em }
  .imgcaption.margin { margin-left: 40px }

  table.skewed { transform: skewx(-35deg); transform-origin: 0 100%; margin-bottom: 5px; box-shadow: 18px 15px rgba(0,0,0,0.1) }
  table.skewed td { border-width: 2px; padding: 5px; width: 30px; text-align: center; font-family: monospace }
  table { border-collapse: collapse }
  table thead td { background-color: black; color: white }
  table td { border: 1px solid black; padding: 3px }
  .c  { color:#2222AA }
  .i  { color:#54AAAA }
  .d  { color:#A600F7 }
  .o  { color:#FF00FF }
  .s  { color:#7700FF }
  .t  { color:#146A31; font-weight:bold }
  .k  { color:#A62828; font-weight:bold }
  .e  { color:#FFFFFF; background-color:#FF3333 }
  .n  { color:black;   background-color:#FFFF00 }
  .h  { font-weight: bold }

  .shortcut { background-color: white; font-family: monospace; padding: 0px 3px; border-radius: 5px; border: 1px outset #860 }
  </style>
</head>
<body>

<div id="toc">
<a class="sub1" href="#conventions"><span>Conventions</span></a>
  <a class="sub2" href="#coord"><span>Coordinate system</span></h3>
  <a class="sub2" href="#faceorder"><span>Face enumeration order</span></h3>
  <a class="sub2" href="#datatypes"><span>Datatypes</span></h3>

<a class="sub1" href="#culling"><span>Frustum culling</span></a>
  <a class="sub2" href="#firstvers"><span>First version</span></a>
  <a class="sub2" href="#impl"><span>Implementation</span></a>
  <a class="sub2" href="#neighbors"><span>Enumerating neighbors</span></a>
  <a class="sub2" href="#edgecase"><span>Edge cases</span></a>
  <a class="sub2" href="#crossplane"><span>Cross-plane faces</span></a>
  <a class="sub2" href="#caveats"><span>Caveats</span></a>
  <a class="sub2" href="#fakechunks"><span>Fake chunks</span></a>
  <a class="sub2" href="#outside"><span>Outside bounds</span></a>
  <a class="sub2" href="#cavecull"><span>Cave culling</span></a>

<a class="sub1" href="#blocks"><span>Block API</span></a>
  <a class="sub2" href="#blockdesc"><span>Block description</span></a>
  <a class="sub2" href="#statedesc"><span>State description</span></a>
  <a class="sub2" href="#blockmodel"><span>Block models</span></a>

<a class="sub1" href="#mesh"><span>Mesh generation</span></a>

<a class="sub1" href="#opengl"><span>Advanced OpenGL</a>
  <a class="sub2" href="#translucency"><span>Alpha transparency</span></a>
  <a class="sub2" href="#gpubanks"><span>Managing chunks on GPU</span></a>

<a class="sub1" href="#nbt2"><span>NBT API</a>

<a class="sub1" href="#entities"><span>Entities</span></a>
  <a class="sub2" href="#structure"><span>Data structure</span></a>
  <a class="sub2" href="#collision"><span>Collision correction</span></a>
</div>

<div id="content">

<h1>MCEdit internals</h1>

<div id="abstract"><u>Abstract:</u>
<p>Some of the algorithms and data structures used in MCEdit 2.0 are not that trivial to understand by looking at the source
code, even heavily commented, especially since the rendering engine makes heavy use of what appears to be cryptic static tables.
This document will provide in-depth explanation for some of them.

<p><b>Pre-requisite</b>: knowledge of OpenGL, 3D math and C programming language.
</div>

<p id="auth">Written by T.Pierron, July 2020</p>

<h2>Conventions</h2>

<p>Before reading this document further, there are a few facts to keep in mind, because they are used
quite extensively throughout the engine. To avoid repeating them over and over again, here is what needs
to be known:

<h3 id="coord"><span>Coordinate system</span></h3>

<div class="photo" style="float:left">
  <img src="images/axis.svg">
</div>

<p>The <b>coordinate system uses a left hand axis</b>. X is mapped to east-west (increasing X goes to east,
decreasing goes to west). Z is mapped to north-south (increasing Z goes to south, decreasing goes to
north). Y is elevation.

<p>Meshes of various objects use a counter-clockwise (CCW) orientation to check if they are front-facing.

<p>Coordinates are relative to player (ie: if you want an object close to camera, coordinates must
be close to player position, not 0,0,0). <span class="n">XXX</span> That's not good actually :-/


<h3 id="faceorder"><span>Face enumeration order</span></h3>

<p>Whenever there is a need to enumerate nearby objects within the voxel space, the <b>same order will
be used almost everytime</b>. For example: to enumerate the 6 nearby voxels a given block is directly
connected to, to enumerate the 6 neighbors a given chunk is connected to, to generate the mesh of the
6 faces a given cube is composed of, ... these will always be done in the same order:
<ol>
  <li><b>South</b>
  <li><b>East</b>
  <li><b>North</b>
  <li><b>West</b>
  <li><b>Top</b>
  <li><b>Bottom</b>
</ol>

<p>Keep that order in mind, it is <b><u>used extensively</u></b> in one form or another throughout the entire code
base. It can be used as indices in a for-loop from 0 to 5, be used as a bit field to remember which
sides have been visited (therefore have values from 0 to 63), or simply as a enumeration value
(<tt>SIDE_*</tt>).

<p>You'll often see the abbreviation <tt>S,E,N,W,T,B</tt> (or sometimes just <tt>S,E,N,W</tt>) throughout
the code base, this is a reminder of this order.

<p>Technically, there are no obligations to respect that order all over the place, but it makes it easy
to reuse the same look-up tables over and over again, without having to worry about compatibility.

<h3 id="datatypes"><span>Datatypes</span></h3>

<p>Datatypes in the engine follows a small, but kind of helpful convention: if a structure has to be
declared as a value, <b>it is not</b> typedef'ed, and the name <b>always have</b> a trailing <tt>_t</tt>
(the t stands for <tt>type</tt> of course).

<p>If there are no trailing <tt>_t</tt> and no <tt class="t">struct</tt>, therefore it is a pointer. Consider the
following example:
<pre><span class="t">struct</span> BlockIter_t iter;
BlockIter iterator;</pre>

<p>From this convention, you know the second declaration is a pointer to a <tt><span class="t">struct</span> BlockIter_t</tt>.

<p>Sometimes a typedef is introduced for <tt class="t">struct</tt> to remove the need to type this keyword,
because the type itself is used quite extensively. For example:
<pre><span class="t">typedef struct</span> NBTIter_t     NBTIter_t;
<span class="t">typedef struct</span> NBTFile_t     NBTFile_t;</pre>
<p>But, the type will keep the <tt>_t</tt> suffix to indicate it is a value type, not a pointer.


<h2>Frustum culling</h2>

<p>Frustum culling refer to the algorithm that can enumerate all the objects that are visible within
the model-view-projection matrix. It is usually a compromise between precision of object's bounding
box and computational power required to test those bounding boxes: we cannot spent too much time on
the CPU checking for object's visibility (because in the meantime the graphics card could have probably
already drawn this object) and on the other hand, including out-of-view objects, will requires useless
work for both the CPU and the GPU.

<p>The techniques used in this engine are not particularly revolutionary, but it uses <b>a lot of</b>
little tricks that makes the source code particularly cryptic.

<p>A <prod>Minecraft</prod> terrain is composed of a grid of chunks: axis-aligned boxes of 16x16x16 voxels.
A grid means they share a lot of vertices: if we know that one corner of a chunk fits within the frustum,
we can automatically add the 7 others chunks that share this vertex.

<p>In other words by testing only one vertex, we can potentially add up to 8 chunks to the list of visible
objects. Which means  on average, we will have to <b>test one point per chunk</b>. <em>That is extremely 
cheap</em>.

<p>Testing if a vertex is part of a frustum is actually very easy: we can use the MVP matrix (the exact
same one that will be used in the vertex shader), by simply multiplying that matrix with the coordinates
of our vertex (using 1 as the fourth vector component). That is:
<pre>V<sub>p</sub> = MVP * V</pre>
<p>Then to test if a vertex is inside the frustum, we can simply use the properties of homogeneous coordinates:
<pre>Vp is in frustum if:
	-V<sub>pw</sub> &lt;= V<sub>px</sub> and V<sub>px</sub> &lt;= V<sub>pw</sub> and
	-V<sub>pw</sub> &lt;= V<sub>py</sub> and V<sub>py</sub> &lt;= V<sub>pw</sub> and 
	-V<sub>pw</sub> &lt;= V<sub>pz</sub> and V<sub>pz</sub> &lt;= V<sub>pw</sub>
</pre>

<p><tt>V<sub>pw</sub></tt> is the fourth component of our projected point. More precisely, each of
these inequalities check if the coordinate is outside one of the 6 planes that defines the frustum.
We'll need that information later.

<p>In this engine, a <tt>struct Chunk_t</tt> (or <tt>Chunk</tt> if you just want a pointer) is a datatype
that reference an entire column of 16x16 blocks of terrain. A <tt>struct ChunkData_t</tt> (or <tt>ChunkData</tt>
as a pointer type) contain all the data (block IDs, sky light, block light, meta-data, ...) for one
16x16x16 blocks of terrain. Keep those datatypes in mind, they will be used throughout this section.

<h3 id="firstvers"><span>First version (pseudo-code)</span></h3>

<p>So, a first version for this algorithm would be (here in pseudo-code):

<pre><span class="c">/* Naive frustum culling */</span>
<span class="o">&lt;visible&gt;</span> as <span class="t">List</span> := empty
<span class="o">&lt;visible&gt;</span>.add(chunk where player is)

<span class="k">For</span> i := 1 to <span class="o">&lt;visible&gt;</span>.Count
   <span class="o">&lt;chunk&gt;</span> as <span class="t">ChunkData</span> := <span class="o">&lt;visible&gt;</span>[i]
   <span class="o">&lt;chunk&gt;</span>.visited := true
   <span class="k">For</span> j := 1 to 8
   <dim>|</dim>  <span class="o">&lt;vertex&gt;</span> as <span class="t">vec4</span> := corner j of <span class="o">&lt;chunk&gt;</span>
   <dim>|</dim>  <span class="k">If</span> <span class="o">&lt;vertex&gt;</span> is in frustum <span class="k">Then</span>
   <dim>|  |</dim>  <span class="k">For</span> k := 1 to 8
   <dim>|  |  |</dim>  <span class="o">&lt;neighbor&gt;</span> as <span class="t">ChunkData</span> := k<sup>th</sup> chunk sharing <span class="o">&lt;vertex&gt;</span>
   <dim>|  |  |</dim>  <span class="k">If</span> Not <span class="o">&lt;neighbor&gt;</span>.visited then
   <dim>|  |  |  |</dim>  <span class="o">&lt;visible&gt;</span>.add(<span class="o">&lt;neighbor&gt;</span>)
   <dim>|  |  |</dim>  <span class="k">End if</span>
   <dim>|  |</dim>  <span class="k">End for</span>
   <dim>|</dim>  <span class="k">End if</span>
   <span class="k">End for</span>
<span class="k">End for</span>
</pre>

<p>That algorithm seems pretty simple, but lacks <b>a lot</b> of house-keeping required to achieve our
goal of one vertex checked per chunk.

<p>As simple as this version is, it already has a few interesting properties:
<ul>
  <li>There was no particular constraints on the MVP matrix, and indeed this algorithm will work for <b>any projection</b> (orthogonal,
  perspective) <b>any FOV</b> and any <b>render distance</b> (near and far plane).
  <li>The list of chunks will mostly be sorted from front to back. It is not perfect, but good enough to trigger some early depth culling
  from the GPU.
</ul>

<h3 id="impl"><span>Implementation (C code)</span></h3>

<p>Sadly, the implementation is a lot more complex than this though. Most of the complexity is to deal
with edge cases though. If you look at the datatype needed for generating the visible list, you can
see there are a few static tables:
<pre style="font-size: 1vw"><span class="t">struct</span> Frustum_t
{
   <span class="t">int32_t</span> neighbors[<span class="o">8</span>];       <span class="c">/* 8 corners having 8 neighbors: bitfield encode 27 neighbors */</span>
   <span class="t">uint8_t</span> chunkOffsets[<span class="o">27</span>];   <span class="c">/* bitfield of where each chunks are (S, E, N, W, T, B) */</span>
   <span class="t">uint8_t</span> faces[<span class="o">6</span>*<span class="o">4</span>];         <span class="c">/* cross-plane faces */</span>
   <span class="t">uint8_t</span> faceDir[<span class="o">6</span>];         <span class="c">/* direction to go to find chunk connected to face */</span>
   <span class="t">uint8_t</span> firstFree[<span class="o">256</span>];     <span class="c">/* fake chunk allocator */</span>
   <span class="t">float</span> * mvp;                <span class="c">/* model-view-projection matrix (4x4) */</span>
};
</pre>

<p>To achieve what's described in the first algorithm, we only need the first 2 tables: <tt>neighbors</tT> and <tt>chunkOffsets</tt>.

<div class="photo" id="vtxorder" style="float: right; width: 25%; margin: 0 0 0 20px">
  <img src="images/cube.svg" width="100%">
  <cap>Vertex order of a chunk</cap>
</div>

<p>The order of each corner of a chunk is illustrated with the figure on the right. Each of these
corners can potentially add 8 chunks, if that corner is contained within the frustum. By overlapping
all those connected chunks you get a 3x3 cube of chunks. Therefore, the maximum number of connected
chunks you can have from those 8 corners is 27.

<p>This is what encodes the <tt>neighbors</tt> table: each of these 27 chunks are given a number
between 0 and 26, and therefore can be encoded as a bitfield in a 32bit integer. The order is shown below
(axis is the same as the figure on the right):

<table class="skewed">
<tr><td>18<td>19<td>20
<tr><td>21<td>22<td>23
<tr><td>24<td>25<td>26
</table>

<table class="skewed">
<tr><td>9<td>10<td>11
<tr><td>12<td><span class="o">13</span><td>14
<tr><td>15<td>16<td>17
</table>

<table class="skewed">
<tr><td>0<td>1<td>2
<tr><td>3<td>4<td>5
<tr><td>6<td>7<td>8
</table>

<p><tt>13</tt> is therefore the chunk we are currently in. For example, if we checked that vertex
<tt>0</tt> of a chunk is within the frustum, we know we can also add chunks <tt>0</tt>, <tt>1</tt>, <tt>3</tt>,
<tt>4</tt>, <tt>9</tt>, <tt>10</tt> and <tt>12</tt>. Chunk 13 is not included, because at this point
we already know that the center chunk is part of the frustum. Encoded as bitfield, with the n<sup>th</sup>
bit set if chunk number <tt>n</tt> is in the frustum, the 7 chunks to add for vertex 0 can be encoded
as <tt>2<sup>0</sup> + 2<sup>1</sup> + 2<sup>3</sup> + 2<sup>4</sup> + 2<sup>9</sup>
+ 2<sup>10</sup> + 2<sup>12</sup> = 5659</tt>, and so on for the other 7 corners: that's what is
stored in the <tt>neighbors</tt> table.


<h3 id="neighbors"><span>Enumerating neighbors</span></h3>

<p>To enumerate all the connected chunks, we'll check if each corner of a chunk is within the frustum
and accumulate those neighbor bitfields into a 32bit integer. Then, we can just use the <tt>chunkOffsets</tt>
table to locate the n<sup>th</sup> chunk (with <tt>n</tt> varying from 0 to 26). Therefore this table
will have 27 elements. Each element is a bitfield with the following meaning:
<ul>
  <li>bit 1 set: move to the <b>south</b> (+Z).
  <li>bit 2 set: move to the <b>east</b> (+X).
  <li>bit 3 set: move to the <b>north</b> (-Z).
  <li>bit 4 set: move to the <b>west</b> (-X).
  <li>bit 5 set: move to the <b>top</b> (+Y).
  <li>bit 6 set: move to the <b>bottom</b> (+Y).
</ul>

<p>That order (<tt>S, E, N, W, T, B</tt>) is used <b>extensively</b> throughout the engine (especially for generating
the mesh of a chunk) and as such there are a lot of helper functions that can use this bitfield directly.

<p>If the chunk is tagged by the bitfield, it is then added at the end of the visible list, to be
scanned later to see if we can reach new chunks from here. We continue then until the entire list
has been scanned.

<h3 id="edgecase" style="clear: both"><span>Edge cases</span></h3>

<p>This first version easily <b>covers around 90% to 99%</b> of the chunks we need to enumerate, but
it can miss some especially around the corners of frustum. For the corners of the far plane it is
usually not that much of a big deal, but for the corners of the near plane, this is not acceptable.
This first version also breaks down when the FOV gets too small. Consider the following frustum:

<div class="image">
  <img src="images/fov10deg.png">
  <cap>Frustum with a 10&deg; FOV</cap>
</div>

<p>Technically, a frustum should be more of a trapezoidal shape, but the parameters used for the near and far plane in
<prod>MCEdit 2.0</prod> are respectively 0.1 and 1000, which gives almost a triangular shape.

<p>You can see here that none of the vertex from the corners of every chunks fit within the frustum. Yet, the frustum does indeed
cross some chunks. How do we enumerate these?

<p>For these, we can use the properties of homogeneous coordinates, when checking if a point is in the frustum: 

<pre>Vp is in frustum if:
	-V<sub>pw</sub> &lt;= V<sub>px</sub> and V<sub>px</sub> &lt;= V<sub>pw</sub> and
	-V<sub>pw</sub> &lt;= V<sub>py</sub> and V<sub>py</sub> &lt;= V<sub>pw</sub> and 
	-V<sub>pw</sub> &lt;= V<sub>pz</sub> and V<sub>pz</sub> &lt;= V<sub>pw</sub>
</pre>

<p>Each of these inequalities tells us on which side of each plane the point is. For example if <tt>V<sub>pz</sub> &lt; -V<sub>pw</sub></tt>
is true, that means the point is behind the near plane. Similarly, if <tt>V<sub>pz</sub> &gt; V<sub>pw</sub></tt> is true, the point is beyond the
far plane, and so on...

<h3 id="crossplane"><span>Cross-plane faces</span></h3>

<p>We can then keep track of which plane the point is outside of, using a bitfield. Since there are
6 planes, a single byte will be enough. That is the purpose of the <tt>outflags</tt> table in the
<tt><span class="t">struct</span> Chunk_t</tt> type: keep track of which planes the origin corner
of each sub-chunk (16x16x16 area, <tt><span class="t">struct</span> ChunkData_t</tt> in the
code) is outside of. The origin corner is the location of block 0, 0, 0 within the chunk.

<p>Therefore to get the <tt>outflags</tt> values of the 8 corners of a <tt>ChunkData</tt>, we will
have to extract them from the 4 neighbor chunks (<tt><span class="t">struct</span> Chunk_t</tt>):
for example the <tt>outflags</tt> value for the coordinate <tt>chunk.x + 16, chunk.y, chunk.z</tt>
is located in the chunk directly to the east of <tt>chunk</tt>: that is how we achieve one matrix
test per <tt>ChunkData</tt> (on average).

<p>For each <tt>ChunkData</tt> we want 8 <tt>outflags</tt> values: one per corner, that we
need to compute and/or extract from nearby chunks. Once we have this information, we can check if a
<b>face</b> of the <tt>ChunkData</tt>'s bounding box crosses two planes: each face is composed of 4
segments and given 2 points that form a segment, this segment crosses two planes if the corresponding
<tt>outflags</tt> value of these points have at least <b>2 bits</b> that differ. Using the C language,
this can be trivially done using a XOR operation:

<pre><span class="t">int</span>    pt1, pt2;      <span class="c">/* we'll see how to enumerate these in a bit */</span>
<span class="t">int8_t</span> flagsPt1 = outflags[pt1];
<span class="t">int8_t</span> flagsPt2 = outflags[pt2];

<span class="k">if</span> (popcount(flagsPt1 ^ flagsPt2) &gt;= <span class="o">2</span>)
{
	<span class="c">/* segment crosses more than 2 planes */</span>
}</pre>

<p><tt>popcount()</tt> is the typical function name for counting the number of 1 bits in an integer,
it is a shorthand for <b>pop</b>ulation <b>count</b>. Since we are using 6 bit integers, we could
have used another lookup table, but most CPU nowadays have a dedicated instruction for this,
which are even <a href="https://github.com/BartMassey/popcount">faster</a> than a lookup table.

<p>If just one segment from the face crosses two or more planes, we consider the entire face as crossing
them too.

<p>In the implementation, two tests were added to <b>eliminate as early as possible some degenerate cases</b>.
Even though the code down the line is able to eliminate those, we might as well remove them as early as possible,
since those tests are very cheap.

<p>The first test check if all the <tt>outflags</tt> of a given face have their coordinates
outside the frustum, using a test like this:
<pre>sector1*sector2*sector3*sector4 != <span class="o">0</span></pre>
<p>If one face has a coordinate inside the frustum (<tt>outflags == <span class="o">0</span></tt>),
the nearby chunk will already be added by the first pass of the algorithm. Then the second test is:
<pre>sector1&amp;sector2&amp;sector3&amp;sector4 == <span class="o">0</span></pre>
<p>This test ensure that not all the coordinates are on the same side of a plane. This happen
quite often at the starting chunk position: coordinates of a face are all to the left/right of a
plane, but also cross the top/bottom planes, therefore will be considered a cross-plane face and
an useless chunk will be added to the list. Not that much of a big deal, but since they are easy
to eliminate, might as well do it.


<h3 id="caveats"><span>Caveats</span></h3>

<p>These two passes will cover 99% of the use cases, even though there will still be cases where a
chunk will be included in the frustum, when it clearly does not belong. Consider the following example:

<div class="image">
  <img src="images/falsepositiv.png">
</div>

<p>The white square next to the starting chunk shouldn't be included in the visible list. What happened here,
is that the segment <tt>[0,2]</tt> crossed the left and right plane ... but outside the frustum. Because the
result of those inequalities we stored in the <tt>outflags</tt> table supposed that those planes extend to
infinity. Therefore point 0 will be considered <b>both</b> to be on left of the left plane <b>and</b> to the
right of the right plane.

<p>In practice, those false positives are quite rare, less than 1&permil;. It would be pointless to add extra
code to eliminate those. All the vertices from these chunks will be eliminated in the vertex shader, without
even reaching the fragment shader. As long as there aren't too many of these, performance loss will be negligible.

<h3 id="fakechunks"><span>Fake chunks</span></h3>

<p>But we are not done yet. A <prod>Minecraft</prod> map is composed of column of chunks. Those
columns are not all of equal height, far from it. Here's a XY slice view of a typical landscape:

<div class="image">
  <img src="images/sliceview.png">
</div>

<p>The yellow lines shows the sub-chunk boundaries, cyan chunks with no writings in it, indicate an
empty chunk: nothing is allocated for these, attempting to get a <tt>ChunkData</tt> for these will
return <tt class="o">NULL</tt>. Player is currently in one of those empty area, looking left, therefore
the algorithm will have no starting point, and as is, will generate an empty list of visible chunks.
Not good.

<p>If that's the case, a fake chunk will be created for the sole purpose of tracking where we are and
to check where we can go next. Those sub-chunks are actually cheap to allocate because we only need
a small subset of the fields contained in a <tt>ChunkData</tt> structure (we only need 2 actually,
about 20 bytes): those chunks are therefore allocated in batch of 32, with their memory layout
overlapping the fields we don't need.

<p>But to prevent allocating useless fake chunks, we only allocate one if it has a lower Y coordinate
than the previously visited. Fake chunks only have to be alloced above ground, therefore if we want
to find something to display, we need to go down (lower Y value). That's the purpose of <tt>cdIndex</tt>
field in a <tt>struct Chunk_t</tt>.

<h3 id="outside"><span>Outside bounds</span></h3>

<p>Fake chunks work fairly well as long as we remain within build limit. Even if the engine would allow
unlimited build height, it would be pointless to allocate a gigantic column of fake chunks just to reach
the ground level, because we can do this by using some simple geometry. And besides, a geometric
approach is required when the player is below the bottomest chunk (i.e.: <tt>Y &lt; 0</tt>).

<p>Again, the problem here is that the frustum culling won't have a starting point, worse: <b>it cannot
have one</b>, because there is no place in the <tt>Chunk</tt> structure to store a reference, even for a
fake chunk.

<p>/* ... */

<h3 id="cavecull"><span>Cave culling</span></h3>

<p>There is one last step that is done at the same time: cave culling, or removing chunks that are completely
hidden by nearer chunks. A good primer on how this algorithm works can be read from the original
<a href="https://tomcc.github.io/2014/08/31/visibility-1.html">author</a> that developped it for Minecraft MCPE.
The version implemented in this engine is <b>way simpler</b> than that. At the cost of (slightly) more
chunks being drawn.

<p>The basic principle behind this implementation of the cave culling is this: <b>a cube viewed using
a perspective projection matrix has at most 3 faces visible</b>. If we can somewhat "prove" that those
faces are hidden, we can then discard the entire chunk from the visible list.

<p>First, we need to know which face is visible according to player position and orientation. This can
easily done using a vector dot product between vector that goes from camera to one of the vertices of
the face (any vertex will do) and the normal of the face: if that number is negative, the face is hidden.

<p>Then, for the faces that are potentially visible, we can check if the face they are connected to is
completely opaque. If that's the case, there are no way the user will be able to see that face. If all
the visible faces are obscured, the entire chunk can be omitted.

<p>This simple trick works relatively well for caves, where there are usually lots of solid blocks all
around. It is not as advanced as the algorithm described above, but given how cheap it is, it is a
trivial optimization to do.

<h2 id="blocks">Block API</h2>

<p>This section will describe how the block description table works (<tt>blocksTable.js</tt>). This
table describes all of the blocks recognized by this engine and their different states, along with
their custom models if any.

<p>This table does not cover 100% of use cases though: you cannot change it and expect to have a
completely different "game". Some special processing is hardcoded within the engine (like redstone
behavior, block with tile entities). Still, this table is used to define a huge chunk of the engine
behavior.

<p>This table uses the javascript object notation format. It is similar to the JSON format, with a few
changes: property names don't have to be enclosed in double quotes and property values can contain expressions.

<p>For the sake of simplifying the parsing, property names have to start with a <b>lower case letters</b>,
constants assigned to property must be spelled using only <b>uppercase letters</b>.

<p>This table contain <b>2 types of objects</b>:
<ol>
  <li><b>Block description</b>: contain generic information about the block, like its type, id,
  name, inventory category, inventory model, ... That information must remain true for all states.
  If that's not the case, some properties can also be declared at the state level.
  <li><b>State description</b>: also known as meta-data. Each block in the terrain can have up to 4bits
  of extra information, that can describe 16 different states. This is the purpose of these objects:
  provide a complete description of one state: custom mesh model and/or texture coordinate if block
  is completely solid. Not all 16 states have to be defined, but at least 1.
</ol>

<h3 id="blockdesc"><span>Block description</span></h3>

<p>A block description must contain the property <tt>id</tt> and be assigned to an integer. Here are the
possible properties:
<ul>
  <li><tt>id</tt>: the block ID as it is stored in the NBT table <tt>Sections/Blocks</tt> of a chunk.
  <li><tt>type</tt>: how the block will be rendered in the world. This field will constraint what is
  expected for state description. <b>This is a very important field</b>, you can choose one value among:
  <ul>
    <li><tt>INVIS</tt>: invisible. No mesh vill be generated for these (typical use case: AIR).
    <li><tt>SOLID</tt>: a full 1x1x1 voxel cube. This engine is optimized to display these. They are
	cheap to process, cheap to render and cheap to define: just specify the texture of the 6 sides of
	the cube and that pretty much all there is to it.
	<p>Note: stairs and slab are considered SOLID blocks.

    <li><tt>TRANS</tt>: Similar to SOLID, they must be defined as a full unit cube. The difference is
	in the way hidden surface removal works: for SOLID blocks, all sides shared by any other solid block
	will be removed. For TRANS block, this check will only be done with the same block id (typical use
	case: glass or water).
    <li><tt>QUAD</tt>: for blocks that are a mix of flat quads that does not necessarily forms a cube.
	Typical use case: crops, grass or flowers.
    <li><tt>CUST</tt>: completely arbitrary shape, a custom model will be expected for each state
	description. Keep in mind that the model cannot exceed a 2x2x2 cube in size. If you need more,
	you will have to use an dedicated entity otherwise.
  </ul>
  <li><tt>name</tt>: a human readable name that will be displayed in various places of the engine.
  <li><tt>tech</tt>: the technical name stored in inventories. If the name is the same as the <tt>name</tt>
  field (but converted to lowercase and space replaced with underscore), you can omit that field.
  <li><tt>inv</tt>: how this block is going to represented in inventory menus. It is an enumeration
  value that can be assigned to one of the following values:
  <ul>
    <li><tt>CUBE</tt>: each individual states will have its own inventory item in the form of a cube. The
	textures used for the cubes will be described in the state description. In the screenshot below, cube
	inventory items have been highlighted with a green background.
    <li><tt>ITEM2D</tt>: each states will be represented as flat 2d texture (taken from state description).
	In the screenshot below, they have a gray background.
    <li><tt>MODEL</tt>: wil use a custom model for their inventory. The model will be viewed at an angle
	using a orthographic projection (not a perspective one). You can provide a custom model to be used
	only in inventories, or you can reuse the ones defined in the state description. In the screenshot
	below, those items have been highlighted with a red background.
  </ul>
  <div class="image">
    <img src="images/inventory.png">
  </div>
  <li><tt>invstate</tt>: sometimes, you don't want to have one inventory item per state, but only one
  (typcial use case: blocks that have an orientation). If this field is present, it must contain the
  state id (between 0 and 15) to use when displaying this item in inventories.
  <li><tt>cat</tt>: the creative menu is split into tabs. This field let you choose which one it will
  be in. If not specified, the item will appear in the "all" category (the tab with the compass, in the
  screenshot above). You can choose one value among;
  <ul>
    <li><tt>BUILD</tt>
	<li><tt>DECO</tt>
	<li><tt>REDSTONE</tt>
	<li><tt>CROPS</tt>
	<li><tt>RAILS</tt>
  </ul>
  <li><tt>special</tt>: special behavior to activate in the engine. Possible choices:
  <ul>
    <li><tt>CHEST</tt>: chest that can form a 2-wide entity. Therefore, that does not include ender chest.
    <li><tt>DOOR</tt>: behave like a door: 2 tall block with the same data values.
    <li><tt>NOSIDE</tt>: will generate a front and back face (typical use is for QUAD block type).
    <li><tt>HALF</tt>: half block: data values will encode placement.
    <li><tt>STAIRS</tt>: data value will encode orientation.
    <li><tt>GLASS</tt>: behave like a glass pane: automatically connect to nearby block with this
	special attribute set (like glass pane and iron bars).
    <li><tt>FENCE</tt>: wooden fences that connect with similar block.
    <li><tt>FENCE2</tt>: nether fence (does not connect with FENCE).
    <li><tt>WALL</tt>: cobblestone wall and variants: it connects with more block than FENCE or GLASS.
    <li><tt>RSWIRE</tt>: used for redstone wire only: wire model depends on nearby blocks.
    <li><tt>LEAVES</tt>: hidden surface must not be removed.
    <li><tt>LIQUID</tt>: water and lava.
    <li><tt>TALLFLOWER</tt>: need a special flag for these, because they are made of 2 blocks.
    <li><tt>RAILS</tt>: this flag is used when placing rails to know which neighbor to update.
    <li><tt>TRAPDOOR</tt>: block update from redstone/user.
    <li><tt>SIGN</tt>: they need special processing (allocate off-screen texture).
    <li><tt>PLATE</tt>: pressure plate (needed for redstone signal).
    <li><tt>SOLIDOUTER</tt>: only useful for <tt>CUST</tt> block type: the block model will be a mix
	of <tt>SOLID</tt> and <tt>CUBE</tt>: the outer layer of the model will use a unit textured cube,
	using the texture declared in the <tt>tex</tt> field of the state description. The purpose of
	this flag is to allow custom block model to benefit from ambient occlusion.
    <li><tt>BED</tt>: their models depend on tile entity.
  </ul>
  <p>Additionally, you can OR these values, with the following flags (ie: separated by |):
  <ul>
	<li><tt>CNXTEX</tt>: generate connected texture for all state description. Texture will be auto-generated
	from state description.
	<li><tt>NOCONNECT</tt>: don't generate connected info. Typical use case: fence gates. They connect
	with fences, and therefore have the FENCE flag, but don't have optional parts like fences.
  </ul>
  <li><tt>bbox</tt>: how the block can be targetted with the mouse. Enumeration value, with the following
  choices:
  <ul>
    <li><tt>NONE</tt>: this block cannot be targetted by user.
    <li><tt>AUTO</tt>: this mode will be automatically set for block type <tt>SOLID</tt>, <tt>TRANS</tt>
	and <tt>QUAD</tt>. Therefore, you can omit the <tt>bbox</tt> field for these types.
    <li><tt>MAX</tt>: this type is intended for <tt>CUST</tt> block type: <tt>MAX</tt> will compute
	the maximum axis-aligned box that covers the entire model.
    <li><tt>FULL</tt>: another mode for <tt>CUST</tt> block type: each individual part of a custom model
	will be used to check if the block is targetted. This type of collision test is very precise, but
	of course a bit more expensive to check.
  </ul>

  <li><tt>bboxPlayer</tt>: bounding box used for player/entity collision detection. The only supported
  value for this field is <tt>NONE</tt>. Otherwise, it will use the same value than the one specified in
  the <tt>bbox</tt> entry.

  <li><tt>orient</tt>: if block placement is orientation dependent, you can specify with this field
  how individual state description can be automatically chosen based on player orientation and/or block
  targetted:
  <ul>
    <li><tt>LOG</tt>: 3 possible orientation: E/W, N/S, or up right.
    <li><tt>FULL</tt>: 6 possible orientation: south, east, north, west, top, bottom.
    <li><tt>BED</tt>: 4 possible orientation, composed of 2 blocks.
    <li><tt>SLAB</tt>: 2 orientation: lower half, upper half.
    <li><tt>TORCH</tt>: 5 orientation: sticked to wall or up right.
    <li><tt>STAIRS</tt>: 8 orientation.
    <li><tt>SENW</tt>: 4 orientation (typical: chest, furnace).
    <li><tt>SWNE</tt>: 4 orientation but different state description (typical: repeaters, comparators).
    <li><tt>DOOR</tt>: 8 orientation.
    <li><tt>SE</tt>: 2 orientation: E/W or N/S, typical use case: rails.
    <li><tt>LEVER</tt>: 8 possible orientation: used by lever and buttons.
  </ul>

  <li><tt>emitLight</tt>: if this block will emit block light, you can indicate a value between 1 and 15
  (0 being the default).

  <li><tt>opacSky</tt>: how much intensity of sky light it will absorb. Default is 15 for <tt>SOLID</tt>
  and 0 for everything else. Usual values are 1 for leaves and 3 for water.

  <li><tt>opacLight</tt>: same with block light. Note: block light decreases by 1 for every step away
  from a light source. Therefore if you want a more "absorbing" block, the minimum value should be 2.

  <li><tt>tile</tt>: will add a default tile entity when placed in the world. Needed by Minecraft, not
  necessary for this engine.

  <li><tt>invmodel</tt>: state id (between 0 and 15) where to copy model to be rendered in inventories.
  This particular block will have only one item in the creative menu (instead of one per state).

  <li><tt>rswire</tt>: indicates how redstone wire connects to this block. Possible values are:
  <ul>
    <li><tt>ALLDIR</tt>: all possible direction (S, E, N, W).
    <li><tt>FRONTBACK</tt>: can connect to the front and back of the block (repeaters).
    <li><tt>BACKONLY</tt>: only from back (observer).
  </ul>

  <li><tt>rsupdate</tt>: indicates if this block cares about redstone update. Enumeration that can
  have one of the following values:
  <ul>
    <li><tt>RECEIVE</tt>: block state will change when redstone signal change nearby.
    <li><tt>GENERATE</tt>: will generate the redstone signal.
    <li><tt>INOUT</tt>: will do both: update states with redstone signal and output a signal (ie: repeaters, comparators).
  </ul>  

  <li><tt>placement</tt>: constraint the block has to satisfy to be placed in the world. If those
  constraint were to be invalidated due to nearby update, the block will be automaticall deleted.
  The field should be a string, described a list of contraints spearated by commas. Each constraint
  can use the following keyword:
  <ul>
    <li><tt>ground</tt>: any type of solid flat ground.
    <li><tt>wall</tt>: any type of solid flat wall.
	<li><tt>solid</tt>: any solid face from a block.
	<li><em>techName</em>: that particular block.
  </ul>
  <p>Note: the block is considered correctly placed if one of the constraint is satisfied. "Solid"
  means a block that has been declared with the type <tt>SOLID</tt>. That excludes <tt>CUST</tt> and
  <tt>TRANS</tt>.

  <li><tt>particle</tt>: type of particles this block will emit constantly.

  <li><tt>invmodel</tt>: custom model to use when this block is displayed in inventories. Should only
  be necessary for block type <tt>CUST</tt>, even though nothing prevent you from using with any other
  type. The format of this field is a bit complicated and be explained in the <a href="#blockmodel">next section</a>.

  <li><tt>pushable</tt>: how this block is going to be affected if pushed/retracted by a piston. Enumeration
  value that can take one of the following value:
  <ul>
    <li><tt>NO</tt>: block can't be pushed, nor retracted (obsidian, chests, ...)
    <li><tt>YES</tt>: default value for all blocks except <tt>QUAD</tt>.
    <li><tt>PUSHONLY</tt>: can only be pushed, but not retracted (glazed terracotta).
    <li><tt>DESTROY</tt>: completely destroy the block if pushed (leaves, grass, ...): this is the
	default for <tt>QUAD</tt>.
    <li><tt>DROPITEM</tt>: remove the block, but create an item entity (flowers, ...).
  </ul>
  <p><b>Note</b>: this engine supports moving blocks containing tile entities (furnace, chests, ...),
  even though in the default block definition file (<tt>blocksTable.js</tt>), they have been marked
  as non-movable.

  <li><tt>gravity</tt>: integer that can be either <tt>0</tt> or <tt>1</tt>. If set to <tt>1</tt>, the
  block will be converted to a falling entity, if placed above air (be it manually or with pistons).

  <li><tt>keepModel</tt>: hack.
</ul>

<h3 id="statedesc"><span>State description</span></h3>

<p>An object declaraction is recognized as a state declaration if it is contains a <tt>state</tt> property
with an integer assigned to it. Beside this property, you can also use these ones:
<ul>
  <li><tt>state</tt>: an integer between 0 and 15 that will be stored in <tt>Sections/Data</tt> table in a chunk.
  This table has only 4bits of information per block. More information can be stored using TileEntity.
  <li><tt>name</tt>: this field should describe a bit more in detail what the state is doing: for example,
  if the block is orientation dependent, you should include which way the state is pointing, or if the
  block has an opened/closed state, this is where it should be described...

  <p>Since this field will almost certainly have <b>a lot of redundant information</b>, there are a few
  facility to prevent you from repeating the same text over and over again: the less redundancy, the
  easier it will be to fix mistakes.

  <p>First, a state name can include an underscore (<tt>_</tt>) in the text. This character will
  act as a reference point for later names. The character itself will be replaced by a regular space.

  <p>Once you have a reference point, you can ask to include everything that was before using the <tt>+</tt>
  or <tt>-</tt> character, and then continue your text.

  <p>The text being appended will always be added with a parenthesis before (and a closing one if none
  are specified in the text), unless there was already an opening one in the text that was copied.

  <p>Here are a few examples:
  <table class="listview">
  <thead><tr><td class="nowrap">Block name<td>State name<td>Expanded into<td>Description
  <tbody>
    <tr><td rowspan="4"><tt>Log</tt><td><tt>+oak</tt><td><tt>Log (oak)</tt><td>Without any previous underscore, the whole text of block will be added.
    <tr><td><tt>+spruce</tt><td><tt>Log (spruce)</tt><td>Still no underscore specified, the reference point will remain the same on next line.
    <tr><td><tt class="nowrap">Bark (_oak)</tt><td><tt>Bark (oak)</tt><td>If the text does not include <tt>+</tt> or <tt>-</tt>, then it replaces everything. A new reference point is also set.
	<tr><td><tt>-spruce</tt><td><tt class="nowrap">Bark (spruce)</tt><td>The new reference point now point to a state description, instead of the block.
  </table>

  <li><tt>tex</tt>: texture coordinates to use to draw the faces of that block. Coordinates are actually
  tile coordinates: integers between 0 and 31 that will point to a texture tile in the file <a href="../resources/terrain.png">terrain.png</a>.
  That way the coordinates will work no matter what resolution the file is, the default tile set is 16x16px,
  but you can use whatever size you want (tiles needs to be square though). Although allowed, it is
  stongly discouraged to use a size that is not a power of 2, due to mipmapping (texture will "bleed"
  at the edge of tiles).

  <p>This field is expecting an array of integers. The number of coordinates will depend on the type of the block:
  <ul>
    <li><tt>SOLID</tt>, <tt>TRANS</tt>: 12 integers that form 6 pairs of U, V tile coordinates, one
	pair for each faces, specified in the order <tt>S,E,N,W,T,B</tt>. The coordinate must be specified
	relative to the top left corner of the tile you want to use for that face.
	<li><tt>QUAD</tt>: 2 integers: the tile texture to use for all quads (integer between 0 and 31).
	<li><tt>CUST</tt>: 8 integers: technically not required to render the block, since block model will
	provide their own texture coordinates, but this field will still be used for particles when this
	block is destroyed by the user. You don't have to specify the texture for the top and bottom face
	though, although it doesn't hurt to include them.
  </ul>

  <p>Filling those values manually is possible, albeit tedious and error prone. In the default <tt>blockTable.js</tt>
  field, all the values where filled with the help of <tt>TileFinder</tt>.
  
  <p>This field can include a 13th integer, that will be used to specify the <tt>rotate</tt>
  field (because <tt>TileFinder</tt> can read and write those 13 values at once).

  <li><tt>quad</tt>: an array of symbols indicating which quad to render for this block. Each symbol
  can be one of the following enumeration value:
  <ul>
    <li><tt>CROSS</tt>: used for crops, flower, grass, ...
    <li><tt>NORTH</tt>: attached to north of block (ladder, vines).
    <li><tt>SOUTH</tt>: attached to south face.
    <li><tt>EAST</tt>: east face.
    <li><tt>WEST</tt>: west face.
    <li><tt>BOTTOM</tt>: bottom of block (lily pad).
    <li><tt>ASCE</tt>: ascending from west to east (rails).
    <li><tt>ASCW</tt>: ascending from east to west.
    <li><tt>ASCN</tt>: ascending from south to north.
    <li><tt>ASCS</tt>: ascending from north to south.
  </ul>

  <li><tt>inv</tt>: this field can be used to override what has been specified at the block level.
  Remember, that the type of inventory item specified in the block will be applied to all state description.
  The typical use case is to prevent some states from appearing in the inventory (ie: <tt>NONE</tt>).

  <li><tt>model</tt>: an array of floatting point numbers. This field is absolutely not intended to
  edited manually. The format wil be described <a href="#blockmodel">below</a>, but even with this
  description, you'll have a hard time filling this field manually.
  <p>Instead, an external tool is almost required: <tt>TileFinder</tt>. You'll notice that all models
  are declared on their own lines (there no JSON tokens mix in those lines, besides what's required
  to make an array of numbers). The reason for this, is that those lines can be selected in a standard
  text editor, then copied and pasted inside <tt>TileFinder</tt> to see what the model looks like.
  You can also copy the model from <tt>TileFinder</tt> to the text file again, if you modify it later.

  <li><tt>rotate</tt>: rotate applied to texture coordinate, 6 groups of 2 bits. Rotation are ordered
  <tt>S,E,N,W,T,B</tt>. The texture will be rotated in multiple of 90&deg; clock-wise (when viewed
  in front), the multiple being the number encoded as 2bits.

  <li><tt>emit</tt>: where emitters are located in the model. An array containing one emitter location
  per entry. It can be one of the letter <tt>S,E,N,W,T,B</tt>, indicating that the entire face can emit
  particles (the location will be randomly selected when a particle is spawned). Or it can be a number:
  if the block has a custom model, this is the primitive number that will be used as location.
</ul>

<h3 id="blockmodel"><span>Block models</span></h3>

<p>Custom models that don't fit <tt>QUAD</tt> or <tt>SOLID</tt> can still use arbitrary shapes using
the property <tt>model</tt> on a state description object. All the models has been filled using using
an external application: <tt>TileFinder</tt>. This section will describe how the models are encoded,
but be warned that this format has not been designed to be manually edited.

<p>Contrary to typical models description format (like <tt>.obj</tt>) which usually only contains
triangles, this format uses cubes/boxes as basic primitives, where each face can be selectively
hidden or textured. You can also apply rotation, scaling, translation to each individual box and
by grouping multiple boxes, you get a model.

<p>Each lines usually represent a primitives (ie: box), even though to keep line length under control,
some might have been wrapped. The first number is a bit field encoding quite a few parameters:
<ul>
  <li><tt>bit0~5</tt>: faces activated for this box, bitfield ordered <tt>S,E,N,W,T,B</tt>. Faces not
  activated will have no triangles generated for them at all.
  <li><tt>bit6</tt>: normals are inverted: ie: if south face is active, it should use normal for the
  north face.
  <li><tt>bit7</tt>: texture should be applied using a cube map. Texture will coordinates refer to a
  tile in the main texture file, but should be reduced according to the face size/position.
  <li><tt>bit8</tt>: if set, it means there are more primitives following this one.
  <li><tt>bit9~10</tt>: model needs to be rotated by 90 degrees increment CCW (ie: trigonometric rotation).
  Careful though: normals will need to be readjusted. This field is carried to next primitives if any,
  therefore should only be set on the first one.
  <li><tt>bit11~16</tt>: detail face: <tt>S,E,N,W,T,B</tt> bitfield indicating faces for which an exact
  texture coordinate will be provided, instead of a cube map. Usually <tt>bit7</tt> is also set when
  using these.
  <li><tt>bit17~...</tt>: face ID: used for models that have optional parts (fences, glass panes, iron bar, restone
  dust, ...). More on this field later.
</ul>

<p>After that, numbers are a bit more straightforward:
<ul>
  <li><b>3 floats</b>: size of the box, in 1/16 units (ie: 16 = a full voxel), specified in X, Y, Z order.
  Can be fractionnal if needed. Model can have size of up to <tt>112x112x122</tt> (7 voxels). Although,
  due to frustum culling, it is advised to keep them below 32x32x32 (2 voxels).
  <li><b>3 floats</b>: translation to apply, also in 1/16 unit, that will be applied to the X, Y, Z axis.
  <li><b>3 floats</b>: rotation in degrees, CCW (trigonometric rotation) on the X, Y, Z axis.
  <li><b>3 floats</b>: rotation in degrees, CCW. The difference with the previous 3 numbers, is that
  these rotations will be carried onto the next primitives.
</ul>

<p>At last, these number can be followed by up to 24 integers which represent the UV coordinates of
the texture to use for the faces defined for this box. There are 4 numbers per face. The number of
faces is the number of bits activated in the first number (ie: <tt>popcount((int) model[0] & 63)</tt>).

<p>/* ... */

<h2 id="mesh">Mesh generation</h2>

<p>Another part that makes <b>heavy</b> use of cryptic static tables.

<p>/* ... */



<h2 id="opengl">Advanced OpenGL</h2>

<p>This section will explain some aspects of rendering pipeline.

<h3 id="translucency"><span>Handling translucent blocks</span></h3>

<p>That part was probably one of the biggest <b>crap shoot to implement</b>. 2 attempts were tried
(depth peeling and fragment sorting on the GPU), but ultimately were entirely discarded because of
serious shortcomings in the way they inherently work. Therefore the first 2 sections are a remimder
to not waste your time with these techniques.

<h4 id="oit"><span>Fragment sorting on GPU (Order Independent Transparency)</span></h4>

<p>In the OpenGL red book ninth edition, there is a fully working example for handling alpha transparency
in a <b>completely generic and 100% accurate way</b>, for any type of geometry, entirely on the GPU. The
implementation seemed elegant, not very intrusive, therefore rather easy to integrate, and indeed handle
absolutely all use cases.

<p>The basic idea with this technique is this:

<blockquote>
<p>Instead of writing translucent fragment directly in the main framebuffer, within the fragment shader,
you write them in a (very big) linked list. Thanks to OpenGLv4 atomic types and counters, this can be
achieved rather easily.

<p>The linked list is implemented using 2 textures: one texture the size of the framebuffer, where each
pixel will actually store the head of the linked list as a 32bit integer. The second texture will contain
the fragments (unsorted). For each element in this texture, we need: the RGBA color (32bit int),
the depth value (32bit float) and the next fragment in the list (32bit int), therefore 12 bytes per
translucent fragment.

<p>Once all fragments has been written in that list, you start a second pass to write them in the
framebuffer, by using the head texture to get all translucent fragment at given position, sort them
by decreasing depth, combining them using pre-multiplied alpha and finally writing the result into
the framebuffer (ie: returning the final color from the fragment shader).
</blockquote>

<p>That technique works indeed fine, except for a few use cases where <b>performance can suffer
massively</b>: a simple way to push this technique to its limit, is simply to have 2 quads, one
behind the other, very close to the camera. In that case, this is what will happen (supposing a
framebuffer of <tt>1920x1080px</tt>):
<ul>
  <li>Each pixel of the framebuffer will have to write 2 fragments in the linked list.
  <li><tt>2</tt> fragments times <tt>1920px</tt> times <tt>1080px</tt> times <tt>16</tt> bytes (12 bytes
  per fragment + 4 bytes for head of linked list) times <tt>60</tt> (frame per second) = a little bit
  under 4 Gb / second. That is going to saturate the memory bandwidth of all but high-end configuration.
  <li>To add insult to injury, if you were to sort those quads using the CPU, it would be just a few
  hundreeds <b>of bytes</b> to move around each second.
</ul>

<p>In conclusion: <b>for a voxel engine, it is not advised to rely on this technique alone</b>.

<h4 id="depthpeel"><span>Depth peeling</span></h4>

<p>This is another technique to handle alpha transparency in a <b>completely generic</b> way, with 100%
accuracy, and <em>mostly</em> handled by the GPU. The idea behind this technique is as follows:

<blockquote>
<p>Once again instead of writing the fragments directly in the main framebuffer, you write them into
another one (that has one color and <b>two</b> depth buffers). Obviously on that framebuffer, you will
have to manage both depth buffers on your own. The first depth buffer needs to be initialized to the min
value, and the second to the max value.

<p>On the CPU side, you start a loop with the number of "peel" of transparency you want to uncover.
There is a technique to get the exact number of loop, but as a starting point use an arbitrary number,
like 2 or 3.

<p>In the fragment shader handling translucent triangles, you overwrite the color only if the depth of the
fragment is higher than the value currently stored in the first depth buffer (ie: farther) and lower
than the second one (ie: nearer). If outside of that range, discard the fragment.

<p>Doing so, you just extracted the first layer of the farthest translucent fragments. You can now merge
the color buffer with the main framebuffer, using a trivial shader and a quad covering the entire screen.

<p>Next step is to swap the first and second depth buffer, initialize the (new) first depth buffer to
the min value, clear the color buffer and continue with the next iteration of the loop.

<p>On the second iteration, you'll have extracted the second farthest layer of translucent fragments.
</blockquote>

<p>The <b>main problem with this approach</b> is getting the exact number of loops required to draw all the
transparent fragments: if you do too little, some geometry will be missing and if you do too many loops,
you are going to waste time doing completely unnecessary work. But, due to the asynchronous nature of
GPUs, this value is not that trivial to get without stalling the pipeline.

<p>One way to do this, is to use a generic buffer accessed through an atomic operator, like <tt>atomicOr()</tt>,
to be called whenever at least one fragment is <b>discarded</b> due to the being replaced by a farther
fragment, that is testing against the first depth buffer. If the fragment is discarded when tested against
the second depth buffer, that means this fragment has already been processed, and therefore should not
update the flag buffer. If at the end of a loop this buffer contains a non-zero value, it means there
are fragments that still need processing.

<p>Sadly, once your loop is done, you cannot read the content of the buffer, to know if you should continue
or stop. Due to the asynchronous nature of OpenGL, the only moment where it is safe to do so, is when
swaping the back/front framebuffer (ie: <tt>SDL_GL_SwapBuffers()</tt>). At this point you know that, the GPU
is done with the previous frame, and the content of the buffer is accurate now.

<p>Worse: if there was not enough loops, at this point you can only increase the number of loops by one.
If you scene just switch from one layer of transparency to one containing a lot, even at 60 frame per
second, you'll be able to see the translucent layers being peeled frame per frame, as the number of loops
is increased one by one. This is going to be particularly jarring to see because layers are extracted
from <B>back to front</b>.

<p>This is far from ideal in practice, and this technique has somewhat the same problem than the linked
list of fragments: it requires too much bandwidth and/or up to date OpenGL implementation, which makes it
particularly annoying to debug when something goes wrong (usually due to buggy driver).


<h4 id="cpusort"><span>Triangles sorting on CPU</span></h4>

<p>The technique that is ultimately used in this engine is simply <b>sorting the triangles from farthest
to nearest</b>. As with the previous 2 techniques, it has its own shortcomings: it is not 100% accurate
(typical use case where it fails: 2 intersecting triangles/quads), and since the sorting is done on
the CPU, it is going to lag the rendering whenever there are too many triangles to sort.

<p>It has its advantages though:
<ul>
  <li>It is very straightforward to implement and <b>debug</b> (well, compared to hardware accelerated sorting).
  <li>A voxel engine has a lot of tricks you can use to considerably reduce the amount of sorting needed.
</ul>

<p>In this engine, the sorting is actually <b>divided in 2 parts</b>. All sorting algorithms
have to assume that one of the operations necessary to sort items is going to be cheap: either comparison
or moving memory (ideally both). In this case, neither of them are particularly cheap if we were to use
the vertex data as direct source. That's why we create a first array which is both cheap to move its
individual items around (just 8 bytes per item) and to compare those items (subtract two 32bit integers).

<p>Once this array has been sorted, we use it to move vertex data. Thanks to the information stored
in that secondary array, each quads from the vertex array has to be moved at most 2 times (and most of
the time, data will be copied from one place of the array to another, ie: using one <tt>memcpy</tt>).

<p>Triangles are sorted by whole quads (ie: 6 vertices at a time, ie: 2 triangles), because the meshing
phase actually only generates quads. The distance used to sort triangles is actually the distance from
the camera <b>to the center of the whole quad</b>, that distance being converted to fixed point.

<p>The sorting itself is handled by the good old libc <tt>qsort()</tt>.

<p>To reduce the amount of sorting needed, a few tricks are used:
<ul>
  <li><b>Chunks are sorted by the frustum culling</b>: the frustum culling function already builds a list
  of chunk that are roughly sorted from front to back. It is not perfect, but as far as alpha transparency
  is concerned, it is good enough. Which means:

  <li><b>Vertex sorted per chunk</b>: we only have to sort the alpha triangles on a per chunk basis. Which
  means all the chunks hidden by frustum/caves don't have to be processed whatsoever. Also since vertex data
  is already stored per chunk, usually in non-contiguous memory segment, it would have been a <b>major
  inconvenience</b> to have to sort them globally.

  <li><b>Viewing angles threshold</b>: the list of visible chunks can change every time the model-view
  matrix is changed (which is to say quite often). Still, it is not required to sort the triangles
  every time the yaw/pitch/position are changed.

  <p>For the yaw/pitch, their values are stored in a chunk at the time of sorting. If these values change
  later, the sorting will be redone only if one of angles differ for more than 45&deg;.

  <p>The position is only taken in account for the chunk the player currently is. Consider the following
  situation:
  <div class="image">
    <img src="images/sortedalpha.png">
  </div>
  <p>The plus sign marks the player position: the <b>yellow block is the closest</b> (therefore drawn
  last), while the <b>purple and green are farther</b> (therefore drawn first). If the player were to
  move in the direction pointed by the arrow, at some point, the yellow block will become farther than
  the purple, therefore the draw order needs to be changed. That's why the current chunk is reordered
  whenever the player position changes.
</ul>

<h3 id="gpubanks"><span>Managing chunks on GPU</span></h3>

<p>Chunks are rendered using instance rendering, which helps reduce the overhead of OpenGL draw calls,
at the price of a bit more work on the CPU side in order for the GPU to do its work.

<p>/* ... */

<h2 id="nbt2">NBT API</h2>

<p>NBT API in this engine does not exactly follow a tradionnal API you might expect for manipulating
a tree of arbitrary data types. The main problem that this API was trying to solve is to keep 
everything related to an NBT tree as close as possible in memory, to benefit from cache locality.

<p>For example, the different tables of a chunk (<tt>Blocks</tt>, <tt>Data</tt>, <tt>BLockLight</tt>,
<tt>SkyLight</tt>) pushed this logic quite far: a single memory buffer is allocated for these and all
of them are placed at fixed offsets relative to the <tt>Blocks</tt> table (since all these tables
always have the same size), such as if you have a pointer to the beginning of the <tt>Blocks</tt>
table, you can access all the others by applying a fixed offset.

<p>/* ... */

<h2 id="entities">Entities</h2>

<p>This part will describe <b>how entities</b> (mobs, block moved by piston, dropped items, paintings, ...)
<b>are managed</b> within this engine. This part is not trivial just by looking at the source code, since
there are a lot of moving parts, with lots of datatypes:

<h3 id="structure"><span>Data structures</span></h3>

<p>There are 6 datatypes used to manage entities:

<ul>
  <li><tt>struct Entity_t</tt> : represents an entity from within the world, as such, they have
  a NBT record associated.

  <li><tt>struct EntityBuf_t</tt> : <tt>struct Entity_t</tt> are allocated in batch (<tt>ENTITY_BATCH</tt>
  count). It is easier to handle entities if pointers are not reallocated, so that reference can be held
  within datatypes. Allocating them in batch, will somewhat keep those entities close in memory.

  <li><tt>struct EntityBank_t</tt> : hold model data that will be used to render entities: we'll use
  one model per entity, so that they can be drawn in a single call to <tt>glMultiDrawArraysIndirect()</tt>.

  <p>This API will beed a command buffer (vboMDAI) and a per instance info (vboLoc). This list will
  be rebuild with minimal changes whenever a entity is added or removed, which means a few more boilerplate
  tables to track usage (most notable one being <tt>mdaiUsage</tt>).

  <p>Assumption is made that entities around the player is rather low (less than 1000). Aas such, we
  don't care about frustum culling, we let the vertex shader do the work.

  <p>Once added, an entity model will remain in the VBO (there are no ways to remove models). A model
  represent a complete entity, like for example: item frame and their item are one model. Block 36 is
  one model...

  <p>Models will be rendered on demand: there are way too many to generate them all at startup.

  <p>Banks will hold a fixed number of vertices data: if that buffer is full or close to, a new bank
  will be allocated.

  <li><tt>struct EntityModel_t</tt> : describe what's in all the VBOs: since VBO are only stream
  of bytes, but we also need to know the vertex location, size, and bounding box.

  <li><tt>struct EntityEntry_t</tt> : given an entity, we want to know if its model is already available
  in one bank.
</ul>

<h3 id="collision"><span>Collision correction</span></h3>

<p>Collision detection in is engine is entirely handled by checking if <b>axis-aligned boxes</b> are
intersecting each others. The obvious advantage is that detecting collision is very easy, the problem
is actually knowing what to do once a collision is detected. This is by far the hardest part, since
each collision will likely involve quite a few bounding box being intersected.

<p>The usual technique you can find online will usually <b>break down at some point</b> because you
cannot correct the collision by looking at one intersection at a time: you need to analyze them as a
group. This section will document the strategy used in this engine, since once again, the source code
can be quite cryptic.

<p>/* ... */

</div>

</body>
</html>
