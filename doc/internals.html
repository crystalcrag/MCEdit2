<!DOCTYPE html>

<html>
<head>
  <title>Internals</title>
  <link rel="stylesheet" type="text/css" href="default.css">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head>
<body>

<div id="toc">
<a class="sub1" href="#conventions"><span>Conventions</span></a>
  <a class="sub2" href="#coord"><span>Coordinate system</span></a>
  <a class="sub2" href="#rotation"><span>Angles</span></a>
  <a class="sub2" href="#faceorder"><span>Face enumeration order</span></a>
  <a class="sub2" href="#datatypes"><span>Datatypes</span></a>

<a class="sub1" href="#culling"><span>Frustum culling</span></a>
  <a class="sub2" href="#firstvers"><span>First version</span></a>
  <a class="sub2" href="#impl"><span>Implementation</span></a>
  <a class="sub2" href="#neighbors"><span>Enumerating neighbors</span></a>
  <a class="sub2" href="#edgecase"><span>Edge cases</span></a>
  <a class="sub2" href="#crossplane"><span>Cross-plane faces</span></a>
  <a class="sub2" href="#caveats"><span>Caveats</span></a>
  <a class="sub2" href="#fakechunks"><span>Fake chunks</span></a>
  <a class="sub2" href="#outside"><span>Outside bounds</span></a>
  <a class="sub2" href="#cavecull"><span>Cave culling</span></a>
    <a class="sub3" href="#cavecullv1"><span>First attempt</span></a>
    <a class="sub3" href="#cavecullv2"><span>Second attempt</span></a>
  <a class="sub2" href="#altimpl"><span>Alternate implementation<span></a>

<a class="sub1" href="#blocks"><span>Block API</span></a>
  <a class="sub2" href="#blockdesc"><span>Block description</span></a>
  <a class="sub2" href="#statedesc"><span>State description</span></a>
  <a class="sub2" href="#blockmodel"><span>Block models</span></a>

<a class="sub1" href="#NBTapi"><span>NBT API</span></a>
  <a class="sub2" href="#NBTspec"><span>NBT Structure</span></a>
  <a class="sub2" href="#NBTspecapi"><span>NBT Structure in API</span></a>
  <a class="sub2" href="#NBTpost"><span>NBT post processing</span></a>
  <a class="sub2" href="#NBTfunc"><span>NBT Function overview</span></a>
	<a class="sub3" href="#NBTread"><span>Reading files</span></a>
	<a class="sub3" href="#NBTfind"><span>Locate tags</span></a>
	<a class="sub3" href="#NBTiter"><span>Iterating properties</span></a>
	<a class="sub3" href="#NBTreadtag"><span>Reading tag value</span></a>
	<a class="sub3" href="#NBTchgtag"><span>Setting tag value</span></a>
	<a class="sub3" href="#NBTcreate"><span>Creating / modifying nbt</span></a>
	<a class="sub3" href="#NBTother"><span>Others</span></a>

<a class="sub1" href="#opengl"><span>Advanced OpenGL</a>
  <a class="sub2" href="#translucency"><span>Alpha transparency</span></a>
    <a class="sub3" href="#oit"><span>Sorting on GPU</span></a>
    <a class="sub3" href="#depthpeel"><span>Depth peeling</span></a>
    <a class="sub3" href="#cpusort"><span>Sorting on CPU</span></a>
  <a class="sub2" href="#gpubanks"><span>Managing chunks on the GPU</span></a>
    <a class="sub3" href="#vtxbuffers"><span>Vertex buffers</span></a>
    <a class="sub3" href="#vtxdata"><span>Vertex data</span></a>

<a class="sub1" href="#mesh"><span>Mesh generation</span></a>
  <a class="sub2" href="#meshsolid"><span><tt>SOLID</tt> voxel</span></a>
    <a class="sub3" href="#vtxtex"><span>Coordinates</span></a>
    <a class="sub3" href="#skyblock"><span>Lighting</span></a>
    <a class="sub3" href="#cnxtex"><span>Connected textures</span></h4>
	<a class="sub3" href="#meshhalf"><span>Half-block</span></a>
    <a class="sub3" href="#ocs"><span>Occlusion</span></a>
  <a class="sub2" href="#meshcust"><span><tt>CUST</tt> voxel</span></a>
    <a class="sub3" href="#cnxmodels"><span>Connected models</span></a>

<a class="sub1" href="#entities"><span>Entities</span></a>
  <a class="sub2" href="#structure"><span>Data structure</span></a>
  <a class="sub2" href="#collision"><span>Collision detection</span></a>
  <a class="sub2" href="#partitioning"><span>Space partioning</span></a>

<a class="sub1" href="#emitters"><span>Particle emitters</span></a>

<br>
<br>
<br>

</div>

<div id="content">

<h1>MCEdit internals</h1>

<div id="abstract"><u>Abstract:</u>
<p>Some of the algorithms and data structures used in MCEdit 2.0 are not that trivial to understand by looking at the source
code, even heavily commented, especially since the rendering engine makes heavy use of what appears to be cryptic static tables.
This document will provide in-depth explanation for some of them.

<p><b>Pre-requisite</b>: knowledge of OpenGL, 3D math and C programming language.
</div>

<p id="auth">Written by T.Pierron, July 2020</p>

<h2>Conventions</h2>

<p>Before reading this document further, there are a few facts to keep in mind, because they are used
quite extensively throughout the engine. To avoid repeating them over and over again, here is what needs
to be known:

<h3 id="coord"><span>Coordinate system</span></h3>

<div class="photo" style="float:left">
  <img src="images/axis.svg">
</div>

<p>The <b>coordinate system uses a left hand axis</b>. X is mapped to east-west (increasing X goes to east,
decreasing goes to west). Z is mapped to north-south (increasing Z goes to south, decreasing goes to
north). Y is elevation.

<p>Meshes of various objects use a counter-clockwise (CCW) orientation to check if they are front-facing.

<p>Coordinates are relative to player (ie: if you want an object close to camera, coordinates must
be close to player position, not 0,0,0). <span class="n">XXX</span> That's not good actually: coords
are stored in floats, loss of precision will be problematic.

<h3 id="rotation"><span>Angles</span></h3>

<p>Angles in this engine tried to be mapped on the trigonometric circle (especially rotation on Y axis).
That way, the output of cosine and sine functions can be used directly without unnecessary conversion.
Here are how they are mapped to each axis, keep that in mind, it is <b>very easy to mix them up</b>:

<div class="photo" style="display: inline-block; margin-left: 40px">
  <img src="images/rotateY.png">
  <cap>Rotation on Y axis (left-hand axis)</cap>
</div><div class="photo" style="display: inline-block; margin-left: 40px">
  <img src="images/rotateX.png">
  <cap>Rotation on X axis</cap>
</div>

<p>With entites, there are some exceptions though: orientation will depend on how the model is created.
To avoid some headache, it is strongly advised to keep the orientation above: if the entity rotation is 0,
it should be facing east.

<h3 id="faceorder"><span>Face enumeration order</span></h3>

<p>Whenever there is a need to enumerate nearby objects within the voxel space, the <b>same order will
be used almost everytime</b>. For example: to enumerate the 6 nearby voxels a given block is directly
connected to, to enumerate the 6 neighbors a given chunk is connected to, to generate the mesh of the
6 faces a given cube is composed of, ... these will always be done in the same order:
<ol>
  <li><b>South</b>
  <li><b>East</b>
  <li><b>North</b>
  <li><b>West</b>
  <li><b>Top</b>
  <li><b>Bottom</b>
</ol>

<p>Keep that order in mind, it is <b><u>used extensively</u></b> in one form or another throughout the entire code
base. It can be used as indices in a for-loop from 0 to 5, be used as a bit field to remember which
sides have been visited (therefore have values from 0 to 63), or simply as a enumeration value
(<tt>SIDE_*</tt>).

<p>You'll often see the abbreviation <tt>S,E,N,W,T,B</tt> (or sometimes just <tt>S,E,N,W</tt>) throughout
the code base, this is a reminder of this order.

<p>Technically, there are no obligations to respect that order all over the place, but it makes it easy
to reuse the same look-up tables over and over again, without having to worry about compatibility.

<h3 id="datatypes"><span>Datatypes</span></h3>

<p>Datatypes in the engine follows a small, but kind of helpful convention: if a structure has to be
declared as a value, <b>it is not</b> typedef'ed, and the name <b>always have</b> a trailing <tt>_t</tt>
(the t stands for <tt>type</tt> of course).

<p>If there are no trailing <tt>_t</tt> and no <tt class="t">struct</tt>, therefore it is a pointer. Consider the
following example:
<pre><t>struct</t> BlockIter_t iter;
BlockIter iterator;</pre>

<p>From this convention, you know the second declaration is a pointer to a <tt><t>struct</t> BlockIter_t</tt>.

<p>Sometimes a typedef is introduced for <tt class="t">struct</tt> to remove the need to type this keyword,
because the type itself is used quite extensively. For example:
<pre><t>typedef struct</t> NBTIter_t     NBTIter_t;
<t>typedef struct</t> NBTFile_t     NBTFile_t;</pre>
<p>But, the type will keep the <tt>_t</tt> suffix to indicate it is a value type, not a pointer.


<h2 id="culling">Frustum culling</h2>

<p>Frustum culling refer to the algorithm that can enumerate all the objects that are visible within
the model-view-projection matrix. It is usually a compromise between precision of object's bounding
box and computational power required to test those bounding boxes: we cannot spent too much time on
the CPU checking for object's visibility (because in the meantime the graphics card could have probably
already rendered this object) and on the other hand, including out-of-view objects, will requires useless
work for both the CPU and the GPU.

<p>The techniques used in this engine are not particularly revolutionary, but there are a lot of edge
cases to take care, that makes the overall algorithm not so trivial and quite extensive.

<p>A <prod>Minecraft</prod> terrain is composed of a grid of chunks: axis-aligned boxes of 16x16x16 voxels.
A typical terrain with a render distance of 16 chunks, contains about 4,000 of these sub-chunks. A frustum
with a field of view of 80&deg; will cross about 1,000 of them: that's a decent amount of information
culled and therefore worth doing.

<p>Since chunks are aligned in a grid, it means they share a lot of vertices: if we know that one corner
of a chunk fits within the frustum, we can automatically add the 7 others chunks that share this vertex.

<p>In other words by testing only one vertex, we can potentially add up to 8 chunks to the list of visible
objects. Which means  on average, we will have to <b>test one point per chunk</b>. <em>That is reasonably 
cheap</em>.

<p>Testing if a vertex is part of a frustum is actually very easy: we can use the MVP matrix (the exact
same one that will be used in the vertex shader), by simply multiplying that matrix with the coordinates
of our vertex (using 1 as the fourth vector component). That is:
<pre>V<sub>p</sub> = MVP * V</pre>
<p>Then to test if a vertex is inside the frustum, we can simply use the properties of homogeneous coordinates:
<pre>Vp is in frustum if:
	-V<sub>pw</sub> &lt;= V<sub>px</sub> and V<sub>px</sub> &lt;= V<sub>pw</sub> and
	-V<sub>pw</sub> &lt;= V<sub>py</sub> and V<sub>py</sub> &lt;= V<sub>pw</sub> and 
	-V<sub>pw</sub> &lt;= V<sub>pz</sub> and V<sub>pz</sub> &lt;= V<sub>pw</sub>
</pre>

<p><tt>V<sub>pw</sub></tt> is the fourth component of our projected point. More precisely, each of
these inequalities check if the coordinate is outside one of the 6 planes that defines the frustum.
We'll need that information later.

<p>In this engine, a <tt>struct Chunk_t</tt> (or <tt>Chunk</tt> if you just want a pointer) is a datatype
that reference an entire column of 16x16 blocks of terrain. A <tt>struct ChunkData_t</tt> (or <tt>ChunkData</tt>
as a pointer type) contain all the data (block IDs, sky light, block light, meta-data, ...) for one
16x16x16 blocks of terrain. Keep those datatypes in mind, they will be used throughout this section.

<h3 id="firstvers"><span>First version (pseudo-code)</span></h3>

<p>So, a first version for this algorithm would be:
<div class="pre">
<ul>
  <li>Start with a empty list of visible chunk.
  <li>Add the chunk where the player in that list.
  <li>For each chunk in that list:
    <ul>
	  <li>For each of the 8 corners of the chunk:
	    <ul>
		  <li>Check if corner is in frustum.
		  <li>If yes, add 8 connected chunks to the end of the list (if the chunk has not already been added yet).
		</ul>
	</ul>
</ul>
</div>

<p>That algorithm seems pretty simple, but lacks <b>a lot</b> of house-keeping required to achieve our
goal of one vertex checked per chunk.

<p>As simple as this version is, it already has a few interesting properties:
<ul>
  <li>There was no particular constraints on the MVP matrix, and indeed this algorithm will work for <b>any projection</b> (orthogonal,
  perspective) <b>any FOV</b> and any <b>render distance</b> (near and far plane).
  <li>The list of chunks will mostly be sorted from front to back. It is not perfect, but good enough to trigger some early depth culling
  from the GPU.
</ul>

<h3 id="impl"><span>Implementation (C code)</span></h3>

<p>Sadly, the implementation is a lot more complex than this though. Most of the complexity is to deal
with edge cases though. If you look at the datatype needed for generating the visible list, you can
see there are a few static tables:
<pre style="font-size: 1vw"><t>struct</t> Frustum_t
{
   <t>int32_t</t> neighbors[<v>8</v>];       <span class="c">/* 8 corners having 8 neighbors: bitfield encode 27 neighbors */</span>
   <t>uint8_t</t> chunkOffsets[<v>27</v>];   <span class="c">/* bitfield of where each chunks are (S, E, N, W, T, B) */</span>
   <t>uint8_t</t> faces[<v>6</v>*<v>4</v>];         <span class="c">/* cross-plane faces */</span>
   <t>uint8_t</t> faceDir[<v>6</v>];         <span class="c">/* direction to go to find chunk connected to face */</span>
   <t>uint8_t</t> firstFree[<v>256</v>];     <span class="c">/* fake chunk allocator */</span>
   <t>float</t> * mvp;                <span class="c">/* model-view-projection matrix (4x4) */</span>
};
</pre>

<p>To achieve what's described in the first algorithm, we only need the first 2 tables: <tt>neighbors</tT> and <tt>chunkOffsets</tt>.

<div class="photo" id="vtxorder" style="float: right; width: 25%; margin: 0 0 0 20px">
  <img src="images/cube.svg" width="100%">
  <cap>Vertex order of a chunk</cap>
</div>

<p>The order of each corner of a chunk is illustrated with the figure on the right. Each of these
corners can potentially add 8 chunks, if that corner is contained within the frustum. By overlapping
all those connected chunks you get a 3x3 cube of chunks. Therefore, the maximum number of connected
chunks you can have from those 8 corners is 27.

<p>This is what encodes the <tt>neighbors</tt> table: each of these 27 chunks are given a number
between 0 and 26, and therefore can be encoded as a bitfield in a 32bit integer. The order is shown below
(axis is the same as the figure on the right):

<table class="skewed" id="cube3x3">
<tr><td>25<td>15<td>23
<tr><td>17<td>5<td>12
<tr><td>21<td>9<td>19
</table>

<table class="skewed">
<tr><td>14<td>3<td>11
<tr><td>4<td><v>0</v><td>2
<tr><td>8<td>1<td>7
</table>

<table class="skewed">
<tr><td>26<td>16<td>24
<tr><td>18<td>6<td>13
<tr><td>22<td>10<td>20
</table>

<p><tt>0</tt> is the chunk we are currently in. The numbers are ordered by scanning each number (starting
from 0 in the center) and looking in the <tt>S, E, N, W, T, B</tt> directions if the chunk has been
assigned to something. If not, it will be assigned to the next free number. The process continues until
all 27 slots have been set.

<p>The purpose of this order is to be able to scan surrounding chunks by their distance from the center
chunk: number 0 is the center, 1 to 6 are chunks one step away from center, 7 to 18 are two steps away
and 19 to 26 are 3 steps away (the steps being a <tt>S, E, N, W, T, B</tt> step). This order will
be required by the cave culling algorithm.

<p>For example, if we checked that vertex <tt>0</tt> of a chunk is within the frustum, we know we can
also add chunks <tt>3</tt>, <tt>4</tt>, <tt>6</tt>, <tt>14</tt>, <tt>16</tt>, <tt>18</tt> and <tt>26</tt>.
Chunk 0 is not included, because at this point we already know that the center chunk is part of the frustum.
Encoded as bitfield, with the n<sup>th</sup> bit set if chunk number <tt>n</tt> is in the frustum, the
7 chunks to add for vertex 0 can be encoded as <tt>2<sup>3-1</sup> + 2<sup>4-1</sup> + 2<sup>6-1</sup> +
2<sup>14-1</sup> + 2<sup>16-1</sup> + 2<sup>18-1</sup> + 2<sup>26-1</sup> = 0x0202a02c</tt>, and so on
for the other 7 corners: that's what is stored in the <tt>neighbors</tt> table.


<h3 id="neighbors"><span>Enumerating neighbors</span></h3>

<p>To enumerate all the connected chunks, we'll check if each corner of a chunk is within the frustum
and accumulate those neighbor bitfields into a 32bit integer. Then, we can just use the <tt>chunkOffsets</tt>
table to locate the n<sup>th</sup> chunk (with <tt>n</tt> varying from 0 to 26). Therefore this table
will have 27 elements. Each element is a bitfield with the following meaning:
<ul>
  <li>bit 1 set: move to the <b>south</b> (+Z).
  <li>bit 2 set: move to the <b>east</b> (+X).
  <li>bit 3 set: move to the <b>north</b> (-Z).
  <li>bit 4 set: move to the <b>west</b> (-X).
  <li>bit 5 set: move to the <b>top</b> (+Y).
  <li>bit 6 set: move to the <b>bottom</b> (+Y).
</ul>

<p>If the chunk is tagged by the bitfield, it is then added at the end of the visible list, to be
scanned later to see if we can reach new chunks from here. We continue then until the entire list
has been scanned.

<h3 id="edgecase" style="clear: both"><span>Edge cases</span></h3>

<p>This first version easily <b>covers around 90% to 99%</b> of the chunks we need to enumerate, but
it can miss some especially around the corners of frustum. This version also breaks down when the FOV
gets too small. Consider the following frustum:

<div class="image">
  <img src="images/fov10deg.png">
  <cap>Frustum with a 10&deg; FOV</cap>
</div>

<p>Technically, a frustum should be more of a trapezoidal shape, but the parameters used for the near and far plane in
<prod>MCEdit 2.0</prod> are respectively 0.1 and 1000, which gives almost a triangular shape.

<p>You can see here that none of the vertex from the corners of every chunks fit within the frustum. Yet, the frustum does indeed
cross some chunks. How do we enumerate these?

<p>For these, we can use the properties of homogeneous coordinates, when checking if a point is in the frustum: 

<pre>Vp is in frustum if:
	-V<sub>pw</sub> &lt;= V<sub>px</sub> and V<sub>px</sub> &lt;= V<sub>pw</sub> and
	-V<sub>pw</sub> &lt;= V<sub>py</sub> and V<sub>py</sub> &lt;= V<sub>pw</sub> and 
	-V<sub>pw</sub> &lt;= V<sub>pz</sub> and V<sub>pz</sub> &lt;= V<sub>pw</sub>
</pre>

<p>Each of these inequalities tells us on which side of each plane the point is. For example if <tt>V<sub>pz</sub> &lt; -V<sub>pw</sub></tt>
is true, that means the point is behind the near plane. Similarly, if <tt>V<sub>pz</sub> &gt; V<sub>pw</sub></tt> is true, the point is beyond the
far plane, and so on...

<h3 id="crossplane"><span>Cross-plane faces</span></h3>

<p>We can then keep track of which plane the point is outside of, using a bitfield. Since there are
6 planes, a single byte will be enough. That is the purpose of the <tt>outflags</tt> table in the
<tt><t>struct</t> Chunk_t</tt> type: keep track of which planes the origin corner
of each sub-chunk (16x16x16 area, <tt><t>struct</t> ChunkData_t</tt> in the
code) is outside of. The origin corner is the location of block 0, 0, 0 within the chunk.

<p>Therefore to get the <tt>outflags</tt> values of the 8 corners of a <tt>ChunkData</tt>, we will
have to extract them from the 4 neighbor chunks (<tt><t>struct</t> Chunk_t</tt>):
for example the <tt>outflags</tt> value for the coordinate <tt>chunk.x + 16, chunk.y, chunk.z</tt>
is located in the chunk directly to the east of <tt>chunk</tt>: that is how we achieve one matrix
test per <tt>ChunkData</tt> (on average).

<p>For each <tt>ChunkData</tt> we want 8 <tt>outflags</tt> values: one per corner, that we
need to compute and/or extract from nearby chunks. Once we have this information, we can check if a
<b>face</b> of the <tt>ChunkData</tt>'s bounding box crosses two planes: each face is composed of 4
segments and given 2 points that form a segment, this segment crosses two planes if the corresponding
<tt>outflags</tt> value of these points have at least <b>2 bits</b> that differ. Using the C language,
this can be trivially done using a XOR operation:

<pre><t>int</t>    pt1, pt2;      <span class="c">/* we'll see how to enumerate these in a bit */</span>
<t>int8_t</t> flagsPt1 = outflags[pt1];
<t>int8_t</t> flagsPt2 = outflags[pt2];

<span class="k">if</span> (popcount(flagsPt1 ^ flagsPt2) &gt;= <v>2</v>)
{
	<span class="c">/* segment crosses more than 2 planes */</span>
}</pre>

<p><tt>popcount()</tt> is the typical function name for counting the number of 1 bits in an integer,
it is a shorthand for <b>pop</b>ulation <b>count</b>. Since we are using 6 bit integers, we could
have used another lookup table, but most CPU nowadays have a dedicated instruction for this,
which are even <a href="https://github.com/BartMassey/popcount">faster</a> than a lookup table.

<p>If just one segment from the face crosses two or more planes, we consider the entire face as crossing
them too.

<p>In the implementation, two tests were added to <b>eliminate as early as possible some degenerate cases</b>.
Even though the code down the line is able to eliminate those, we might as well remove them as early as possible,
since those tests are very cheap.

<p>The first test check if all the <tt>outflags</tt> of a given face have their coordinates
outside the frustum, using a test like this:
<pre>sector1*sector2*sector3*sector4 != <v>0</v></pre>
<p>If one face has a coordinate inside the frustum (<tt>outflags == <v>0</v></tt>),
the nearby chunk will already be added by the first pass of the algorithm. Then the second test is:
<pre>sector1&amp;sector2&amp;sector3&amp;sector4 == <v>0</v></pre>
<p>This test ensure that not all the coordinates are on the same side of a plane. This happen
quite often at the starting chunk position: coordinates of a face are all to the left/right of a
plane, but also cross the top/bottom planes, therefore will be considered a cross-plane face and
an useless chunk will be added to the list. Not that much of a big deal, but since they are easy
to eliminate, might as well do it.


<h3 id="caveats"><span>Caveats</span></h3>

<p>These two passes will cover 99% of the use cases, even though there will still be cases where a
chunk will be included in the frustum, when it clearly does not belong. Consider the following example:

<div class="image">
  <img src="images/falsepositiv.png">
</div>

<p>The white square next to the starting chunk shouldn't be included in the visible list. What happened here,
is that the segment <tt>[0,2]</tt> crossed the left and right plane ... but outside the frustum. Because the
result of those inequalities we stored in the <tt>outflags</tt> table supposed that those planes extend to
infinity. Therefore point 0 will be considered <b>both</b> to be on left of the left plane <b>and</b> to the
right of the right plane.

<p>In practice, those false positives are quite rare, less than 1 in a thousand. It would be pointless to add extra
code to eliminate those. All the vertices from these chunks will be eliminated in the vertex shader, without
even reaching the fragment shader. As long as there aren't too many of these, performance loss will be negligible.

<h3 id="fakechunks"><span>Fake chunks</span></h3>

<p>But we are not done yet. A <prod>Minecraft</prod> map is composed of column of chunks. Those
columns are not all of equal height, far from it. Here's a XY slice view of a typical landscape:

<div class="image">
  <img src="images/sliceview.png">
</div>

<p>The yellow lines shows the sub-chunk boundaries, cyan chunks with no writings in it, indicate an
empty chunk: nothing is allocated for these, attempting to get a <tt>ChunkData</tt> for these will
return <tt class="o">NULL</tt>. Player is currently in one of those empty area, looking left, therefore
the algorithm will have no starting point, and as is, will generate an empty list of visible chunks.
Not good.

<p>If that's the case, a fake chunk will be created for the sole purpose of tracking where we are and
to check where we can go next. Those sub-chunks are actually cheap to allocate because we only need
a small subset of the fields contained in a <tt>ChunkData</tt> structure.

<p>But we need to avoid allocating useless fake chunks: a frustum with a 16 chunks render distance can
cross several thousands of sub-chunks if the frustum were completely full. When you are walking on the
surface, most of the frustum is composed of air, which would be wasteful to allocate a fake chunk
for something that isn't going to be rendered anyway.

<p>The heuristic used here is to only consider adding a fake chunk if <b>it crosses the bottom plane
of the frustum</b>. The reason for checking the bottom plane is because this is the only plane a column
of <tt>ChunkData</tt> is guaranteed to cross. Chunk columns are always contiguous: there are no gaps
between the bottomest and topmost <tt>ChunkData</tt>, if it wasn't the case, that heuristic wouldn't
work at all. Alsom the pitch (vertical angle) of a player is always between [-pi/2, pi/2] (ie: you
cannot look upside down).

<p>The way it is checked is very similar to cross-plane faces: by checking the <tt>outflags[]</tt>
array, for a segment that has its 2 endpoints on the opposite side of the bottom plane.



<h3 id="outside"><span>Outside bounds</span></h3>

<p>Fake chunks work fairly well as long as we remain within build limit. Even if the engine would allow
unlimited build height, it would be pointless to allocate a gigantic column of fake chunks just to reach
the ground level, because we can do this by using some simple geometry. And besides, a geometric
approach is required when the player is below the bottomest chunk (i.e.: <tt>Y &lt; 0</tt>).

<p>Again, the problem here is that the frustum culling won't have a starting point, worse: <b>it cannot
have one</b>, because there is no place in the <tt>Chunk</tt> structure to store a reference, even for a
fake chunk.

<p>There are 2 cases to take care:
<ol>
  <li><b>Below built height</b>: right now we return an empty chunk list: you are not supposed to get here.
  And besides, even if you were to generate a chunk list, most voxel will be culled by the GPU because
  they are oriented backward.
  <li><b>Above build height</b>: we use the inverse MVP matrix to get the direction of the bottom plane
  of the frustum. With that direction, we check what's the nearest chunk it intersects (at highest possible
  location, whether there is a <tt>ChunkData</tt> or not). If there is a <tt>ChunkData</tt>, we use this
  as a starting point, otherwise we allocate a fake <tt>ChunkData</tt>.
</ol>

<h3 id="cavecull"><span>Cave culling</span></h3>

<p>There is one last step that is done at (almost) the same time: cave culling, or removing chunks that
are completely hidden by nearer chunks. A good primer on how this algorithm works can be read from the
original <a href="https://tomcc.github.io/2014/08/31/visibility-1.html">author</a> that developed it
for Minecraft MCPE.

<h4 id="cavecullv1"><span>First attempt</span></h3>

<p>In the linked blog post, it was mentioned that they first tried to remove chunks that are completely
surrounded by opaque chunks (ie: where the outer face is completely made up of opaque quad). Unsurprisingly,
the results were disappointing: it only culled about 1% of total chunks.

<p>A simpler approach were attempted for this engine, because computing the visibility graph is actuatlly
not that cheap (although with that information, <b>you can cull a lot of chunks</b>).

<p>The slight improvement was to realize that <b>a cube viewed using a perspective projection
matrix has at most 3 faces visible</b>. Instead of checking all 6 faces, we only need to check at most 3.
Checking if a face is fully opaque is very simple and super cheap to compute.

<p>Sadly, the results for this method were also disappointing: it culled about 10% of the chunks in the
view frustum. Caves leave too many holes in chunks, which means finding an entire solid face is quite
rare in practice.

<p>This section is just a reminder to not waste any time with any of these techniques.

<h4 id="cavecullv2"><span>Second attempt</span></h3>

<p>Second attempt was based on the algorithm described in the link above: compute visibility graph of
connected chunks, and traverse that graph while attempting to mimic a raycasting traversal of that graph.
The traversal was changed quite a bit though: the one used in <prod>Minecraft</prod> is a bit too aggressive,
and tend to discard chunks that are clearly visible (as of v1.17 the results are a lot better since it
was introduced in 1.8).

<h5 id="cnxgraph"><span>Computing visibility graph</span></h3>

<p>Computing the visibility graph is not that hard: in this engine it is implemented in
<tt>mapUpdate.c</tt>: <tt>mapUpdateGetCnxGraph()</tt>. It uses a 3D flood fill (as described in the blog
post), using a ring buffer (to simulate recursion) and bit-vector to manage which voxel has been visited.
This sounds way more complicated than it really is: there is about 40 lines of code for this function
(comments included).

<p>A simplification was done though: we only start the scan at the edge of the chunk: because we only
need to know which faces can be reached from a given face. Knowing there is a hidden hole in the middle
of a chunk, is an information we don't care at all. That means if the outer layer of the chunk is
completely solid, the flood fill should be rather cheap to compute (and kind of expensive if the chunk
is mostly air).

<p>The visibility of faces is <b>stored in a bitfield</b>. Since there are 6 faces, there are <b>15</b>
possible connections:

<table class="hspace" id="cnxgraphtbl">
  <thead><tr><td><small>to &#x25ba;<br>from &#x25bc;</small><td><tt>S</tt><td><tt>E</tt><td><tt>N</tt><td><tt>W</tt><td><tt>T</tt><td><tt>B</tt>
  <tbody><tr><th><tt>S</tt><td class="XXX"><td>1<td>2<td>3<td>4<td>5
         <tr><th><tt>E</tt><td>1<td class="XXX"><td>6<td>7<td>8<td>9
         <tr><th><tt>N</tt><td>2<td>6<td class="XXX"><td>10<td>11<td>12
         <tr><th><tt>W</tt><td>3<td>7<td>10<td class="XXX"><td>13<td>14
         <tr><th><tt>T</tt><td>4<td>8<td>11<td>13<td class="XXX"><td>15
         <tr><th><tt>B</tt><td>5<td>9<td>12<td>14<td>15<td class="XXX">
</table>

<p>This table shows the connection bit used to encode all the connections there are in a sub-chunk.
The connections are stored in <tt>ChunkData.cnxGraph</tt>: it is a bitfield (<tt>1 &lt;&lt; connectID-1</tt>)
that indicates which face has a visible path to another face. If there are no paths, that means the
face is blocking the visibility of a chunk.

<p>Knowing there is "hole" at the edge of a face (ie: the diagonal of the above matrix) is an information
we don't need, <b>except for the first visible chunk of the frustum</b>. If you start in such a chunk
and looking through that hole, there won't be any connection and therefore the cave culling will stop
right there, which is obviously not good. Those extra 6bits are actually stored in a separate field
(<tt>cdFlags</tt>).

<h5 id="cnxgraph"><span>Graph traversal</span></h3>

<p>This is the part that differs significantly from the blog post: it uses a more conservative approach,
which results in more chunks being drawn, but should not leave any unfilled hole in the world.

<p>The way it is done, is actually pretty simple: since frustum culling orders chunks from near to far,
we then scan the chunks from beginning to the end of that list. From a given chunk, we check if there
is <b>a path within the visibility graph</b> that can reach a previously visible chunk.

<p>We also use the fact that a cube in 3d space only have, at most, 3 visible faces. Going through
hidden faces will add a significant amount of hidden chunks. Visibility of a face is done by computing
the dot product between the face normal and the vector from camera to one point of the face.

<p>Therefore here is a simplified version of the graph traversal algorithm:
<div class="pre">
<ul>
  <li>For each visible <tt>ChunkData</tt> we got from frustum culling:
    <ul>
	  <li>For each face visible of this <tt>ChunkData</tt> (at most 3):
	    <ul>
		  <li>Get neighbor <tt>ChunkData</tt> directly connected to that face.
		  <li>From this neighbor <tt>ChunkData</tt> is there a path that allows us to go from the face
		  we entered this neighbor previously to the <b>opposite face</b> we are currently testing ?
		  <li><b>If yes</b>: save the face we entered current chunk and mark the chunk as visible.
		  <li><b>If no</b>: try with another face.
		  <li><span class="n">Note</span>: besides lack of connectivity, this test can also fail for
		  the following reasons:
		  <ul>
		    <li>The neighbor is outside frustum.
			<li>The neighbor was removed from the list by a previous iteration of this algorithm.
		  </ul>
		</ul>
	  <li>If there are no paths to any faces of the <tt>ChunkData</tt>, remove this chunk from the
	  visible list.
	</ul>
</ul>
</div>

<p>Knowing this, you'll notice that the first chunk in the list is a bit special: there are no particular
faces where we entered this chunk. Since we don't know where we came from in this very first chunk, we
simply assume all directions are valid: this is what is encoded in the table <tt>canGoTo[]</tt>: For each
<tt>S, E, N, W, T, B</tt> face we want to check, assume assume we came from every direction, therefore
check connectivity for any direction.

<p>If a <tt>ChunkData</tt> is connected to this first chunk, we want to know if there is a path to that
face, from <b>any other direction</b>. Therefore we check all the connection ID that are possible
for a given face, as described in the <a href="#cnxgraphtbl">previous table</a>. So if we want to know
if we can reach the south face of the first chunk, we check if one of the connection ID is set for the
south face, that is either 1, 2, 3, 4 or 5. Since connection graph is encoded as bitfield, the test becomes:
<pre><t>static int</t> canGoTo[] = {
	<v>0x001f</v>+(<v>1</v>&lt;&lt;<v>15</v>), <span class="c">/* to south:  1+2+4+8+16 */</span>
	<v>0x01e1</v>+(<v>1</v>&lt;&lt;<v>16</v>), <span class="c">/* to east:   1+32+64+128+256 */</span>
	<v>0x0e22</v>+(<v>1</v>&lt;&lt;<v>17</v>), <span class="c">/* to west:   2+32+512+1024+2048 */</span>
	<v>0x3244</v>+(<v>1</v>&lt;&lt;<v>18</v>), <span class="c">/* to north:  4+64+512+4096+8192 */</span>
	<v>0x5488</v>+(<v>1</v>&lt;&lt;<v>19</v>), <span class="c">/* to top:    8+128+1024+4096+16384 */</span>
	<v>0x6910</v>+(<v>1</v>&lt;&lt;<v>20</v>), <span class="c">/* to bottom: 16+256+2048+8192+16384 */</span>
};
<span class="c">/* neighbor is the first ChunkData */</span>
<span class="k">if</span> ((neighbor->cnxGraph | (neighbor->cdFlags &lt;&lt; <v>15</v>)) &amp; canGoTo[oppSide])
{
	<span class="c">/* yes, we can */</span>
	cur->comingFrom = side;
	<span class="k">break</span>;
}
</pre>

<p>The <tt>cdFlags</tt> test is needed in case the <tt>cnxFlags</tt> is empty (ie: no connections to
any faces at all), but the chunk has holes at the edge of a face.

<p>This method is not as aggressive as the current version of <prod>Minecraft</prod>: it is far from
simulating a raycasting traversal, but can still easily cull 50% of chunks when above ground, and nearly
90% when underground. Still, way better than the first version.


<h3 id="altimpl"><span>Alternate implementation</span></h2>

<p>Understanding what's going on in a 3d space is usually quite difficult, since it usually involves
a lot of information: whether you try to do step by step debugging or display something in the 3d world,
the result is going to be tedious to analyze. An alternate implementation exists that limits the problem
in 2d space, which makes it <b>much easier</b> to understand and refactor in case of problems.

<p>Check out the repository <a href="https://github.com/crystalcrag/MCEdit-utils">MCEdit-utils</a>:
the <tt>Frustum</tt> utility implement more or less everything that has been described in this chapter.
This utility is actually <b>the reference implementation when something has to be changed</b> in the
frustum culling algorithm, be it due to bug fix or trying to improve the function.



<h2 id="blocks">Block API</h2>

<p>This section will describe how the block description table works (<tt>blocksTable.js</tt>). This
table describes all of the blocks recognized by this engine and their different states, along with
their custom models if any.

<p>This table does not cover 100% of use cases though: you cannot change it and expect to have a
completely different "game". Some special processing is hardcoded within the engine (like redstone
behavior, block with tile entities). Still, this table is used to define a huge chunk of the engine
behavior.

<p>This table uses the javascript object notation format. It is similar to the JSON format, with a few
changes: property names don't have to be enclosed in double quotes and property values can contain expressions.

<p>For the sake of simplifying the parsing, property names have to start with a <b>lower case letters</b>,
constants assigned to property must be spelled using only <b>uppercase letters</b>.

<p>This table contain <b>2 types of objects</b>:
<ol>
  <li><b>Block description</b>: contain generic information about the block, like its type, id,
  name, inventory category, inventory model, ... That information must remain true for all states.
  If that's not the case, some properties can also be declared at the state level.
  <li><b>State description</b>: also known as meta-data. Each block in the terrain can have up to 4bits
  of extra information, that can describe 16 different states. This is the purpose of these objects:
  provide a complete description of one state: custom mesh model and/or texture coordinate if block
  is completely solid. Not all 16 states have to be defined, but at least 1.
</ol>

<h3 id="blockdesc"><span>Block description</span></h3>

<p>A block description must contain the property <tt>id</tt> and be assigned to an integer. Here are the
possible properties:
<ul>
  <li><tt>id</tt>: the block ID as it is stored in the NBT table <tt>Sections/Blocks</tt> of a chunk.
  <li><tt>type</tt>: how the block will be rendered in the world. This field will constraint what is
  expected for state description. <b>This is a very important field</b>, you can choose one value among:
  <ul>
    <li><tt>INVIS</tt>: invisible. No mesh will be generated for these (typical use case: AIR).
    <li><tt>SOLID</tt>: a full 1x1x1 voxel cube. This engine is optimized to display these. They are
	cheap to process, cheap to render and cheap to define: just specify the texture of the 6 sides of
	the cube and that pretty much all there is to it.
	<p>Note: stairs and slab are considered SOLID blocks.

    <li><tt>TRANS</tt>: Similar to SOLID, they must be defined as a full unit cube. The difference is
	in the way hidden surface removal works: for SOLID blocks, all sides shared by any other solid block
	will be removed. For TRANS block, this check will only be done with the same block id (typical use
	case: glass or water).
    <li><tt>QUAD</tt>: for blocks that are a mix of flat quads that does not necessarily forms a cube.
	Typical use case: crops, grass or flowers.
    <li><tt>CUST</tt>: completely arbitrary shape, a custom model will be expected for each state
	description. Keep in mind that the model cannot exceed a 1x1x1 cube in size, because of frustum
	culling. If you need more, you will have to use an entity instead.
  </ul>
  <li><tt>name</tt>: a human readable name that will be displayed in various places of the engine.
  <li><tt>tech</tt>: the technical name stored in inventories. If the name is the same as the <tt>name</tt>
  field (but converted to lowercase and space replaced with underscore), you can omit that field.
  <li><tt>inv</tt>: how this block is going to be represented in inventory menus. It is an enumeration
  value that can be assigned to one of the following values:
  <ul>
    <li><tt>CUBE</tt>: each individual states will have its own inventory item in the form of a cube. The
	textures used for the cubes will be described in the state description. In the screenshot below, cube
	inventory items have been highlighted with a green background.
    <li><tt>ITEM2D</tt>: each states will be represented as flat 2d texture (taken from state description).
	In the screenshot below, they have a gray background.
    <li><tt>MODEL</tt>: will use a custom model for their inventory. The model will be viewed at an angle
	using a orthographic projection (not a perspective one). You can provide a custom model to be used
	only in inventories, or you can reuse the ones defined in the state description. In the screenshot
	below, those items have been highlighted with a red background.
  </ul>
  <div class="image">
    <img src="images/inventory.png">
  </div>
  <li><tt>invstate</tt>: sometimes, you don't want to have one inventory item per state, but only one
  (typical use case: blocks that have an orientation). If this field is present, it must contain the
  state id (between 0 and 15) to use when displaying this item in inventories.
  <li><tt>cat</tt>: the creative menu is split into tabs. This field let you choose which one it will
  be in. If not specified, the item will appear in the "all" category (the tab with the compass, in the
  screenshot above). You can choose one value among;
  <ul>
    <li><tt>BUILD</tt>
	<li><tt>DECO</tt>
	<li><tt>REDSTONE</tt>
	<li><tt>CROPS</tt>
	<li><tt>RAILS</tt>
	<li><tt>FILLBY</tt>: blocks that should not be in survival/creative inventory, but can be used
	as to fill space using extended command (fill and geometric brush).
  </ul>
  <li><tt>special</tt>: special behavior to activate in the engine. Possible choices:
  <ul>
    <li><tt>CHEST</tt>: chest that can form a 2-wide entity. Therefore, that does not include ender chest.
    <li><tt>DOOR</tt>: behave like a door: 2 tall block with the same data values.
    <li><tt>NOSIDE</tt>: will generate a front and back face (typical use is for QUAD block type).
    <li><tt>HALF</tt>: half block: data values will encode placement.
    <li><tt>STAIRS</tt>: data value will encode orientation.
    <li><tt>GLASS</tt>: behave like a glass pane: automatically connect to nearby block with this
	special attribute set (like glass pane and iron bars).
    <li><tt>FENCE</tt>: wooden fences that connect with similar block.
    <li><tt>FENCE2</tt>: nether fence (does not connect with FENCE).
    <li><tt>WALL</tt>: cobblestone wall and variants: it connects with more block than FENCE or GLASS.
    <li><tt>RSWIRE</tt>: used for redstone wire only: wire model depends on nearby blocks.
    <li><tt>LEAVES</tt>: hidden surface must not be removed.
    <li><tt>LIQUID</tt>: water and lava.
    <li><tt>TALLFLOWER</tt>: need a special flag for these, because they are made of 2 blocks.
    <li><tt>RAILS</tt>: this flag is used when placing rails to know which neighbor to update.
    <li><tt>TRAPDOOR</tt>: block update from redstone/user.
    <li><tt>SIGN</tt>: they need special processing (allocate off-screen texture).
    <li><tt>PLATE</tt>: pressure plate (needed for redstone signal).
    <li><tt>SOLIDOUTER</tt>: only useful for <tt>CUST</tt> block type: the block model will be a mix
	of <tt>SOLID</tt> and <tt>CUBE</tt>: the outer layer of the model will use a unit textured cube,
	using the texture declared in the <tt>tex</tt> field of the state description. The purpose of
	this flag is to allow custom block model to benefit from ambient occlusion.
    <li><tt>BED</tt>: their models depend on tile entity.
  </ul>
  <p>Additionally, you can OR these values, with the following flags (ie: separated by |):
  <ul>
	<li><tt>CNXTEX</tt>: generate connected texture for all state description. Texture will be auto-generated
	from state description.
	<li><tt>NOCONNECT</tt>: don't generate connected info. Typical use case: fence gates. They connect
	with fences, and therefore have the FENCE flag, but don't have optional parts like fences.
  </ul>
  <li><tt>bbox</tt>: how the block can be targeted with the mouse. Enumeration value, with the following
  choices:
  <ul>
    <li><tt>NONE</tt>: this block cannot be targeted by user.
    <li><tt>AUTO</tt>: this mode will be automatically set for block type <tt>SOLID</tt>, <tt>TRANS</tt>
	and <tt>QUAD</tt>. Therefore, you can omit the <tt>bbox</tt> field for these types.
    <li><tt>MAX</tt>: this type is intended for <tt>CUST</tt> block type: <tt>MAX</tt> will compute
	the maximum axis-aligned box that covers the entire model.
    <li><tt>FULL</tt>: another mode for <tt>CUST</tt> block type: each individual part of a custom model
	will be used to check if the block is targeted. This type of collision test is very precise, but
	of course a bit more expensive to check.
  </ul>

  <li><tt>bboxPlayer</tt>: bounding box used for player/entity collision detection. The only supported
  value for this field is <tt>NONE</tt>. Otherwise, it will use the same value than the one specified in
  the <tt>bbox</tt> entry.

  <li><tt>orient</tt>: if block placement is orientation dependent, you can specify with this field
  how individual state description can be automatically chosen based on player orientation and/or block
  targeted:
  <ul>
    <li><tt>LOG</tt>: 3 possible orientation: E/W, N/S, or up right.
    <li><tt>FULL</tt>: 6 possible orientation: south, east, north, west, top, bottom.
    <li><tt>BED</tt>: 4 possible orientation, composed of 2 blocks.
    <li><tt>SLAB</tt>: 2 orientation: lower half, upper half.
    <li><tt>TORCH</tt>: 5 orientation: stick to wall or up right.
    <li><tt>STAIRS</tt>: 8 orientation.
    <li><tt>SENW</tt>: 4 orientation (typical: chest, furnace).
    <li><tt>SWNE</tt>: 4 orientation but different state description (typical: repeaters, comparators).
    <li><tt>DOOR</tt>: 8 orientation.
    <li><tt>SE</tt>: 2 orientation: E/W or N/S, typical use case: rails.
    <li><tt>LEVER</tt>: 8 possible orientation: used by lever and buttons.
  </ul>

  <li><tt>emitLight</tt>: if this block will emit block light, you can indicate a value between 1 and 15
  (0 being the default).

  <li><tt>opacSky</tt>: how much intensity of sky light it will absorb. Default is 15 for <tt>SOLID</tt>
  and 0 for everything else. Usual values are 1 for leaves and 3 for water.

  <li><tt>opacLight</tt>: same with block light. Note: block light decreases by 1 for every step away
  from a light source. Therefore if you want a more "absorbing" block, the minimum value should be 2.

  <li><tt>tile</tt>: will add a default tile entity when placed in the world. Needed by Minecraft, not
  necessary for this engine.

  <li><tt>invmodel</tt>: state id (between 0 and 15) where to copy model to be rendered in inventories.
  This particular block will have only one item in the creative menu (instead of one per state).

  <li><tt>rswire</tt>: indicates how redstone wire connects to this block. Possible values are:
  <ul>
    <li><tt>ALLDIR</tt>: all possible direction (S, E, N, W).
    <li><tt>FRONTBACK</tt>: can connect to the front and back of the block (repeaters).
    <li><tt>BACKONLY</tt>: only from back (observer).
  </ul>

  <li><tt>rsupdate</tt>: indicates if this block cares about redstone update. Enumeration that can
  have one of the following values:
  <ul>
    <li><tt>RECEIVE</tt>: block state will change when redstone signal change nearby.
    <li><tt>GENERATE</tt>: will generate the redstone signal.
    <li><tt>INOUT</tt>: will do both: update states with redstone signal and output a signal (ie: repeaters, comparators).
  </ul>  

  <li><tt>placement</tt>: constraint the block has to satisfy to be placed in the world. If those
  constraint were to be invalidated due to nearby update, the block will be automatically deleted.
  The field should be a string, described a list of constraints separated by commas. Each constraint
  can use the following keyword:
  <ul>
    <li><tt>ground</tt>: any type of solid flat ground.
    <li><tt>wall</tt>: any type of solid flat wall.
	<li><tt>solid</tt>: any solid face from a block.
	<li><em>techName</em>: that particular block.
  </ul>
  <p>Note: the block is considered correctly placed if one of the constraint is satisfied. "Solid"
  means a block that has been declared with the type <tt>SOLID</tt>. That excludes <tt>CUST</tt> and
  <tt>TRANS</tt>.

  <li><tt>particle</tt>: type of particles this block will emit constantly.

  <li><tt>invmodel</tt>: custom model to use when this block is displayed in inventories. Should only
  be necessary for block type <tt>CUST</tt>, even though nothing prevent you from using with any other
  type. The format of this field is a bit complicated and be explained in the <a href="#blockmodel">next section</a>.

  <li><tt>pushable</tt>: how this block is going to be affected if pushed/retracted by a piston. Enumeration
  value that can take one of the following value:
  <ul>
    <li><tt>NO</tt>: block can't be pushed, nor retracted (obsidian, chests, ...)
    <li><tt>YES</tt>: default value for all blocks except <tt>QUAD</tt>.
    <li><tt>PUSHONLY</tt>: can only be pushed, but not retracted (glazed terracotta).
    <li><tt>DESTROY</tt>: completely destroy the block if pushed (leaves, grass, ...): this is the
	default for <tt>QUAD</tt>.
    <li><tt>DROPITEM</tt>: remove the block, but create an item entity (flowers, ...).
  </ul>
  <p><b>Note</b>: this engine supports moving blocks containing tile entities (furnace, chests, ...),
  even though in the default block definition file (<tt>blocksTable.js</tt>), they have been marked
  as non-movable.

  <li><tt>gravity</tt>: integer that can be either <tt>0</tt> or <tt>1</tt>. If set to <tt>1</tt>, the
  block will be converted to a falling entity, if placed above air (be it manually or with pistons).

  <li><tt>keepModel</tt>: hack.
</ul>

<h3 id="statedesc"><span>State description</span></h3>

<p>An object declaration is recognized as a state declaration if it is contains a <tt>state</tt> property
with an integer assigned to it. Beside this property, you can also use these ones:
<ul>
  <li><tt>state</tt>: an integer between 0 and 15 that will be stored in <tt>Sections/Data</tt> table in a chunk.
  This table has only 4bits of information per block. More information can be stored using TileEntity.
  <li><tt>name</tt>: this field should describe a bit more in detail what the state is doing: for example,
  if the block is orientation dependent, you should include which way the state is pointing, or if the
  block has an opened/closed state, this is where it should be described...

  <p>Since this field will almost certainly have <b>a lot of redundant information</b>, there are a few
  facility to prevent you from repeating the same text over and over again: the less redundancy, the
  easier it will be to fix mistakes.

  <p>First, a state name can include an underscore (<tt>_</tt>) in the text. This character will
  act as a reference point for later names. The character itself will be replaced by a regular space.

  <p>Once you have a reference point, you can ask to include everything that was before using the <tt>+</tt>
  or <tt>-</tt> character, and then continue your text.

  <p>The text being appended will always be added with a parenthesis before (and a closing one if none
  are specified in the text), unless there was already an opening one in the text that was copied.

  <p>Here are a few examples:
  <table class="listview">
  <thead><tr><td class="nowrap">Block name<td>State name<td>Expanded into<td>Description
  <tbody>
    <tr><td rowspan="4"><tt>Log</tt><td><tt>+oak</tt><td><tt>Log (oak)</tt><td>Without any previous underscore, the whole text of block will be added.
    <tr><td><tt>+spruce</tt><td><tt>Log (spruce)</tt><td>Still no underscore specified, the reference point will remain the same on next line.
    <tr><td><tt class="nowrap">Bark (_oak)</tt><td><tt>Bark (oak)</tt><td>If the text does not include <tt>+</tt> or <tt>-</tt>, then it replaces everything. A new reference point is also set.
	<tr><td><tt>-spruce</tt><td><tt class="nowrap">Bark (spruce)</tt><td>The new reference point now point to a state description, instead of the block.
  </table>

  <li><tt>tex</tt>: texture coordinates to use to draw the faces of that block. Coordinates are actually
  tile coordinates: integers between 0 and 31 that will point to a texture tile in the file <a href="../resources/terrain.png">terrain.png</a>.
  That way the coordinates will work no matter what resolution the file is, the default tile set is 16x16px,
  but you can use whatever size you want (tiles needs to be square though). Although allowed, it is
  strongly discouraged to use a size that is not a power of 2, due to mipmapping (texture will "bleed"
  at the edge of tiles). You can omit that field, in which case it will use the same texture coordinates
  than the previous state (as declared in the file).

  <p>This field is expecting an array of integers. The number of coordinates will depend on the type of the block:
  <ul>
    <li><tt>SOLID</tt>, <tt>TRANS</tt>: 12 integers that form 6 pairs of U, V tile coordinates, one
	pair for each faces, specified in the order <tt>S,E,N,W,T,B</tt>. The coordinate must be specified
	relative to the top left corner of the tile you want to use for that face.
	<li><tt>QUAD</tt>: 2 integers: the tile texture to use for all quads (integer between 0 and 31).
	<li><tt>CUST</tt>: 8 integers: technically not required to render the block, since block model will
	provide their own texture coordinates, but this field will still be used for particles when this
	block is destroyed by the user. You don't have to specify the texture for the top and bottom face
	though, although it doesn't hurt to include them.
  </ul>

  <p>Filling those values manually is possible, albeit tedious and error prone. In the default <tt>blockTable.js</tt>
  field, all the values where filled with the help of <tt>TileFinder</tt> (check out the repository
  <a href="https://github.com/crystalcrag/MCEdit-utils">MCEdit-utils</a>).
  
  <p>This field can include a 13th integer, that will be used to specify the <tt>rotate</tt>
  field (because <tt>TileFinder</tt> can read and write those 13 values at once).

  <li><tt>quad</tt>: an array of symbols indicating which quad to render for this block. Each symbol
  can be one of the following enumeration value:
  <ul>
    <li><tt>CROSS</tt>: used for flower, grass, ...
	<li><tt>SQUARE</tt>: usually crops.
    <li><tt>NORTH</tt>: attached to north of block (ladder, vines).
    <li><tt>SOUTH</tt>: attached to south face.
    <li><tt>EAST</tt>: east face.
    <li><tt>WEST</tt>: west face.
    <li><tt>BOTTOM</tt>: bottom of block (lily pad).
    <li><tt>ASCE</tt>: ascending from west to east (rails).
    <li><tt>ASCW</tt>: ascending from east to west.
    <li><tt>ASCN</tt>: ascending from south to north.
    <li><tt>ASCS</tt>: ascending from north to south.
  </ul>

  <li><tt>inv</tt>: this field can be used to override what has been specified at the block level.
  Remember, that the type of inventory item specified in the block will be applied to all state description.
  The typical use case is to prevent some states from appearing in the inventory (ie: <tt>NONE</tt>).

  <li><tt>model</tt>: an array of floating point numbers. This field is absolutely not intended to be
  edited manually. The format will be described <a href="#blockmodel">below</a>, but even with this
  description, you'll have a hard time filling this field manually.
  <p>Instead, an external tool is almost required: <tt>TileFinder</tt>. You'll notice that all models
  are declared on their own lines (there no JSON tokens mix in those lines, besides what's required
  to make an array of numbers). The reason for this, is that those lines can be selected in a standard
  text editor, then copied and pasted inside <tt>TileFinder</tt> to see what the model looks like.
  You can also copy the model from <tt>TileFinder</tt> to the text file again, if you modify it later.

  <li><tt>rotate</tt>: rotate applied to texture coordinate, 6 groups of 2 bits. Rotation are ordered
  <tt>S,E,N,W,T,B</tt>. The texture will be rotated in multiple of 90&deg; clock-wise (when viewed
  in front), the multiple being the number encoded as 2bits.

  <li><tt>emit</tt>: where emitters are located in the model. An array containing one emitter location
  per entry. It can be one of the letter <tt>S,E,N,W,T,B</tt>, indicating that the entire face can emit
  particles (the location will be randomly selected when a particle is spawned). Or it can be a number:
  if the block has a custom model, this is the primitive number that will be used as location.
</ul>

<h3 id="blockmodel"><span>Block models</span></h3>

<p>Custom models that don't fit <tt>QUAD</tt> or <tt>SOLID</tt> can still use arbitrary shapes using
the property <tt>model</tt> on a state description object. All the models has been filled using using
an external application: <tt>TileFinder</tt>. This section will describe how the models are encoded,
but be warned that this format has not been designed to be manually edited.

<p>Contrary to typical models description format (like <tt>.obj</tt>) which usually only contains
triangles, this format uses cubes/boxes as basic primitives, where each face can be selectively
hidden or textured. You can also apply rotation, scaling, translation to each individual box and
by grouping multiple boxes, you get a model.

<p>Each lines usually represent a primitives (ie: box), even though to keep line length under control,
some might have been wrapped. The first number is a bit field encoding quite a few parameters:
<ul>
  <li><tt>bit0~5</tt>: faces activated for this box, bitfield ordered <tt>S,E,N,W,T,B</tt>. Faces not
  activated will have no triangles generated for them at all.
  <li><tt>bit6</tt>: normals are inverted: ie: if south face is active, it should use normal for the
  north face.
  <li><tt>bit7</tt>: texture should be applied using a cube map. Texture coordinates refer to a
  tile in the main texture file, but should be reduced according to the face size/position.
  <li><tt>bit8</tt>: if set, it means there are more primitives following this one.
  <li><tt>bit9~10</tt>: model needs to be rotated by 90 degrees increment CCW (ie: trigonometric rotation).
  Careful though: normals will need to be readjusted. This field is carried to next primitives if any,
  therefore should only be set on the first one.
  <li><tt>bit11~16</tt>: detail face: <tt>S,E,N,W,T,B</tt> bitfield indicating faces for which an exact
  texture coordinate will be provided, instead of a cube map. Usually <tt>bit7</tt> is also set when
  using these.
  <li><tt>bit17~...</tt>: face ID: used for models that have optional parts (fences, glass panes, iron bar, restone
  dust, ...). More on this field later.
</ul>

<p>After that, numbers are a bit more straightforward:
<ul>
  <li><b>3 floats</b>: size of the box, in 1/16 units (ie: 16 = a full voxel), specified in X, Y, Z order.
  Can be fractional if needed. Model can have size of up to <tt>112x112x112</tt> (7 voxels). Although,
  due to frustum culling, it is advised to keep them below 16x16x16 (1 voxel).
  <li><b>3 floats</b>: translation to apply, also in 1/16 unit, that will be applied to the X, Y, Z axis.
  <li><b>3 floats</b>: rotation in degrees, CCW (trigonometric rotation) on the X, Y, Z axis.
  <li><b>3 floats</b>: rotation in degrees, CCW. The difference with the previous 3 numbers, is that
  these rotations will be carried onto the next primitives.
</ul>

<p>At last, these number can be followed by up to 24 integers which represent the UV coordinates of
the texture to use for the faces defined for this box. There are 4 numbers per face. The number of
faces is the number of bits activated in the first number (ie: <tt>popcount((int) model[0] & 63) * 4</tt>).

<p>Each number must encode a <tt>UV</tt> coordinate as two integers. <tt>U</tt> can vary from 0 to 512,
and <tt>V</tt> from 0 to 1024. <tt>U</tt> can therefore address 513 numbers, thus the formula for each
number is <tt>U + V * 513</tt>.

<h2 id="NBTapi">NBT API</h2>

<p>This module is used to read, write and modify NBT (<tt>Named Binary Tag</tt>) file format from disk
and/or memory. NBT is used to store arbitrary data types in a tree-like structure (ie: nested up to
any depth). In some ways, it can be seen as a binary JSON. NBT file are often being compressed using
either gzip or zlib compression, this module handle decompression by the use of the <tt>zlib</tt> library
(this module does not roll its own decompression algorithm).

<p>NBT API in this engine does not exactly follow a traditional API you might expect for manipulating
a tree of arbitrary data types. The main problem that this API was trying to solve is to keep 
everything related to an NBT tree as close as possible in memory, to benefit from cache locality.

<p>This is actually the main focus of this API: it <b>strongly</b> favors read over write access. The
rationale for this choice being that most chunks in a map will never be modified at all, and for those
that will, most of the time it is simply a matter of overwriting some tables (<tt>BlockLight</tt>,
<tt>Blocks</tt>, <tt>Data</tt>, ...).

<p>There are a few lists (<tt>TileEntities</tt>, <tt>Entities</tt>, <tt>TileTicks</tt>, ...) where the
content can change significantly, and this is where this API will be a bit more tedious to use than other
APIs.

<p>The gist of how this API works is to serialize the content of a NBT file into a <b>single memory
block</b>. This block will be reallocated if the first allocation was not enough, but <b>everything</b>
will be kept into a contiguous block of memory. Therefore the binary representation of the NBT structure
in memory will actually be <b>very close</b> to how it is stored on disk (if it were uncompressed): save
a few memory alignment constraints and byte ordering, and you could write the buffer almost directly
to disk.

<p>Sadly, that also means, in order to use this API, you'll need to have a pretty good understanding
on how NBT is structured on disk, because that API is a very shallow abstraction over that. A refresher
will be available in the next section.




<h3 id="NBTspec"><span>NBT Structure</span></h2>

<p>This section is a quick refresher on how NBT is structured (uncompressed). This format can store
arbitrary data types, in a tree-like format with branch nested as deep as you want.

<p>NBT supports <b>3 major families of types</b>:
<ol>
  <li><b>Scalar</b>: designate an immediate value, which can be an integer (1, 2, 4 or 8 bytes), a
  floating point number (32 or 64bits) or a string.
  <li><b>List</b>: contains a finite number of scalar and/or compound (all of the same type).
  <li><b>Compound</b>: an arbitrary number of scalar, list or even nested compound, one after the other:
  a field terminator is used to mark the end of the block.
</ol>

<p>Usually an NBT object/file always starts with a <b>Compound</b> or <b>List</b>, otherwise it will
be limited to a single scalar value, which is not very useful. Each type is stored using a header and
a payload. The header follows the same structure for every type, the payload is obviously specific to
each type.

<p>Also, integers bigger than 1 byte and floatting point types are stored in <b>big endian</b> format.

<h4>Header</h4>

<p>Here is the structure of the header:
<ul>
  <li><b>1 byte</b>: the first byte encode the type of the record. Here are the possible values:
  <table>
  <thead><tr><td>Num<td>Define<td>Description
  <tbody>
    <tr><th>0<td><tt>TAG_End</tt><td>This type is used to mark the end of a compound.
	<p><span class="n">Note</span>: a <tt>TAG_End</tt> does not have any payload beyond this single byte.
    <tr><th>1<td><tt>TAG_Byte</tt><td>Used to store an <tt class="t">uint8_t</tt>.

    <tr><th>2<td><tt>TAG_Short</tt><td>Store an <tt class="t">uint16_t</tt>.
    <tr><th>3<td><tt>TAG_Int</tt><td>Store an <tt class="t">uint32_t</tt>.
    <tr><th>4<td><tt>TAG_Long</tt><td>Store an <tt class="t">uint64_t</tt>.
    <tr><th>5<td><tt>TAG_Float</tt><td>Store an <tt class="t">float</tt>.
    <tr><th>6<td><tt>TAG_Double</tt><td>Store an <tt class="t">double</tt>.
    <tr><th>7<td><tt>TAG_Byte_Array</tt><td>Store an <tt class="t">uint8_t</tt> array.
    <tr><th>8<td><tt>TAG_String</tt><td>Store an <tt class="t">uint8_t</tt> array
	<p>The main difference between <tt>TAG_ByteArray</tt> is the maximal length of the array.
	<tr><th>9<td><tt>TAG_List</tt><td>Store an arbitrary number of a given object (which can be scalar or compound).
	<p><span class="n">Note</span>: a <tt>TAG_List</tt> of <tt>TAG_End</tt> is permitted
	if the number of items is 0.

	<tr><th>10<td><tt>TAG_Compound</tt><td>Store an arbitrary number of scalar/compound, not necessarily
	of the same types.
	<p>The last item of a compound, must be a <tt>TAG_End</tt>.
    <tr><th>11<td><tt>TAG_Int_Array</tt><td>Store an <tt class="t">uint32_t</tt> array.

	<p>Why is it not stored as a <tt>TAG_List</tt> of <tt>TAG_Int</tt>, you might ask ? Well, I guess someone forgot this
	type existed...
	<p>This type is used by the <tt>HeightMap</tt> entry of a chunk to store the highest
	value where sky light is at max level.
  </ul>
  </table>

  <li><b>2 bytes</b>: all types, except <tt>TAG_End</tt>, are followed by 2 bytes, which encodes a length
  <p><span class="n">Note</span>: keep in mind, that this length is stored as a big endian number.
  <li><b>[length] bytes</b>: will contain a string that is the name of this tag (not the value itself).
  <li><b><em>remaining</em></b>: payload section.
</ul>

<h4>Payload</h4>

<p>Finally, here are the structure of the different payload sections, according to each tag:
<table>
<thead><tr><td>Num<td>Define<td>Description
<tbody>
  <tr><th>1<td><tt>TAG_Byte</tt><td>Followed by 1 byte: the integer value.
  <tr><th>2<td><tt>TAG_Short</tt><td>Followed by 2 bytes: the integer value in big endian format.
  <tr><th>3<td><tt>TAG_Int</tt><td>Followed by 4 bytes.
  <tr><th>4<td><tt>TAG_Long</tt><td>Followed by 8 bytes.
  <tr><th>5<td><tt>TAG_Float</tt><td>Followed by 4 bytes, encoding a floating point in big endian using the IEEE 754 format).
  <tr><th>6<td><tt>TAG_Double</tt><td>Followed by 8 bytes.
  <tr><th>7<td><tt>TAG_Byte_Array</tt><td>followed by:
    <ul>
	  <li><b>4 bytes</b>: encodes a length.
	  <li><b>[length] bytes</b>: content of the array.
	</ul>
  <tr><th>8<td><tt>TAG_String</tt><td>Followed by:
    <ul>
	  <li><b>2 bytes</b>: encodes a length.
	  <li><b>[length] bytes</b>: content of the string (usually UTF-8 encoded, not 0-terminated).
	</ul>
  <tr><th>9<td><tt>TAG_List</tt><td>Followed by:
    <ul>
	  <li><b>1 byte</b>: object type stored in this list (any types except <tt>TAG_List</tt>).
	  <li><b>4 bytes</b>: number of items in the list.
	  <li><b>...</b>: N objects of given type. In case of scalar, it will N times the size of given scalar.
	  For compound list the size can be completely arbitrary.
	</ul>
	<p class="cont"><span class="n">Note</span>: <tt>TAG_List</tt> of <tt>TAG_Compound</tt> are a bit special though:
	<ul>
	  <li>Compounds in a list don't have name. Therefore a compound entry in a list is simply a list
	  of scalar values until a <tt>TAG_End</tt> is found.
	  <li>The list ends when [N] compounds have been read (the list itself is not terminated by a <tt>TAG_End</tt>).
	</ul>
  <tr><th>10<td><tt>TAG_Compound</tt><td>Immediately followed by NBT tags (including nested compounds),
  one after the other, until a <tt>TAG_End</tt> is found.
  <tr><th>11<td><tt>TAG_Int_Array</tt><td>Followed by:
    <ul>
	  <li><b>4 bytes</b>: length of the array.
	  <li><b>[length] <tt>TAG_Int</tt></b>: content of the array.
	</ul>
	<p>Thanks to this type, 1 (ONE) byte is saved in the uncompressed stream over using a <tt>TAG_List</tt>.
</table>

<p>Knowing all of this is kind of important, because, when an NBT is read into memory, <b>it will mimic
this structure very closely</b> (save a few alignment adjustment and endianess conversion). Also, when you'll
have to build a NBT fragment, you'll have to match this structure: this API has <b>very little</b>
consistency checks in that regard.

<h4>Example</h4>

<p>Let's look at a small example:
<pre><t>static uint8_t</t> nbt_stream[] = {
	<v>0x0A</v>, <v>0x00</v>, <v>0x00</v>, <v>0x02</v>, <v>0x00</v>, <v>0x03</v>, <v>0x6D</v>, <v>0x61</v>, <v>0x70</v>, <v>0x00</v>, <v>0x0C</v>, <v>0x00</v>
};
</pre>

<ol>
  <li>First byte is 10, which indicates the start of a compound.
  <li>Next 2 bytes are 0, 0: this is the length of the compound name. Since it is zero, the first 3
  bytes marks are the entirety of the compound header. Immediately following, will be a list of
  NBT tags, until <tt>TAG_End</tt> is found.
  <li>Next byte is 2, which is a <tt>TAG_Short</tt>.
  <li>Next 2 bytes are 0, 3, which means this entry has a name of 3 characters.
  <li>Next 3 bytes are 'm', 'a', 'p': this is the name of this tag (not its value).
  <li>Next 2 bytes (payload of a <tt>TAG_Short</tt>) is 0, 12, therefore the value associated to this
  entry is 12.
  <li>Finally 0 marks the end of the compound, and therefore end of the file.
</ol>

<p><span class="n">Note</span>: this is the structure of the file <tt>World/data/idcounts.dat</tt>.



<h3 id="NBTspecapi"><span>NBT Structure in API</span></h3>

<p>This section will explain how this API process NBT files at a high level: some of the techniques induce
a few caveats that you need to be aware before being able to understand this API.


<p>Like said in the previous sections, once read into memory, a NBT file is just <b>a contiguous memory
buffer</b>. If you look at the main type definition for a NBT file, that's all you'll find:
<pre><t>struct</t> NBTFile_t
{
	<t>int</t>   usage, max;
	<t>int</t>   alloc, page;
	DATA8 mem;
};
</pre>

<p><tt>mem</tt> contains the NBT tags, <tt>usage</tt> is how many bytes are stored, <tt>max</tt> is how
many bytes have been allocated. <tt>alloc</tt> and <tt>page</tt> are only needed when reading the file
(and can be ignored/repurposed after that). This has a few <b>advantages</b>:
<ul>
  <li>All the information related to a NBT file is guaranteed to be <b>close in memory</b>: this is interesting
  to benefit from the CPU cache.
  <li>Since there is just a single buffer, the only thing to do to <b>free the memory</b> is to call <tt>free()</tt>
  on the <tt>mem</tt> field: no need to recursively scan all the entries of the file.
  <li>More often than not, you can get away by just <b>keeping the <tt>mem</tt> field</b> (ie: just a single
  pointer). Indeed, if you look at the API, some functions only accept a <tt>DATA8</tt> as for the NBT
  file. This buffer contains enough information to find everything (including end of buffer).
  <li>Likewise, if the only thing you have is a raw pointer to a NBT stream, a <tt>NBTFile_t</tt> can
  be trivially constructed by just assigning the <tt>mem</tt> field to that buffer. If the only thing
  you care is reading (and not modifying), the other fields don't matter.
</ul>

<p>Obviously, there are <b>drawbacks</b> to this approach:
<ul>
  <li>The abstraction provided by the API is kind of shallow: you have to be sure to replicate exactly
  the specification of a NBT file. For example, if you create a compound, you'll have to add the
  <tt>TAG_End</tt> manually, this API won't help you. This is harder than it seems, especially when
  compounds are nested, it is kind of easy to forget a <tt>TAG_End</tt> in the stream.
  <li>Adding/removing tags can be expensive. This API has ways to greatly mitigate that cost, but it
  will involve quite a bit of work.
</ul>

<p>Since the buffer <tt>mem</tt> can be reallocated, the API relies <b>heavily</b> on byte offset to
get a reference of a tag or a branch. Indeed, if you look at the API, almost all the functions have an
offset parameter in their list of arguments or return an integer as their result (<v>0</v> will always
be the beginning of the file and <v>-1</v> will signal an error). <b>This is the gist of this API</b>:
you first locate what you want to read/modify/delete, and <b>get an offset to the start of the tag</b>,
then you can do whatever operation you want on that tag.

<h4>Structure</h4>

<p>This part is technically not required to use this API, but for the sake of completeness,
it is still described. This part will described <b>how the NBT file is stored in memory</b>.

<p>All NBT tags start with the following header (using native endianess for integer more than 1 byte long):

<bits>
  <brow><hdr>0: </hdr><bitpart class="sz16" bit="32">16: <em>count</em></bitpart><bitpart class="sz8" bit="16">8: <em>minNameSz</em></bitpart><bitpart class="sz4" bit="8"><em>subtype</em></bitpart><bitpart class="sz4" bit="4"><em>type</em></bitpart><bitpart class="sz0" bit="0"><em>&nbsp;</em></bitpart></brow>
  <brow><hdr>1: </hdr><bitpart class="sz32" bit="32">32: <em>size</em> (in bytes)</bitpart><bitpart class="sz0" bit="0"><em>&nbsp;</em></bitpart></brow>
  <brow><hdr>2: </hdr><bitpart class="sz32" bit="32">32: <em>name</em> (0-terminated)</bitpart><bitpart class="sz0" bit="0"><em>&nbsp;</em></bitpart></brow>
  <brow><hdr>... </hdr><bitpart class="sz32" bit="32">optional: more 32bit words follow to store the name</bitpart><bitpart class="sz0" bit="0"><em>&nbsp;</em></bitpart></brow>
</bits>

<p>Or visualized as a C struct:

<pre style="font-size: 0.9em">
<t>struct</t> NBTHdr_t
{
   <t>uint8_t</t>  type;        <span class="c">/* TAG_* */</span>
   <t>uint8_t</t>  minNameSz;   <span class="c">/* min name len: if 255 need to scan up to 0 byte */</span>
   <t>uint16_t</t> count;       <span class="c">/* number of entries after this node (TAG_List only) */</span>
   <t>uint32_t</t> size;        <span class="c">/* size of entire hierarchy under this node (including header + name) */</span>
   <t>uint8_t</t>  name[<v>4</v>];     <span class="c">/* name of node (4-byte alignment) */</span>
};
</pre>

<p>Each field has the following purpose:
<ul class="space">
  <li><tt>type</tt>: the <b>lower 4bits</b> store the main type of the tag stored at this location.
  If the type is <tt>TAG_List</tt>, the <b>upper 4bits</b> store the type of tags stored in the list
  itself. A very common sub-type is <tt>TAG_Compound</tt>, therefore a dedicated define exists for
  these: <tt>TAG_List_Compound</tt>.

  <li><tt>minNameSz</tt>: encodes the <b>length of the <tt>name</tt> field</b> (<b>not</b> including
  padding bytes, and <b>not</b> including final <v>0</v>). This field is used internally to quickly
  have access to the payload section of the tag. This field being 8bits, it means that the maximal
  length of a tag name must be below 255 bytes. In practice, all tag names have less 64 characters.


  <li><tt>count</tt>: if the type of the tag is a <tt>TAG_List</tt>, this field will <b>store the number
  of items</b> in the list. You might see a limitation here: in the NBT structure, this field is 4 bytes,
  whereas here it is only 2. Indeed, in theory this might cause problem, in practice however, having
  more than 65535 items in a list has yet to be seen (and if it happens, it is probably due to a bug).<br>
  <br>
  If this is causing problem in the future, some "bits" could be borrowed from the next field (<tt>size</tt>)
  to increase the precision of this one.

  <li><tt>size</tt>: this field stores the <b>size in bytes of entire tag</b>. This size is always a multiple
  of 4 bytes. The size is the size of the payload and the header. The idea is, if you have an offset
  from the start of a tag, adding the size field will bring you to the next NBT tag.<br>
  <br>

  This field is particularly critical to quickly find tags, without needing to scan entire hierarchies
  of tags. Tags are searched in breadth-first method: first, all the tag names of a given level are
  scanned, then if nothing is found, it will recursively scan sub-level.

  <li><tt>name</tt>: <b>name of the tag</b>: it is a direct dump from NBT stream. This string will always be
  NUL-terminated and padded so that the header size is always a multiple of 4 bytes. I.e: if the name
  of a tag is 4 characters, the <tt>name</tt> will have enough space to store 8.
</ul>

<p>The structure is therefore always at the start of every NBT you'll get from this API. Therefore, the
size of the file can also be retrieved in the first <tt>size</tt> field.

<p>All tags uses this header with the exception of <tt>TAG_End</tt>: this tag is actually encoded as
4 <v>NUL</v> bytes.

<h4>Payload section</h4>

<p><b>Payload immediately follows the structure header</b>. It will be padded to be a multiple of 4
bytes (so that next tag will start on a 4-bytes alignment). All scalar and list of scalars will be
converted to <b>native endianess</b>. This is somewhat useful for list, because you can ask for a raw
pointer to the start of the list, avoiding the need of extra copy/allocation. However, if the list is
short (most of them are), you will be better off asking the payload to be formatted in a certain way.

<p><b>For exemple</b>: some list (especially position of objects within 3d space) can be encoded as 3 <tt>TAG_Int</tt>,
3 <tt>TAG_Float</tt> or 3 <tt>TAG_Double</tt>. If you ask for a raw pointer, you'll have to check the
type and manually do the conversion. This API has functions to copy the content of a list to a specific
format.

<h4>Chunk optimization</h4>

<p>A little trick was used to speed-up accessing the various tables from a chunk: block IDs, data
values, skylight and blocklight values. All those tables will be loaded at fixed offsets from the start
of the compound where they are contained. When saved on disk, the order is not necessarily the same,
but this module will make sure it is once the sections are read back.

<p>That means, if you have a pointer to the start of the block IDs, you can access all the other tables
just by adding a certain offset. It simplify chunk updates considerably, since you only need a single
pointer, which is very easy to carry around.

<p>Last but not least, these tables are accessed very frequently (especially the ones near the player),
having them close to each other will somewhat benefit from the CPU cache.


<h3 id="NBTpost"><span>NBT post processing</span></h3>


<p>This API works rather well when all you want to do is read some data from a NBT file. Even modifying
arrays by directly overwriting payload section of said array is perfectly fine and efficient. However,
this API is not so efficient when you have to modify potentially big list of compounds: adding, removing
and modifying such a list could potentially be very expensive, since the only way to do that is to relocate
huge chunk of memory to make room for a particular NBT fragment. While the computing power available on
a modern CPU can easily handle that kind of load, there are more efficient ways to do this.

<p>The way it is handled in this API, is the ability to marks a <tt>TAG_List_Compound</tt> as being
modified, but not changing anything to the decompressed NBT stream. When time comes to save the changes,
a callback will be triggered and ask to provide an updated version of that list (one compound at a time).

<p>A single NBT file can have multiple lists though: a typical chunk in a <tt>Minecraft</tt> map has
at least 4: <tt>Sections</tt>, <tt>Entities</tt>, <tt>TileEntities</tt> and <tt>TileTicks</tt>. Each
of them could be modified at the same time. When the callback is triggered, it needs to be informed
about which list to rebuild.

<p>The rationale behind this approach is that when you create a new entity, block with a tile entity or
tile ticks, you'll have to allocate some memory and store them in some kind of list. Therefore, you'll
already have all items of a list somewhere, you just have to format them a bit before saving them on disk.

<p>To do this, you first have to mark a particular NBT tag in the file as being modified, using the
following function:
<pre><t>void</t>  <b>NBT_MarkForUpdate</b>(NBTFile, <t>int</t> offset, <t>int</t> tag);</pre>

<p>Only the first 8bits of <tt>tag</tt> will be taken into account. That means at most 8 different lists
can be modified at once in a NBT stream. It is highly likely that you <b>cannot</b> use an enumeration
value, and have to use a bitfield flag. The reason for this, is to handle the special case where the
<tt>TAG_List_Compound</tt> itself is missing from the stream. In that case, you'll have to mark the
parent node as modified. If all the lists reside in the same parent, you'll have to use a bitfield.

<p>Then you can provide a callback when it is time to save the NBT stream, using one of this 2 functions:

<pre>DATA8 <b>NBT_Compress</b>(NBTFile, <t>int</t> * size, <t>int</t> page, NBT_WriteCb_t cb, <t>void</t> * cbparam);
<t>int</t>   <b>NBT_Save</b>(NBTFile, <t>STRPTR</t> path, NBT_WriteCb_t cb, <t>void</t> * cbparam);</pre>

<p>The first function stores the stream in memory, the second one stores it directly on disk. The
interesting part will happen in the callback <tt>cb</tt>. It must have the following prototype:
<pre><t>int</t> write_callback(<t>int</t> tag, <t>void</t> * cbparams, NBTFile nbt);</pre>

<p>If an NBT tag is mark for modification, your callback will be first called with the <tt>nbt</tt>
param set to <tt class="o">NULL</tt>. The expected return value is the number of items your
<tt>TAG_List_Compound</tt> will contain.

<p>Then your callback will be called again with a valid <tt>nbt</tt> parameter. You'll have to fill
the <tt>mem</tt> member of that struct so that it contains a valid NBT fragment. <b>No memory will
be initially allocated</b>. The rationale for this, is that you'll have to allocate an NBT fragment
anyway when the object (Entity, TileEntity) is created. Therefore, you just have to assign the <tt>mem</tt>
field to that fragment. You can also create the fragment on the fly (like it is done for <tt>TileTicks</tt>
is this engine): in that case it is perfectly acceptable to use a static table for this.

<p>The return value should be <tt class="o">1</tt> is a fragment has been assigned to <tt>nbt-&gt;mem</tt>,
or <tt class="o">0</tt> if the previous call was the last one. Providing less compounds than what was
returned initially by the callback will cause problems when reading the file back.


<h3 id="NBTfunc"><span>NBT function overview</span></h3>

<p>This part will show a quick overview of what each function does.

<h4 id="NBTread">Reading files</h4>

<pre><t>int</t> <b>NBT_Parse</b>(NBTFile file, <t>STRPTR</t> path);
<t>int</t> <b>NBT_ParseIO</b>(NBTFile file, <t>FILE</t> *, <t>int</t> offset);
<t>int</t> <b>NBT_ParseZlib</b>(NBTFile file, DATA8 stream, <t>int</t> bytes);
</pre>

<p>These functions will read various type of files:
<ul>
  <li><tt>NBT_Parse</tt>: try to read a gzip-compressed or plain uncompressed file.
  <li><tt>NBT_ParseIO</tt>: parse a portion of file at given offset: typically to uncompress chunk within region file.
  <li><tt>NBT_ParseZlib</tt>: read a zlib-compressed file (not used by <prod>Minecraft</prod> though).
</ul>

<p>The return value for all these function will be <v>1</v> if the file was sucessfully read, <v>0</v>
if something went wrong.

<p>The <tt>file</tt> parameter will also be ovewritten to contain the content of the
decoded NBT stream. the stream will be malloc()'ed and will have to be free()'ed by the caller at
some point when not needed anymore.



<h4 id="NBTfind">Locate tags</h4>

<p>One you have an NBT file decoded, you can start looking at what's inside using these functions:

<pre><t>int</t> <b>NBT_FindNode</b>(NBTFile file, <t>int</t> offset, <t>STRPTR</t> name);
<t>int</t> <b>NBT_FindNodeFromStream</b>(DATA8 nbt, <t>int</t> offset, <t>STRPTR</t> name);
</pre>

<p>Use these functions to find a particular tag within the file. The tag will be searced using a breadth-first
search, scanning recursively the structure of the NBT file until something is found.

<p><tt>offset</tt> is the byte offset where the search should start. <v>0</v> is the beginning of the
file. If a negative number is given, the search will be aborted and <v>-1</v> returned.

<p>The <tt>name</tt> parameter can actually be a bit more than just a tag name, it can be a path,
where tags to search are separated by colon, for example:
<pre><t>int</t> offset = NBT_FindNode(&amp;levelDat, <v>"Player.EnderItems"</v>);</pre>
<p>will first search for a tag "Player", then if it has been found and is a <tt>TAG_Compound</tt> or
<tt>TAG_List_Compound</tt>, will search for a tag "EnderItems" in this branch only.

<p>The return value is the index where the tag was located. This index will be required by almost all
NBT function. <v>-1</v> will be returned if nothing was found.




<h4 id="NBTiter">Iterating properties</h4>

<p>When you know you have a <tt>TAG_Compound</tt>, you might want to iterate over all of its properties.
Here are the following functions for this:
<pre><t>void</t>  NBT_InitIter(NBTFile, <t>int</t> offset, NBTIter);
<t>void</t>  NBT_IterCompound(NBTIter, DATA8 mem);
<t>int</t>   NBT_Iter(NBTIter iter);</pre>

<p>To iterate over properties, you first need to initialize an iterator: <tt>NBTIter_t</tt>. There are
2 ways to do so: either you have an NBTFile_t or simply a raw pointer.

<p>Then, you need to repeatedly call <tt>NBT_Iter</tt> this way:
<pre>
NBTIter_t iter;
<t>int</t> offset;

NBT_InitIter(&amp;nbt, NBT_FindNode(&amp;nbt, <v>"..."</v>), &amp;iter);
<span class="k">while</span> ((i = NBT_Iter(&amp;iter)) &gt;= <v>0</v>)
{
	<span class="c">/* iter.name will contain the name of the current tag, &lt;i&gt; is the offset of the tag */</span>
	...
}</pre>

<p>If the tag was a <tt>TAG_Compound</tt>, the iterator will iterate over all of its immediate
properties: if there is a nested compound, its content will be skipped. You'll have to initialize
another iterator by yourself. If the tag was a <tt>TAG_List_Compound</tt>, the iterator will give the
starting offset of each compound in the list. You'll have to initialize another iterator to scan the
properties of each compound.



<h4 id="NBTreadtag">Reading tag value</h4>

<p>These functions can format values to a certain type, even if the NBT type is entirely different:

<pre><t>Bool</t> NBT_GetFloat(NBTFile, <t>int</t> offset, <t>float</t> * array, <t>int</t> nb);</pre>

<p>Try to read <tt>n</tt> floating point values from tag. If tag is an integer, it will be converted
to float. If it is a string, the function <tt>strtod</tt> will be applied on it. If the tag is not a
scalar (ie: compound or list), <tt class="o">False</tt> will be returned. If the tag have less items
than requested, the function will also fail.

<pre><t>Bool</t> NBT_GetString(NBTFile root, <t>int</t> offset, <t>STRPTR</t> buffer, <t>int</t> max);
<t>int</t>  NBT_GetInt(NBTFile, <t>int</t> offset, <t>int</t> def);</pre>

<p>Convert tag to string or integer. The tag needs to be a scalar for this to work.

<h4 id="NBTchgtag">Setting tag value</h4>

<pre>
<t>Bool</t> NBT_SetFloat(NBTFile, <t>int</t> offset, <t>float</t> * array, <t>int</t> nb);
<t>Bool</t> NBT_SetInt(NBTFile, <t>int</t> offset, <t>int64_t</t> val);</pre>

<p>Similar to <tt>NBT_Get*</tt>, these function will modify the tag value, <b>keeping the original tag
type</b>. These functions <b>will not</b> change the tag of the NBT stream.

<h4 id="NBTcreate">Creating / modifying nbt</h4>

<p>These function can be used to <b>create NBT fragment and/or modify existing NBT file</b> (the changes will
only be done in memory). The modifications are potentially expensive, since bytes will have to be
relocated if a tag is inserted/modified/deleted in the middle of the stream, plus some metadata will
have to be updated. But if performance is not that critical, using this functions is perfectly fine.

<p>For extensive modification of <tt>TAG_List_Compound</tt>, you should check the <a href="#NBTpost">NBT
post processing</a> section: this mechanism is designed to handle arbitrary modifications to a
<tt>TAG_List_Compound</tt> quite efficiently.

<pre>
<t>Bool</t>  NBT_Add(NBTFile nbt, ...);
<t>Bool</t>  NBT_Delete(NBTFile nbt, <t>int</t> offset, <t>int</t> nth);
<t>int</t>   NBT_Insert(NBTFile, <t>STRPTR</t> loc, <t>int</t> type, NBTFile fragment);
<t>int</t>   NBT_AddOrUpdateKey(NBTFile, <t>STRPTR</t> key, <t>int</t> type, <t>void</t> * value, <t>int</t> offsetTagList);
<t>DATA8</t> NBT_Copy(<t>DATA8</t> mem);</pre>

<h4 id="NBTother">Others</h4>

<pre>
<t>int</t>    NBT_Size(DATA8 fragment);
<t>void</t> * NBT_Payload(NBTFile, <t>int</t> offset);
<t>void</t> * NBT_ArrayStart(NBTFile root, int offset, int * size);
<t>void</t> * NBT_PayloadFromStream(DATA8 stream, <t>int</t> offset, <t>STRPTR</t> name);
</pre>






<h2 id="opengl">Advanced OpenGL</h2>

<p>This section will explain some aspects of rendering pipeline.

<h3 id="translucency"><span>Handling translucent blocks</span></h3>

<p>That part was probably one of the biggest <b>crap shoot to implement</b>. 2 attempts were tried
(depth peeling and fragment sorting on the GPU), but ultimately were entirely discarded because of
serious shortcomings in the way they inherently work. Therefore the first 2 sections are a reminder
to not waste your time with these techniques.

<h4 id="oit"><span>Fragment sorting on GPU (Order Independent Transparency)</span></h4>

<p>In the OpenGL red book ninth edition, there is a fully working example for handling alpha transparency
in a <b>completely generic and 100% accurate way</b>, for any type of geometry, entirely on the GPU. The
implementation seemed elegant, not very intrusive, therefore rather easy to integrate, and indeed handle
absolutely all use cases.

<p>The basic idea with this technique is this:

<blockquote>
<p>Instead of writing translucent fragment directly in the main framebuffer, within the fragment shader,
you write them in a (very big) linked list. Thanks to OpenGLv4 atomic types and counters, this can be
achieved rather easily.

<p>The linked list is implemented using 2 textures: one texture the size of the framebuffer, where each
pixel will actually store the head of the linked list as a 32bit integer. The second texture will contain
the fragments (unsorted). For each element in this texture, we need: the RGBA color (32bit int),
the depth value (32bit float) and the next fragment in the list (32bit int), therefore 12 bytes per
translucent fragment.

<p>Once all fragments has been written in that list, you start a second pass to write them in the
framebuffer, by using the head texture to get all translucent fragment at given position, sort them
by decreasing depth, combining them using pre-multiplied alpha and finally writing the result into
the framebuffer (ie: returning the final color from the fragment shader).
</blockquote>

<p>That technique works indeed fine, except for a few use cases where <b>performance can suffer
massively</b>: a simple way to push this technique to its limit, is simply to have 2 quads, one
behind the other, very close to the camera. In that case, this is what will happen (supposing a
framebuffer of <tt>1920x1080px</tt>):
<ul>
  <li>Each pixel of the framebuffer will have to write 2 fragments in the linked list.
  <li><tt>2</tt> fragments times <tt>1920px</tt> times <tt>1080px</tt> times <tt>16</tt> bytes (12 bytes
  per fragment + 4 bytes for head of linked list) times <tt>60</tt> (frame per second) = a little bit
  under 4 Gb / second. That is going to saturate the memory bandwidth of all but high-end configuration.
  <li>To add insult to injury, if you were to sort those quads using the CPU, it would be just a few
  hundreds <b>of bytes</b> to move around each second.
</ul>

<p>In conclusion: <b>for a voxel engine, it is not advised to rely on this technique alone</b>.

<h4 id="depthpeel"><span>Depth peeling</span></h4>

<p>This is another technique to handle alpha transparency in a <b>completely generic</b> way, with 100%
accuracy, and <em>mostly</em> handled by the GPU. The idea behind this technique is as follows:

<blockquote>
<p>Once again instead of writing the fragments directly in the main framebuffer, you write them into
another one (that has one color and <b>two</b> depth buffers). Obviously on that framebuffer, you will
have to manage both depth buffers on your own. The first depth buffer needs to be initialized to the min
value, and the second to the max value.

<p>On the CPU side, you start a loop with the number of "peel" of transparency you want to uncover.
There is a technique to get the exact number of loop, but as a starting point use an arbitrary number,
like 2 or 3.

<p>In the fragment shader handling translucent triangles, you overwrite the color only if the depth of the
fragment is higher than the value currently stored in the first depth buffer (ie: farther) and lower
than the second one (ie: nearer). If the fragment passes both tests, update the <b>first</b> depth buffer
to the depth of the fragment. If outside of that range, discard the fragment.

<p>Doing so, you just extracted the first layer of the farthest translucent fragments. You can now merge
the color buffer with the main framebuffer, using a trivial shader and a quad covering the entire screen.

<p>You might think that the first depth buffer could be managed by OpenGL using a depth test set to
<tt>GL_GREATER</tt>, but we will need the result of that test later.

<p>Next step is to swap the first and second depth buffer, initialize the (new) first depth buffer to
the min value, clear the color buffer and continue with the next iteration of the loop.

<p>On the second iteration, you'll have extracted the second farthest layer of translucent fragments.
</blockquote>

<p>The <b>main problem with this approach</b> is getting the exact number of loops required to draw all the
transparent fragments: if you do too little, some geometry will be missing and if you do too many loops,
you are going to waste time doing completely unnecessary work. But, due to the asynchronous nature of
GPUs, this value is not that trivial to get without stalling the pipeline.

<p>One way to do this, is to use a generic buffer accessed through an atomic operator, like <tt>atomicOr()</tt>,
to be called whenever at least one fragment is <b>discarded</b> due to the being replaced by a farther
fragment, that is testing against the first depth buffer. If the fragment is discarded when tested against
the second depth buffer, that means this fragment has already been processed, and therefore should not
update the flag buffer. If at the end of a loop this buffer contains a non-zero value, it means there
are fragments that still need processing.

<p>Sadly, once your loop is done, you cannot read the content of the buffer, to know if you should continue
or stop. Due to the asynchronous nature of OpenGL, the only moment where it is safe to do so, is when
swapping the back/front framebuffer (ie: <tt>SDL_GL_SwapBuffers()</tt>). At this point you know that, the GPU
is done with the previous frame, and the content of the buffer is accurate now.

<p>Worse: if there was not enough loops, at this point you can only increase the number of loops by one.
If your scene just switched from one layer of transparency to one containing a lot, even at 60 frames per
second, you'll be able to see the translucent layers being peeled frame per frame, as the number of loops
is increased one by one. This is going to be particularly jarring to see because layers are extracted
from <B>back to front</b>.

<p>This is far from ideal in practice, and this technique has somewhat the same problem than the linked
list of fragments: it requires too much bandwidth and/or up to date OpenGL implementation, which makes it
particularly annoying to debug when something goes wrong (usually due to buggy driver).


<h4 id="cpusort"><span>Triangles sorting on CPU</span></h4>

<p>The technique that is ultimately used in this engine is simply <b>sorting the triangles from farthest
to nearest</b>. As with the previous 2 techniques, it has its own shortcomings: it is not 100% accurate
(typical use case where it fails: 2 intersecting triangles/quads), and since the sorting is done on
the CPU, it is going to lag the rendering whenever there are too many triangles to sort.

<p>It has its advantages though:
<ul>
  <li>It is very straightforward to implement and <b>debug</b> (well, compared to hardware accelerated sorting).
  <li>A voxel engine has a lot of tricks you can use to considerably reduce the amount of sorting needed.
</ul>

<p>In this engine, the sorting is actually <b>divided in 2 parts</b>. All sorting algorithms
have to assume that one of the operations necessary to sort items is going to be cheap: either comparison
or moving memory (ideally both). In this case, neither of them are particularly cheap if we were to use
the vertex data as direct source. That's why we create a first array which is both cheap to move its
individual items around (just 8 bytes per item) and to compare those items (subtract two 32bit integers).

<p>Once this array has been sorted, we use it to move vertex data. Thanks to the information stored
in that secondary array, each quads from the vertex array has to be moved at most 2 times (and most of
the time, data will be copied from one place of the array to another, ie: using one <tt>memcpy</tt>).

<p>Triangles are sorted by whole quads (ie: 6 vertices at a time, ie: 2 triangles), because the meshing
phase actually only generates quads. The distance used to sort triangles is actually the distance from
the camera <b>to the center of the whole quad</b>, that distance being converted to fixed point.

<p>The sorting itself is handled by the good old libc <tt>qsort()</tt>.

<p>To reduce the amount of sorting needed, a few tricks are used:
<ul>
  <li><b>Chunks are sorted by the frustum culling</b>: the frustum culling function already builds a list
  of chunk that are roughly sorted from front to back. It is not perfect, but as far as alpha transparency
  is concerned, it is good enough. Which means:

  <li><b>Vertex sorted per chunk</b>: we only have to sort the alpha triangles on a per chunk basis. Which
  means all the chunks hidden by frustum/caves don't have to be processed whatsoever. Also since vertex data
  is already stored per chunk, usually in non-contiguous memory segment, it would have been a <b>major
  inconvenience</b> to have to sort them globally.

  <li><b>Viewing angles threshold</b>: the list of visible chunks can change every time the model-view
  matrix is changed (which is to say quite often). Still, it is not required to sort the triangles
  every time the yaw/pitch/position are changed.

  <p>For the yaw/pitch, their values are stored in a chunk at the time of sorting. If these values change
  later, the sorting will be redone only if one of angles differ for more than 45&deg;.

  <p>The position is only taken in account for the chunk the player currently is. Consider the following
  situation:
  <div class="image">
    <img src="images/sortedalpha.png">
  </div>
  <p>The plus sign marks the player position: the <b>yellow block is the closest</b> (therefore drawn
  last), while the <b>purple and green are farther</b> (therefore drawn first). If the player were to
  move in the direction pointed by the arrow, at some point, the yellow block will become farther than
  the purple, therefore the draw order needs to be changed. That's why the current chunk is reordered
  whenever the player position changes.

  <li>Last, but not least, there are use cases where <b>sorting is completely unnecessary</b>. If you
  can somewhat prove that the alpha triangles <b>cannot overlap each other</b>, then you can draw them
  in any order you want. This is particularly the case for ocean surface: a simple flat plane of alpha
  triangles. Sorting them is a total waste of CPU time, and indeed if you were to sort them anyway,
  you'd get some noticeable lag spike once the angle threashold is reached. In the middle of an ocean,
  with a 16 chunk render distance, there can be more than a hundred of these to sort, and it is completely
  unnecessary.

  <p>The <b>heuristic</b> that has been implemented in this engine, is to check if the entirety of the alpha
  triangles in a sub-chunk lies in a particular axis-aligned plane. If so, the chunk is marked as not
  requiring any sorting to be made (but it still has to be rendered at the same time as other translucent
  chunks).

  <p>Again, when you are surrounded by large bodies of water, <b>this trick helps a lot</b>.
</ul>

<h3 id="gpubanks"><span>Managing chunks on the GPU</span></h3>

<p>Chunks are rendered using instance rendering, which helps reduce the overhead of OpenGL draw calls,
at the price of a bit more work on the CPU side in order for the GPU to do its work.

<p>In a nutshell, chunks are stored in banks, which are pretty big memory segments (or vertex buffer
objects) stored on the GPU (as of writing this, there are 20Mb in size). These segments are then managed
using a custom allocator, where the meta-data used to track free/used memory is of course stored on
the CPU.

<h4 id="vtxbuffers">Vertex buffers</h4>

<p>The code is located in <tt>render.c:renderStoreArrays()</tt> and <tt>render.c:renderFreeArray()</tt>,
and their sole purpose is to behave like a custom <tt>malloc()</tt> and <tt>free()</tt>. The only
difference is that the actual memory is owned by the GPU.

<p>To achieve this, there are 2 main datatypes:
<ul>
  <li><tt>GPUBank</tt>: this is the datatype used to manage an entire segment. Segments cannot be
  reallocated (or at least, it is not advised to do it), therefore to allocate more memory, we'll have
  to create more of these segments. OpenGL draw commands can only deal with one primary segment (or
  VBO) at a time (VAO can deal with multiple VBO source, but they are processed in parallel, here
  we would need a serial access). Therefore to draw the geometry of a scene, we'll need at least as
  many draw commands as there are <tt>GPUBank</tt> involved in that scene (in practice, there will a
  lot more draw calls than just the terrain data).

  <li><tt>GPUMem</tt>: this datatype will track one allocation in a bank: the entire mesh of chunk
  will be stored here. That includes opaque and translucent triangles. The memory segment will be
  divided in 2: opaque triangles are stored at the start, followed by the translucent ones. This
  information is actually stored at the <tt>ChunkData</tt> level (<tt>glSize</tt>: total size in
  bytes of vertex data, <tt>glAlpha</tt>: size of alpha triangles in bytes, located at the end):
  the reason is because that information is needed in a few places, and the GPU datatypes are
  private to the render module.
</ul>

<p>Frustum culling will give us a list of <tt>ChunkData</tt> to render. The only thing to do is to
"sort" them by <tt>GPUBank</tt> and fill-in the <tt>glMultiDrawArraysIndirect()</tt> data structures.
There are 2: one for the indirect command (16 bytes per chunk) and one for model data (12 bytes per
chunk, ie: 3 floats). This VBO model is part of the VAO of the <tt>GPUBank</tt>, but has a <tt>glVertexAttribDivisor()</tt>
set to 1 (ie: only grab one vertex data per instance). It simply contains the position to offset all
the triangles of that <tt>ChunkData</tt>.

<p>There is one particular parameter that is critical to track though: it is the number of commands
that will be issued in a single <tt>glMultiDrawArraysIndirect()</tt> call (<tt>vtxSize</tt>). Keep in
mind that opaque and translucent meshes will be stored in the same buffer commands: therefore if a
chunk has both an opaque and an alpha mesh, that number will be increased by 2.

<p>Knowing the total number of draw commands is critical in setting up the <tt>glMultiDrawArraysIndirect()</tt>
command buffer, particularly the <tt>baseInstance</tt> field. Translucent chunk commands need to be
filled from end to start in this buffer (because frustum culling sort them from front to back). If that
<tt>vtxSize</tt> is incorrect, <tt>baseInstance</tt> will be off, and translucent fragment will not
appear where they should.

<p>The geometry shader has a few more tricks:
<ul>
  <li>Terrain is obviously rendered with back face culling activated. Except that some quads need to be
  always rendered as front face, no matter what the vertex orientation tells. A first version of this
  engine generated 2 quads for these: one for the back face and one for the front face. But the geometry
  shader can trivially reorder the vertex to be always front facing.

  <li>The geometry shader also allows finer control over how ambient occlusion is applied (compared to
  just doing a per vertex shading).
</ul>

<h4 id="vtxdata">Vertex data</h4>

<p>This section will describe how vertex data are stored on the GPU. Being the central piece of any
voxel engine, this part had a decent amount of thoughts put into it (and quite a few refactoring).

<p>Terrain meshes <b>only need quads to be rendered</b> (not necessarily axis aligned), and since there
are a lot of them you might want to store them efficiently: a typical <prod>Minecraft</prod> world with
16 chunks loaded surrounding the player (that is an area of 32x32 chunks) usually contains around 2,000,000
quads (not all of them will be rendered at once), or 8M vertices (12M using newer OpenGL API, because
<tt>GL_QUAD</tt> was deprecated).

<p>If you were to store the vertex data (coordinates, texture UV and some meta data) as floats, that
would required about 400 Mb of data. While even a GPU from 2010 can easily handle this kind of load,
reducing the amount of data means we could push the render distance way farther than this.

<p>This engine manage to compress each quad down to 28 bytes (stored as 7 32bit unsigned integer),
that means viewing a world on a far render distance (16 chunks) usually requires about 100Mb of memory
on the GPU side: that's actually not very much. The vertex data is processed as <tt>GL_POINTS</tt>,
and split into <tt>GL_TRIANGLE_STRIP</tt> in a geometry shader.

<p>The format of each quad is as follows (stored in VBO as 7 <tt class="t">uint32_t</tt>):

<bits>
  <brow><hdr>0: </hdr><bitpart class="sz16" bit="32">16: <em>Y1</em></bitpart><bitpart class="sz16" bit="16">16: <em>X1</em></bitpart><bitpart class="sz0" bit="0"><em>&nbsp;</em></bitpart></brow>

  <brow><hdr>1: </hdr><bitpart class="sz2" bit="32"><em>Vhi</em></bitpart><bitpart class="sz14" bit="30">14: <em>DX2</em></bitpart><bitpart class="sz16" bit="16">16: <em>Z1</em></bitpart><bitpart class="sz0" bit="0"><em>&nbsp;</em></bitpart></brow>

  <brow><hdr>2: </hdr><bitpart class="sz4" bit="32">4: <em>ext</em></bitpart><bitpart class="sz14" bit="28">14: <em>DZ2</em></bitpart><bitpart class="sz14" bit="14">14: <em>DY2</em></bitpart><bitpart class="sz0" bit="0"><em>&nbsp;</em></bitpart></brow>

  <brow><hdr>3: </hdr><bitpart class="sz4" bit="32">4:  <em>ext</em></bitpart><bitpart class="sz14" bit="28">14: <em>DY3</em></bitpart><bitpart class="sz14" bit="14">14: <em>DX3</em></bitpart><bitpart class="sz0" bit="0"><em>&nbsp;</em></bitpart></brow>

  <brow><hdr>4: </hdr><bitpart class="sz9" bit="32">9: <em>Vlo</em></bitpart><bitpart class="sz9" bit="23">9: <em>U</em></bitpart><bitpart class="sz14" bit="14">14: <em>DZ3</em></bitpart><bitpart class="sz0" bit="0"><em>&nbsp;</em></bitpart></brow>

  <brow><hdr>5: </hdr><bitpart class="sz8" bit="32">8: <em>Vsz</em></bitpart><bitpart class="sz8" bit="24">8: <em>Usz</em></bitpart><bitpart class="sz1" bit="16"><em>A</em></bitpart><bitpart class="sz1"><em>L</em></bitpart><bitpart class="sz1"><em>D</em></bitpart><bitpart class="sz1"><em>X</em></bitpart><bitpart class="sz3" bit="12">3: <em>N</em></bitpart><bitpart class="sz9" bit="9">9: <em>OCS</em></bitpart><bitpart class="sz0" bit="0"><em>&nbsp;</em></bitpart></brow>

  <brow><hdr>6: </hdr><bitpart class="sz8" bit="32">8: <em>Sky/Block</em></bitpart><bitpart class="sz8" bit="24">8: <em>Sky/Block</em></bitpart><bitpart class="sz8" bit="16">8: <em>Sky/Block</em></bitpart><bitpart class="sz8" bit="8">8: <em>Sky/Block</em></bitpart><bitpart class="sz0" bit="0"><em>&nbsp;</em></bitpart></brow>
</bits>

<p>Each field has the following meaning:

<ul>
  <li><tt>X<sub>i</sub></tt>, <tt>Y<sub>i</sub></tt>, <tt>Z<sub>i</sub></tt>: to represent a <tt>QUAD</tt>, you need
  at least 3 coordinates. <tt>QUAD</tt> are not necessarily axis aligned, otherwise you could get away
  with only 2 points.
  <p>The coordinates are encoded as a fixed point number on 16bits. Because some models slightly exceed
  their voxel space, and as such can also exceed a chunk bounding box (like torches attached to wall).
  Therefore, the minimum range of coordinates should be between -0.5 and 16.5, but to make computation
  easier, the range of values is between -8 and 24.

  <p>Each voxel cube is therefore divided in 65536 / 32 = 2048 parts, which is largely enough
  to accomodate all the models that are not a full block from <prod>Minecraft</prod> 1.12. To convert
  from fixed to floating point, the formula is: <pre>vec3 position = (fixed - 16384) * (1 / 2048.)</pre>

  <p>Sadly, there is not enough space to store the 3 needed coordinates as 16bits fixed point. That's
  why the 2<sup>nd</sup> and 3<sup>rd</sup> points are stored as relative to the first vertex. Since
  models (for terrain) should never exceed a voxel unit, you know that each coordinates are at most at
  +/- 2048 units apart on each axis, which is 12 bits (including sign). We add 2 more bits of precision
  for a bit of safety, and that's why the last 2 points uses 14bits of precision per axis.

  <li><tt>U</tt>, <tt>V</tt>: coordinates of the <b>top left corner</b> of the texture to use for this <tt>QUAD</tt>
  (vertex V2, see below). <tt>V</tt> coordinate is split into 2 because there wasn't enough space left on
  the 4<sup>th</sup> word.

  <li><tt>Usz</tt>, <tt>Vsz</tt>: 2nd coordinate. These numbers are relative to <tt>U</tt> and <tt>V</tt>
  respectively, minus 128. This correspond to the texture coordinate for vertex V3 (see below). ie:
  <pre>vec2 texV3 = vec2(U + Usz - 128, V + Vsz - 128);</pre>

  <li><tt>X</tt>: knowing the texture coordinate of 2 vertices is not enough to fully find all the
  coordinates of the 2 remaining vertices. At this point there are 2 possibilities: keep U or V coordinate
  for V2 and V1. This is the purpose of this bit: if set to one, keep X for V1.

  <li><tt>D</tt>: dual-sided quad: this quad must not be culled by the back-face culling test of OpenGL.
  Vertex data will be rearranged in the geometry shader to make the test pass, without the need of
  extra vertices.

  <li><tt>L</tt>: not-so-pretty hack for very crude handling of liquid. XXX needs to be removed.

  <li><tt>A</tt>: texture will be animated (lava/water animation).

  <li><tt>OCS</tt>: ambient occlusion value for 4 vertices, each value being encoded on 2bits.

  <li><tt>ext</tt>: 8bits of extra data split into 2 due to lack of space (it was added very late).
  This and the <tt>OCS</tt> fields are way too complicated to be explained here. They will be described
  in the mesh generation chapter.

  <li><tt>N</tt>: normal of the face, encoded as <tt>0</tt>: south, <tt>1</tt>: east, <tt>2</tt>: north,
  <tt>3</tt>: west, <tt>4</tt>:top, <tt>5</tt>: bottom, <tt>6</tt>: recompute from vertices. The vast
  majority of quads are axis-aligned, and therefore unnecessary to recompute the normal. Those that are
  not will have their normal recomputed and shading per face adjusted accordingly.

  <li><tt>Sky</tt> / <tt>Block</tt>: a direct dump of the NBT tables <tt>Skylight</tt> and <tt>BlockLight</tt>.
  Obviously used for lighting purpose: 1 value per vertex, same order as OCS/texure U, V.
</ul>

<p>In the geometry shader, this is the information that will be sent to the fragment shader:
<div class="photo">
  <img src="images/quad.png">
</div>

<p>Two triangles will be constructed out of the 4 vertices: V1 - V2 - V3 and V3 - V2 - V4. Then,
each face will be decomposed like this:

<div class="photo" id="quadface">
  <img src="images/quad_face.png">
</div>

<p>This shows how each face is constructed from the cube vertices. <b>The arrow inside</b> the face
shows how the OCS/Sky/Block values are extracted: from least significant bits to most significant,
with start of arrow = first item, arrow end = last item, 4 values in total. <b>The axis</b> shows
where the 0, 0, 0 coordinates are (if the cube were to be rendered at 0, 0, 0) and where they
increase with positive values.

<hr>

<p id="vtx10bytes">However, this vertex format is <b>not easy to work with</b>: it involves a lot of tedious bit shifting
and code logic to extract all the information about a quad. The mesh of objects have to be analyzed for
generating bounding box and face visibility for example. That's why this engine uses another <b>vertex data</b>
format. It is actually used by everything, but terrain information: custom block models, inventory models,
entities models, bounding boxes, ...

<bits>
  <brow><hdr>0: </hdr><bitpart class="sz16" bit="16">16: <em>X</em></bitpart><bitpart class="sz0" bit="0"><em>&nbsp;</em></bitpart></brow>
  <brow><hdr>1: </hdr><bitpart class="sz16" bit="16">16: <em>Y</em></bitpart><bitpart class="sz0" bit="0"><em>&nbsp;</em></bitpart></brow>
  <brow><hdr>2: </hdr><bitpart class="sz16" bit="16">16: <em>Z</em></bitpart><bitpart class="sz0" bit="0"><em>&nbsp;</em></bitpart></brow>
  <brow><hdr>3: </hdr><bitpart class="sz7" bit="16">7: <em>Vhi</em></bitpart><bitpart class="sz9" bit="9">9: <em>U</em></bitpart><bitpart class="sz0" bit="0"><em>&nbsp;</em></bitpart></brow>
  <brow><hdr>4: </hdr><bitpart class="sz8" bit="16">8: <em>Sky/Block</em></bitpart><bitpart class="sz2" bit="8"><em><small>ocs</small></em></bitpart><bitpart class="sz3" bit="6">3: <em>N</em></bitpart><bitpart class="sz3" bit="3"><em>Vlo</em></bitpart><bitpart class="sz0" bit="0"><em>&nbsp;</em></bitpart></brow>
</bits>

<p>Although this is only 10 bytes (5 <tt class="t">uint16_t</tt>), this only encodes a single vertex.
You need 6 of these to form a quad, that is 60 bytes per <tt>GL_QUAD</tt>. At some point in time, the
terrain data was also based on this vertex data. Given how tedious it was to adapt all the rendering
code to the 28 bytes per quad version, it was decided to keep the compressed data for terrain only.

<h2 id="mesh">Mesh generation</h2>

<p>Welcome to <b>look-up table hell</b>.

<p>This engine supports 3 major types of voxel elements that can be converted into meshes. Each <b>have
their pros and cons</b>:

<ol>
  <li><tt>SOLID</tt>: these are the <b>bread and butter of a voxel engine</b>: a block that occupies the full
  space of a voxel. It can have arbitrary textures on all 6 sides, hidden faces can be culled easily and
  efficiently, and have a precise lighting model (including skylight, blocklight and ambient occlusion).

  <p>The <b>native "resolution"</b> of this engine is actually "half" a voxel: i.e.: a full voxel that
  has been split in half on the X, Y and Z axis. Which means a full voxel is made of 8 sub-voxels
  (i.e: you can, for example, render all kind of slabs with this: vertical, horizontal, 2x1, ...).

  <p>A typical map is usually composed of 80% of these blocks, therefore they require quite a bit of
  work (thus, will need <b>a lot</b> of look-up tables).

  <li><tt>CUST</tt>: voxels that can have an <b>arbirary shape</b> and have a much greater precision than half-blocks.
  The major drawback with these is that their <b>lighting model is greatly simplified</b>: for example, they
  don't generate any ambient occlusion. Also the same skylight and blocklight is applied to the entire
  model: if you were to generate a floor out of these with a block light nearby, you would be able to
  see that the transition between light values is not smooth at all (and have that <prod>Minecraft</prod>
  alpha feels).

  <p>Hidden face culling is still performed aggressively on these: a full voxel model will therefore
  be culled the same way as a <tt>SOLID</tt> block.

  <p>This type includes blocks like fences, glass panes, pistons, torches, chests, doors, ...
  
  <p>Note: this type of blocks also includes what is known as "chiseled" blocks: slab and detailed blocks
  (X, Y, Z split by 8).

  <li><tt>QUAD</tt>: this is a <b>very simple voxel to process</b>: only a handful of combination exists
  and all of them are trivial to process compared to the previous two. The typical use case for these
  are flowers, crops, grass, rails...

  <p>Like <tt>CUST</tt>, they use a simplified lighting model: single skylight/blocklight value for
  the entire model, and no ambient occlusion. Technically, they could be handled as <tt>CUST</tt>, but
  specifying a custom model each time they are needed is way too tedious.
</ol>

<p>Note: keep in mind that all blocks must be aligned inside the voxel grid. Technically, it is possible
to generate triangles at arbirary position, but the voxel manipulation functions won't be able to handle
it. To place a model at a truly arbitrary position, you need to use entities: this will be covered in the
next section (and have their own pros and cons).

<h3 id="meshsolid"><span>SOLID voxel</span></h3>

<p>These blocks requires quite a bit of work to be converted into meshes. First, keep
<a href="#quadface">this picture</a> in mind, its information will be used <b>extensively</b>
in the entire meshing phase.

<h4 id="vtxtex"><span>Vertex and texture coordinates</span></h4>

<p>Converting a full solid voxel into a pseudo quad (technically a <tt>GL_POINT</tt>, that will be transformed
into 2 triangles in the geometry shader to a form a <tt>GL_QUAD</tt>), you need just a couple of look-up tables:

<pre style="font-size: 0.8em"><t>uint8_t</t> vertex[<v>3</v>*<v>8</v>] = { <span class="c">/* 8 vertices of a 1x1x1 cube */</span>
    <v>0</v>,<v>0</v>,<v>1</v>,  <v>1</v>,<v>0</v>,<v>1</v>,  <v>1</v>,<v>1</v>,<v>1</v>,  <v>0</v>,<v>1</v>,<v>1</v>,
    <v>0</v>,<v>0</v>,<v>0</v>,  <v>1</v>,<v>0</v>,<v>0</v>,  <v>1</v>,<v>1</v>,<v>0</v>,  <v>0</v>,<v>1</v>,<v>0</v>,
};
<t>uint8_t</t> cubeIndices[<v>6</v>*<v>4</v>] = { <span class="c">/* face (quad) of cube: S, E, N, W, T, B */</span>
    <v>9</v>, <v>0</v>, <v>3</v>, <v>6</v>,    <v>6</v>, <v>3</v>, <v>15</v>, <v>18</v>,     <v>18</v>, <v>15</v>, <v>12</v>, <v>21</v>,     <v>21</v>, <v>12</v>, <v>0</v>, <v>9</v>,    <v>21</v>, <v>9</v>, <v>6</v>, <v>18</v>,      <v>0</v>, <v>12</v>, <v>15</v>, <v>3</v>
<span class="c">/*  3, 0, 1, 2,    2, 1,  5,  6,      6,  5,  4,  7,      7,  4, 0, 3,     7, 3, 2,  6,      0,  4,  5, 1 */</span>
};
<t>uint8_t</t> texCoord[] = { <span class="c">/* tex coord for each face: each line is a rotation, indexed by (Block.rotate&amp;3)*8 */</span>
    <v>0</v>,<v>0</v>,    <v>0</v>,<v>1</v>,    <v>1</v>,<v>1</v>,    <v>1</v>,<v>0</v>,
    <v>0</v>,<v>1</v>,    <v>1</v>,<v>1</v>,    <v>1</v>,<v>0</v>,    <v>0</v>,<v>0</v>,
    <v>1</v>,<v>1</v>,    <v>1</v>,<v>0</v>,    <v>0</v>,<v>0</v>,    <v>0</v>,<v>1</v>,
    <v>1</v>,<v>0</v>,    <v>0</v>,<v>0</v>,    <v>0</v>,<v>1</v>,    <v>1</v>,<v>1</v>,
};
</pre>

<p>It is as simple as it gets: <tt>vertex</tt> refers to the coordinates in world space (if the cube were
to be rendered at 0,0,0) of each corner, then to get the 4 coordinates of a given face <tt>cubeIndices</tt>
are indices within <tt>vertex[]</tt> array. The indices are pre-multiplied by 3, to avoid doing it in
the <b>many places</b> this array is used. The order/orientation is described in <a href="#quadface">this
picture</a>.

<p>In case you are wondering, the vertices and face order have no particular meaning nor does them
enable special tricks. All of this was chosen kind of arbitrarily very early in the development and
turned out to be OK: neither particularly good, nor bad.

<p>Keep in mind that coordinates for the mesh will be relative to the sub-chunk origin (a 16x16x16
chunk of terrain). In the vertex shader, each sub-chunk will receive a <tt>vec3</tt> offset that
will be added to every vertices.

<p><b>The order in which vertices of a face are enumerated</b> has a meaning though: it is done so that
all the remaining information (texture coordinates, lighting, ambient occlusion) can be applied the
same way on all faces.

<p>The <tt>texCoord</tt> array encodes 4 different rotations of a texture:

<div class="image">
  <img src="images/tex-rotate.png">
</div>

<p>Since there are 6 faces and you need 2 bits to encode each rotation, the <tt>BlockState_t.rotate</tt>
field contains 12bits of information. You cannot mirror a texture though, for this you'll need to a <tt>CUST</tt> voxel.

<h4 id="skyblock"><span>Block and sky light</span></h4>

<p>Each of the 24 vertices of a cube can have an independant block and sky light value, so that values
can be smoothly interpolated across a face. Each vertex will depend on 4 sky/block light: the 4 voxels
that share the vertex in the direction of the face normal. This is the purpose of the <tt>skyBlockOffset[]</tt>
table (it contains too many numbers to be displayed here).

<p>Each number in this table refers to a voxel, that is using the same coordinate system than the one
used in the <a jref="#cube3x3">frustum culling</a>:

<p><img src="images/quad_face.png" style="width: 66%; float: right">

<table class="skewed">
<tr><td>18<td>19<td>20
<tr><td>21<td>22<td>23
<tr><td>24<td>25<td>26
</table>

<table class="skewed">
<tr><td>9<td>10<td>11
<tr><td>12<td><v>13</v><td>14
<tr><td>15<td>16<td>17
</table>

<table class="skewed">
<tr><td>0<td>1<td>2
<tr><td>3<td>4<td>5
<tr><td>6<td>7<td>8
</table>

<p>Whenever a <tt>SOLID</tt> block has at least one face visible, we extract the 26 surrounding voxels:
block ID and data value (in the array <tt>blockIds3x3[]</tt>) as well as block light and sky light
(in the array <tt>skyBlock[]</tt>). Each of these two arrays have 27 elements, ordered like in the table
above.

<p><tt>skyBlockOffset[]</tt> then encodes the 4 values we need per vertex: 4 vertex per face, that means
16 values per face, 96 items in total. For block light, we take the maximum among the 4 values, for
skylight we take the minimum if the value is not 0.

<p>For example, the south face has the values <tt class="o">15</tt>, <tt class="o">16</tt>, <tt class="o">24</tt>,
<tt class="o">25</tt> for the first vertex. If you look at the face order schema, the first vertex of
the south face is vertex 3 (arrow inside the square shows the order). There are 8 voxels that share
this vertex, but we only take the 4 that are in the direction of the face's normal (otherwise there
are too many).

<h4 id="cnxtex"><span>Connected textures</span></h4>

<p>Connected texture only applies to full block. More complex models like glass pane uses a different
approach (and will be described in the <tt>CUST</tt> section).

<p>For full blocks, the base model of its texture will be used to generate all the variations. Since
there are 4 sides, it means there are 16 possible combinations. As of writing this, this is done by removing
a one pixel line from a given side. These are generated in <tt>blocks.c:blockPostProcessTexture()</tt>.
This is for example, what it looks like for the glass texture:

<div class="photo">
  <img src="images/cnxtex.png" style="background-color: black; border: 5px solid black; width: 512px">
</div>

<p>To know which texture to use, you just need to set a bitfield if the block on top (bit1), right (bit2),
bottom (bit3) or left (bit4) "connects" with the current voxel. By default, U texture coordinate is
set to 0, therefore, you just have to shift it by <tt>bitfield * 16</tt> to simulate a connection.

<p>Left, right, top and bottom are relative to a face, therefore a new look-up table is needed:
<tt>offsetConnected[]</tt>. It encodes the 4 blocks to look for connection in the <tt>blockIds3x3[]</tt>
table (24 elements in total). Each group of 4 elements is of course ordered top, right, bottom and left.

<h4 id="meshhalf"><span>Half-block</span></h4>

<p>Half-block is actually the native "resolution" of this engine. Seems simple enough and you might wonder
what the big deal with these ? Well, you'll have a glimpse as to why Mojang has not added vertical slab to
<prod>Minecraft</prod> yet (as of writingthis, in august 2021): they introduce <b>a lot</b> of edge cases,
and sadly, it means <b>lots of look-up tables</b>.

<p>The first thing to keep in mind with half-block is, that <prod>MinecrafT</prod> treat them as if they were
a <tt>SOLID</tt> voxel: they completely block sky light and block light no matter what their orientation
is. If you attempt to get block or sky light at their coordinate, you'll get 0.

<p>The way half-blocks are meshed is a bit different from full voxel though. In case it wasn't clear up
until now, the chunk meshing for full voxel does not attempt to merge adjacent quads that share the same
properties (note: it should though).

<p>For half-slab though, the engine tries way harder. This is the gist of the meshing phase: whenever
a sub-face (ie: 0.5 x 0.5 in size) is detected as being visible, we check in the 2 directions perpendicular
to the normal if the size can be extended, and generate a quad of this size instead. This is done in
the function <tt>halfBlockGenMesh()</tt> in <tt>halfBlocks.c</tt>.


<h4 id="ocs"><span>Ambient occlusion</span></h4>

<p>/* ... */

<h3 id="meshcust"><span>CUST voxel</span></h3>

<p>Custom voxels are blocks that cannot be represented as a <tt>SOLID</tt> voxel. They can have an
arbitrary shape, but their lighting is quite simplified compared to <tt>SOLID</tt>. For example they
usually do not generate ambient occlusion, unless one of their face line up with the voxel grid.

<p>Mesh data is stored in memory and read from the main block description table (<tt>blocksTable.js</tt>).
These models use the <a href="#vtx10bytes">10 bytes per voxel</a> vertex data. In the meshing phase
they are converted to 28 bytes per quad. This conversion is pretty straightforward, albeit a bit messy
to look at with all these bit twiddling hacks.

<p>There is one aspect that is not that trivial to handle though: <b>connected models</b>.

<h4 id="cnxmodels"><span>Connected models</span></h4>

<p>Some models <b>can have optional parts</b> that can be removed based on nearby voxels. The overtypical
example being fences:
<div class="image">
  <img src="images/cnxmodels.png">
</div>

<p>Yet, if you look at the model definition for every type of fence, you'll see <b>only one model</b>
being defined for each. The way it is handled is this engine is by tagging each vertex by an integer.
In the model <a href="#vtx10bytes">vertex data</a>, this ID is stored in the sky/block light information,
using 5 bits out of the 8 available (lighting information make no sense at this point, that's why it is
perfectly safe to repurpose those fields). That means each models can have up to <b>32 different connected
parts</b>. As of writing this, the models that have the most parts are glass panes with 18 parts.

<p>In case of fences, they only have 4 different parts: the 4 extensions around the center piece. In the
meshing phase we check for blocks around the custom model if those optional parts can connect to. This
is done in the function <tt>blockGetConnect()</tt>: the return value will be a bitfield of the parts
that should be included in the chunk's mesh.

<p>Then, in the chunk mesh generation, the unused parts are filtered using this simple test:
<pre><span class="k">if</span> (faceId &gt; <v>0</v> &amp;&amp; (connect &amp; (<v>1</v> &lt;&lt; (faceId-<v>1</v>))) == <v>0</v>)
{
	<span class="k">continue</span>;
}
</pre>

<p>Here, <tt>connect</tt> is the bitfield encoding the parts that should be included in the mesh. Since
it is a 32bits integer, that's where the limit of 32 optional parts comes from. An ID of 0 for a face
means that the face will always be included (like the central piece of a fence).


<p>/* ... */

<h2 id="entities">Entities</h2>

<p>Entities in this engine refer to a model that is not aligned to the voxel grid: it can have arbitrary
position and/or rotation, and are not necessarily included in a <tt>ChunkData</tt> (which means that
frustum culling used by terrain <b>cannot</b> be applied to entities).

<p>This part will describe <b>how entities</b> (mobs, block moved by piston, dropped items, paintings, ...)
<b>are managed</b> within this engine. This part is not trivial just by looking at the source code, since
there are a lot of moving parts, with lots of datatypes:

<h3 id="structure"><span>Data structures</span></h3>

<p>There are a lot of datatypes used to manage entities, here a brief overview of the purpose of each one:

<ul>
  <li><tt>struct Entity_t</tt> : represents an entity from within the world, as such, they have
  a NBT record associated.

  <li><tt>struct EntityBuffer_t</tt> : <tt>struct Entity_t</tt> are allocated in batch (<tt>ENTITY_BATCH</tt>
  count, 256 by default). It is easier to handle entities if pointers are not reallocated, so that reference
  can be held within datatypes. Allocating them in batch, will somewhat keep those entities close in memory.

  <li><tt>struct EntityBank_t</tt> : hold model data that will be used to render entities: we'll use
  one model per entity, so that they can be drawed in a single call to <tt>glMultiDrawArraysIndirect()</tt>.

  <p>This API will need a command buffer (vboMDAI) and a per instance vertex data (vboLoc). This list will
  be rebuild with minimal changes whenever a entity is added or removed, which means a few more boilerplate
  tables to track usage (most notable one being <tt>mdaiUsage</tt>).

  <p>Assumption is made that entities around the player is rather low (less than 1000). As such, we
  don't care about frustum culling, we let the vertex shader do the work.

  <p>Once added, an entity model will remain in the VBO (there are no ways to remove models). Models will
  be reused as mush as possible: for example if a stone brick block is used in an item frame, is dropped
  as an item in the world or is pushed by a piston, all at the same time: there will be only one model
  allocated for all of these (but using different per instance information: rotation, scaling, lighting).

  <p>Models will also be rendered on demand: there are way too many to generate them all at startup.

  <p>Banks will hold a fixed number of vertices data: if that buffer is full or close to, a new bank
  will be allocated. The number of objects drawed can be unlimited though: if there are 1000 stone brick
  block dropped as an item around the player, it will use one model in the VBO and 1000 instance with
  different location/lighting.

  <li><tt>struct EntityModel_t</tt> : describe what's in all the VBOs: since VBO are only stream
  of bytes. We also need to know the vertex location, size, and bounding box.

  <li><tt>struct EntityEntry_t</tt> : given an entity, we want to know if its model is already available
  in one bank. Each models id (<tt>VBObank</tt>) are stored in a hash table that can give the model id
  (<tt>VBObank</tt>) given an item ID (<tt>ItemID_t</tt>).
</ul>

<p>The schema below shows how all these datatypes are interconnected. If you ever venture in <tt>entities.c</tt>,
keep that schema on hand, otherwise, you'll get lost:

<div class="photo">
  <img src="images/entities.png" style="width: 100%">
</div>

<p>It is not as complicated as it looks. First some legends:
<ul>
  <li>A <b>closed box</b> represent a fixed chunk of memory.
  <li>An <b>opened box</b> on the left side means that the block can be reallocated if more space is needed.
  That means there should be no pointers that holds a reference within those blocks, because its base
  address can change at any time.
  <li>An <b>arrow</b> means that within the datatype, there is a reference to the pointed datatype.
  Note that this reference is not necessarily a pointer (it is often just an integer, more on this below).
</ul>

<p>The "root" datatype is <tt>EntityPrivate_t</tt> (on the far left): this is a static global variable
that contains all the buffers/linked list for managing entities. Whenever an entity is found in the NBT
of a chunk, it is added to a list (in the first free slot). To avoid doing one allocation per entity,
they are allocated in batch of 256, those batches being stored in a linked list. An <tt>entityId</tt>
is <b>an integer</b> that can uniquely identify one entity: the first 8bits encode the index in the batch,
the remaining is the buffer number (ie: <tt>entityId&gt;&gt;8</tt><sup>th</sup> item in the linked list).


<p>But we don't want to allocate one model (vertex data for the GPU) per entity. In any given world, it
is extremely likely that only a couple of entity models will be used: a few hundreds usually, whereas
the number of entities can be in the thousands.


<p>That's the purpose of the <tt>EntityBank_t</tt> datatype: keep track of where a given model (vertex
data) is and the metadata necessary for each instance (one per entity). One entire bank can then be rendered
using a single OpenGL draw call, using <tt>glMultiDrawArraysIndirect()</tt>.

<p>Banks therefore have to manage 2 groups of arrays: model vertex data (<tt>vboModel</tt> and <tt>models</tt>)
and per instance information (<tt>vboLoc</tt> and <tt>vboMDAI</tt>):
<ul>
  <li><tt>vboModel</tt> is an OpenGL array buffer that can hold at most 64K <a href="#vtx10bytes">vertex</a>
  data (each vertex being 10 bytes). Once it is full, a new bank will be allocated. Also, once a model
  has been added, it cannot be removed.

  <p>To keep track of what's inside this <tt>VBO</tt>, we need a new array: <tt>struct EntityModel_t * models</tt>.
  This array will contain where the model is located in <tt>vboModel</tt> (vertex index and vertex count).
  And while we are here, the model structure will also contain to the model bounding box (derived from
  vertex data). This bounding box assumes that no rotations and no scaling are applied to the model.

  <li><tt>vboLoc</tt> is a per instance array buffer (<tt>glVertexAttribDivisor()</tt> set to 1). There
  is one instance slot per entity. All entities that use a model from the bank will be rendered in the
  same draw call, no matter how many entities references this model.

  <p>Therefore <tt>vboLoc</tt> and <tt>vboMDAI</tt> can be resized at some point.
</ul>

<p>The link between an <tt>Entity_t</tt> and and its model is stored in the <tt>VBObank</tt> field: it
encodes both the bank and the model id within an integer: the first 6bits encodes the bank number, the
remaining encodes the index in the <tt>models</tt> array.

<p>Bounding boxes are stored within the <tt>struct EntityModel_t</tt> datatype. In theory, they can be
extracted from <tt>BlockState_t</tt>, but it is way too much work. Bounding box for entities are always
assumed to be AABB, ie: no rotation taken into account when checking collision (but scaling will be).
Raypicking (ie: pointing an entity with mouse) will take rotation into account though.

<h3 id="collision"><span>Collision detection/correction</span></h3>

<p>Collision detection is implemented using a swept AABB algorithm and correction is done through sliding
adjustment and was strongly inspired by <a href="https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/swept-aabb-collision-detection-and-response-r3084/">this article</a>.

<p>This algorithm works extremely well in all use case, but it has one major limitation: it tends to
break down when bounding box are already intersecting.

<h3 id="partitioning"><span>Space partioning</span></h3>

<p>One aspect related to collision detection, is <b>entities enumeration</b>. Since entities are spread all
over the world and don't rely on the voxel grid, enumerating them without scanning the majority of
them, each time a collision detection need to be performed is somewhat challenging.

<p>Scanning the entire entity list is of course not a viable solution, since entities in a voxel engine
tend to move a lot (that's the main interest of entities: moving freely, unlike voxels). Therefore,
knowing which entities intersect an AABB, will be a very frequent query, and it better be optimized
to not fall into that dreaded O(N<sup>2</sup>) complexity.

<p>The solution used in this engine is to use a dynamic self-balancing quadtree. First, you might wonder
<b>why just a quadtree and not an octree</b>? The main reason for using a quadtree is that entities are
primarily spread on the XZ plane and very little on the Y axis: adding another dimension to the tree
would add very little performance gain, but lots of uneeded complexity and extra memory usage. An
octree would have made more sense it were used for other purposes, like frustum culling or raypicking.

<h4>Block map or quad tree?</h4>

<p>Another question worth answering is: <b>is it cheaper to use a block map instead of a quadtree?</b>

<p>One may be tempted to use the chunk itself as a crude block map for space partioning. In practice, it
is not that good of an idea, since a 16x16 area is quite big, even bigger if you consider that entities are
referenced through their center and therefore can overlap a nearby chunk depending on their size. In
practice, it means you'll have to scan more than one chunk each time you want to do a collision check
on a given entity.

<p>What if we use a finer block map grid? This can be interesting since an entity can be uniquely
identified using a 16bit integer (no need for a full pointer address).

<p>The resolution of the quadtree is "limited" to a 1x1 grid at the finest level (which is quite small
actually). Using a block map of this size is too expensive though: 512 bytes per chunk, which in pratice
would have to be allocated for almost every chunk, since entities are almost everywhere in a typical
<prod>Minecraft</prod> map.

<p>Therefore, there are only 2 choices left: a 2x2 or 4x4 grid (8x8 and 16x16 being too coarse). Which
adds respectively 128 and 32bytes per chunk. On a far render distance (32x32 grid of chunk loaded),
as far as memory usage goes, that would be 128K and 32K of memory needed, which is still far more than
a quadtree need (around 10K), and the quadtree will give you way more precision than a 4x4 grid.

<p>Conclusion: a quadtree is more efficient as far as memory is concerned, but will require a bit more
CPU usage. Just a reminder to not waste any time implementing this.

<h4>Auto-resize quad tree</h4>

<p>The problem with using a quadtree in a voxel world is that its size must <b>accomodate the player
movements</b>. If the player moves a lot in the XZ plane, at some point the quadtree will hold reference
to objects that are completely outside render distance, which is a waste of memory usage and CPU to
reach the leaf nodes of the tree.

<p>The way it is handled in this implementation, is by <b>auto-resizing the quad tree</b>: when adding
an item in the tree, if its initial position is outside of the current bounding box of the quadtree,
as many top layers as necessary will be added, until the object position is included in the bounding
box.

<p>When an object is deleted, this implementation will try extra hard to prune empty branches and/or
relocate leaf node to higher level layers. These operations are not that expensive, otherwise as the
player moves, top layers will kept being added to cover the increasing distance between the spawn area
and the current position. At some point, the tree will have so many layers, that it will be necessary
to perform as many bounding box checks as a 16x16 block map (which is what the quadtree was supposed
to avoid).





<h2 id="emitters">Particle emitters</h2>

<p>Here is the way particle emitters are handled in this engine:

<ol>
  <li>While a chunk is turned into a mesh of quads (<tt>chunkUpdate()</tt> in <tt>chunks.c</tt>),
  each voxel is checked for a type of particle they can emit. If the conditions are met, a list of
  potential emitters is stored at the <tt>ChunkData</tt> level. The emitters are not immediately
  made active, only those close to player position will. This list store emitters as 4 16bit
  integers. They are not accessed through a <tt>struct</tt>, because it involves bitfield and the
  struct is not necessarily aligned (also this "struct" is used in only 3 different functions in the
  entire engine).

  <li><b>Emitters cover an area</b>. A first implementation allocated one emitter per block. In practice,
  this was not a very good idea, because some blocks are very common and can allocate lots of emitters,
  like lava or powered redstone dust. Instead, an emitter cover an XZY area of 16x16x2 (ie: 2 vertical
  layers of a chunk). That means for a particular type of particle emitted, at most 8 emitters will
  be created (for a given chunk).

  <li>When a particle has to be created, the emitter will search through its area where the block
  is or are located. Since the area covers 512 voxels, a 32bit bitfield is used to narrow the search:
  each bit indicate in which Z row to look for a block. That means at most 16 blocks have to scanned
  per row, which is pretty cheap, because it is a contiguous memory buffer.

  <li>The emitter also holds how many blocks there are in the area that can spawn particles. Therefore
  the search will continue until all emitters are found.

  <li>Emitters are grouped by type and interval: since all blocks are scanned at the same time, if
  timing interval is different it has to be done in a different emitter.

</ol>

<p>This schema shows how the information is stored at the <tt>ChunkData</tt> level (in <tt>emitters</tt>
field):
<bits>
  <brow><hdr>0: </hdr><bitpart class="sz8" bit="16">8: <em>count</em></bitpart><bitpart class="sz5" bit="8">5: <em>type</em></bitpart><bitpart class="sz3" bit="3">3: <em>Y</em></bitpart></brow>

  <brow><hdr>1: </hdr><bitpart class="sz16" bit="16">16: <em>interval</em> (ms)</bitpart><bitpart class="sz0" bit="0"><em>&nbsp;</em></bitpart></brow>

  <brow><hdr>2: </hdr><bitpart class="sz16" bit="16">16: <em>area LO</em></bitpart><bitpart class="sz0" bit="0"><em>&nbsp;</em></bitpart></brow>

  <brow><hdr>3: </hdr><bitpart class="sz16" bit="16">16: <em>area HI</em></bitpart><bitpart class="sz0" bit="0"><em>&nbsp;</em></bitpart></brow>
</bits>

<p><b>Note</b>: <tt>count</tt> is only 8bits instead of 9. In practice having more than 256 block
emitters in a 16x16x2 region is extremely rare (lava lakes can easily reach that number though, but
not more than 256). Also note that numbering in this field starts at 0. 0 means there is 1 block that
can emit particles.

<p>Once player location is known, emitters from all 27 <tt>ChunkData</tt> surrounding the player are
made active. As the player moves, this list will be adjusted by removing the emitters that are too far
away, and making active the one that got within 1 chunk distance away from the player. The emitters
that are still within range must not be changed, otherwise their timing will be reset.


</div>

</body>
</html>
