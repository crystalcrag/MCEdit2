<!DOCTYPE html>

<html>
<head>
  <title>Internals</title>
  <link rel="stylesheet" type="text/css" href="default.css">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head>
<body>

<div id="toc">
<a class="sub1" href="#conventions"><span>Conventions</span></a>
  <a class="sub2" href="#coord"><span>Coordinate system</span></h3>
  <a class="sub2" href="#faceorder"><span>Face enumeration order</span></h3>
  <a class="sub2" href="#datatypes"><span>Datatypes</span></h3>

<a class="sub1" href="#culling"><span>Frustum culling</span></a>
  <a class="sub2" href="#firstvers"><span>First version</span></a>
  <a class="sub2" href="#impl"><span>Implementation</span></a>
  <a class="sub2" href="#neighbors"><span>Enumerating neighbors</span></a>
  <a class="sub2" href="#edgecase"><span>Edge cases</span></a>
  <a class="sub2" href="#crossplane"><span>Cross-plane faces</span></a>
  <a class="sub2" href="#caveats"><span>Caveats</span></a>
  <a class="sub2" href="#fakechunks"><span>Fake chunks</span></a>
  <a class="sub2" href="#outside"><span>Outside bounds</span></a>
  <a class="sub2" href="#cavecull"><span>Cave culling</span></a>

<a class="sub1" href="#blocks"><span>Block API</span></a>
  <a class="sub2" href="#blockdesc"><span>Block description</span></a>
  <a class="sub2" href="#statedesc"><span>State description</span></a>
  <a class="sub2" href="#blockmodel"><span>Block models</span></a>

<a class="sub1" href="#opengl"><span>Advanced OpenGL</a>
  <a class="sub2" href="#translucency"><span>Alpha transparency</span></a>
  <a class="sub2" href="#gpubanks"><span>Managing chunks on the GPU</span></a>
    <a class="sub3" href="#vtxbuffers"><span>Vertex buffers</span></a>
    <a class="sub3" href="#vtxdata"><span>Vertex data</span></a>

<a class="sub1" href="#mesh"><span>Mesh generation</span></a>
  <a class="sub2" href="#meshsolid"><span><tt>SOLID</tt> voxel</span></a>
    <a class="sub3" href="#vtxtex"><span>Coordinates</span></a>
    <a class="sub3" href="#skyblock"><span>Lighting</span></a>
    <a class="sub3" href="#cnxtex"><span>Connected textures</span></h4>
	<a class="sub3" href="#meshhalf"><span>Half-block</span></a>
    <a class="sub3" href="#ocs"><span>Occlusion</span></a>
  <a class="sub2" href="#meshcust"><span><tt>CUST</tt> voxel</span></a>
    <a class="sub3" href="#cnxmodels"><span>Connected models</span></a>

<a class="sub1" href="#nbt2"><span>NBT API</a>

<a class="sub1" href="#entities"><span>Entities</span></a>
  <a class="sub2" href="#structure"><span>Data structure</span></a>
  <a class="sub2" href="#collision"><span>Collision correction</span></a>
</div>

<div id="content">

<h1>MCEdit internals</h1>

<div id="abstract"><u>Abstract:</u>
<p>Some of the algorithms and data structures used in MCEdit 2.0 are not that trivial to understand by looking at the source
code, even heavily commented, especially since the rendering engine makes heavy use of what appears to be cryptic static tables.
This document will provide in-depth explanation for some of them.

<p><b>Pre-requisite</b>: knowledge of OpenGL, 3D math and C programming language.
</div>

<p id="auth">Written by T.Pierron, July 2020</p>

<h2>Conventions</h2>

<p>Before reading this document further, there are a few facts to keep in mind, because they are used
quite extensively throughout the engine. To avoid repeating them over and over again, here is what needs
to be known:

<h3 id="coord"><span>Coordinate system</span></h3>

<div class="photo" style="float:left">
  <img src="images/axis.svg">
</div>

<p>The <b>coordinate system uses a left hand axis</b>. X is mapped to east-west (increasing X goes to east,
decreasing goes to west). Z is mapped to north-south (increasing Z goes to south, decreasing goes to
north). Y is elevation.

<p>Meshes of various objects use a counter-clockwise (CCW) orientation to check if they are front-facing.

<p>Coordinates are relative to player (ie: if you want an object close to camera, coordinates must
be close to player position, not 0,0,0). <span class="n">XXX</span> That's not good actually: coords
are stored in floats, loss of precision will be problematic.


<h3 id="faceorder"><span>Face enumeration order</span></h3>

<p>Whenever there is a need to enumerate nearby objects within the voxel space, the <b>same order will
be used almost everytime</b>. For example: to enumerate the 6 nearby voxels a given block is directly
connected to, to enumerate the 6 neighbors a given chunk is connected to, to generate the mesh of the
6 faces a given cube is composed of, ... these will always be done in the same order:
<ol>
  <li><b>South</b>
  <li><b>East</b>
  <li><b>North</b>
  <li><b>West</b>
  <li><b>Top</b>
  <li><b>Bottom</b>
</ol>

<p>Keep that order in mind, it is <b><u>used extensively</u></b> in one form or another throughout the entire code
base. It can be used as indices in a for-loop from 0 to 5, be used as a bit field to remember which
sides have been visited (therefore have values from 0 to 63), or simply as a enumeration value
(<tt>SIDE_*</tt>).

<p>You'll often see the abbreviation <tt>S,E,N,W,T,B</tt> (or sometimes just <tt>S,E,N,W</tt>) throughout
the code base, this is a reminder of this order.

<p>Technically, there are no obligations to respect that order all over the place, but it makes it easy
to reuse the same look-up tables over and over again, without having to worry about compatibility.

<h3 id="datatypes"><span>Datatypes</span></h3>

<p>Datatypes in the engine follows a small, but kind of helpful convention: if a structure has to be
declared as a value, <b>it is not</b> typedef'ed, and the name <b>always have</b> a trailing <tt>_t</tt>
(the t stands for <tt>type</tt> of course).

<p>If there are no trailing <tt>_t</tt> and no <tt class="t">struct</tt>, therefore it is a pointer. Consider the
following example:
<pre><span class="t">struct</span> BlockIter_t iter;
BlockIter iterator;</pre>

<p>From this convention, you know the second declaration is a pointer to a <tt><span class="t">struct</span> BlockIter_t</tt>.

<p>Sometimes a typedef is introduced for <tt class="t">struct</tt> to remove the need to type this keyword,
because the type itself is used quite extensively. For example:
<pre><span class="t">typedef struct</span> NBTIter_t     NBTIter_t;
<span class="t">typedef struct</span> NBTFile_t     NBTFile_t;</pre>
<p>But, the type will keep the <tt>_t</tt> suffix to indicate it is a value type, not a pointer.


<h2>Frustum culling</h2>

<p>Frustum culling refer to the algorithm that can enumerate all the objects that are visible within
the model-view-projection matrix. It is usually a compromise between precision of object's bounding
box and computational power required to test those bounding boxes: we cannot spent too much time on
the CPU checking for object's visibility (because in the meantime the graphics card could have probably
already drawn this object) and on the other hand, including out-of-view objects, will requires useless
work for both the CPU and the GPU.

<p>The techniques used in this engine are not particularly revolutionary, but it uses <b>a lot of</b>
little tricks that makes the source code particularly cryptic.

<p>A <prod>Minecraft</prod> terrain is composed of a grid of chunks: axis-aligned boxes of 16x16x16 voxels.
A grid means they share a lot of vertices: if we know that one corner of a chunk fits within the frustum,
we can automatically add the 7 others chunks that share this vertex.

<p>In other words by testing only one vertex, we can potentially add up to 8 chunks to the list of visible
objects. Which means  on average, we will have to <b>test one point per chunk</b>. <em>That is reasonably 
cheap</em>.

<p>Testing if a vertex is part of a frustum is actually very easy: we can use the MVP matrix (the exact
same one that will be used in the vertex shader), by simply multiplying that matrix with the coordinates
of our vertex (using 1 as the fourth vector component). That is:
<pre>V<sub>p</sub> = MVP * V</pre>
<p>Then to test if a vertex is inside the frustum, we can simply use the properties of homogeneous coordinates:
<pre>Vp is in frustum if:
	-V<sub>pw</sub> &lt;= V<sub>px</sub> and V<sub>px</sub> &lt;= V<sub>pw</sub> and
	-V<sub>pw</sub> &lt;= V<sub>py</sub> and V<sub>py</sub> &lt;= V<sub>pw</sub> and 
	-V<sub>pw</sub> &lt;= V<sub>pz</sub> and V<sub>pz</sub> &lt;= V<sub>pw</sub>
</pre>

<p><tt>V<sub>pw</sub></tt> is the fourth component of our projected point. More precisely, each of
these inequalities check if the coordinate is outside one of the 6 planes that defines the frustum.
We'll need that information later.

<p>In this engine, a <tt>struct Chunk_t</tt> (or <tt>Chunk</tt> if you just want a pointer) is a datatype
that reference an entire column of 16x16 blocks of terrain. A <tt>struct ChunkData_t</tt> (or <tt>ChunkData</tt>
as a pointer type) contain all the data (block IDs, sky light, block light, meta-data, ...) for one
16x16x16 blocks of terrain. Keep those datatypes in mind, they will be used throughout this section.

<h3 id="firstvers"><span>First version (pseudo-code)</span></h3>

<p>So, a first version for this algorithm would be:
<div class="pre">
<ul>
  <li>Start with a empty list of visible chunk.
  <li>Add the chunk where the player in that list.
  <li>For each chunk in that list:
    <ul>
	  <li>For each of the 8 corners of the chunk:
	    <ul>
		  <li>Check if corner is in frustum.
		  <li>If yes, add 8 connected chunks to the end of the list (if the chunk has not already been added yet).
		</ul>
	</ul>
</ul>
</div>

<p>That algorithm seems pretty simple, but lacks <b>a lot</b> of house-keeping required to achieve our
goal of one vertex checked per chunk.

<p>As simple as this version is, it already has a few interesting properties:
<ul>
  <li>There was no particular constraints on the MVP matrix, and indeed this algorithm will work for <b>any projection</b> (orthogonal,
  perspective) <b>any FOV</b> and any <b>render distance</b> (near and far plane).
  <li>The list of chunks will mostly be sorted from front to back. It is not perfect, but good enough to trigger some early depth culling
  from the GPU.
</ul>

<h3 id="impl"><span>Implementation (C code)</span></h3>

<p>Sadly, the implementation is a lot more complex than this though. Most of the complexity is to deal
with edge cases though. If you look at the datatype needed for generating the visible list, you can
see there are a few static tables:
<pre style="font-size: 1vw"><span class="t">struct</span> Frustum_t
{
   <span class="t">int32_t</span> neighbors[<span class="o">8</span>];       <span class="c">/* 8 corners having 8 neighbors: bitfield encode 27 neighbors */</span>
   <span class="t">uint8_t</span> chunkOffsets[<span class="o">27</span>];   <span class="c">/* bitfield of where each chunks are (S, E, N, W, T, B) */</span>
   <span class="t">uint8_t</span> faces[<span class="o">6</span>*<span class="o">4</span>];         <span class="c">/* cross-plane faces */</span>
   <span class="t">uint8_t</span> faceDir[<span class="o">6</span>];         <span class="c">/* direction to go to find chunk connected to face */</span>
   <span class="t">uint8_t</span> firstFree[<span class="o">256</span>];     <span class="c">/* fake chunk allocator */</span>
   <span class="t">float</span> * mvp;                <span class="c">/* model-view-projection matrix (4x4) */</span>
};
</pre>

<p>To achieve what's described in the first algorithm, we only need the first 2 tables: <tt>neighbors</tT> and <tt>chunkOffsets</tt>.

<div class="photo" id="vtxorder" style="float: right; width: 25%; margin: 0 0 0 20px">
  <img src="images/cube.svg" width="100%">
  <cap>Vertex order of a chunk</cap>
</div>

<p>The order of each corner of a chunk is illustrated with the figure on the right. Each of these
corners can potentially add 8 chunks, if that corner is contained within the frustum. By overlapping
all those connected chunks you get a 3x3 cube of chunks. Therefore, the maximum number of connected
chunks you can have from those 8 corners is 27.

<p>This is what encodes the <tt>neighbors</tt> table: each of these 27 chunks are given a number
between 0 and 26, and therefore can be encoded as a bitfield in a 32bit integer. The order is shown below
(axis is the same as the figure on the right):

<table class="skewed" id="cube3x3">
<tr><td>18<td>19<td>20
<tr><td>21<td>22<td>23
<tr><td>24<td>25<td>26
</table>

<table class="skewed">
<tr><td>9<td>10<td>11
<tr><td>12<td><span class="o">13</span><td>14
<tr><td>15<td>16<td>17
</table>

<table class="skewed">
<tr><td>0<td>1<td>2
<tr><td>3<td>4<td>5
<tr><td>6<td>7<td>8
</table>

<p><tt>13</tt> is therefore the chunk we are currently in. For example, if we checked that vertex
<tt>0</tt> of a chunk is within the frustum, we know we can also add chunks <tt>0</tt>, <tt>1</tt>, <tt>3</tt>,
<tt>4</tt>, <tt>9</tt>, <tt>10</tt> and <tt>12</tt>. Chunk 13 is not included, because at this point
we already know that the center chunk is part of the frustum. Encoded as bitfield, with the n<sup>th</sup>
bit set if chunk number <tt>n</tt> is in the frustum, the 7 chunks to add for vertex 0 can be encoded
as <tt>2<sup>0</sup> + 2<sup>1</sup> + 2<sup>3</sup> + 2<sup>4</sup> + 2<sup>9</sup>
+ 2<sup>10</sup> + 2<sup>12</sup> = 5659</tt>, and so on for the other 7 corners: that's what is
stored in the <tt>neighbors</tt> table.


<h3 id="neighbors"><span>Enumerating neighbors</span></h3>

<p>To enumerate all the connected chunks, we'll check if each corner of a chunk is within the frustum
and accumulate those neighbor bitfields into a 32bit integer. Then, we can just use the <tt>chunkOffsets</tt>
table to locate the n<sup>th</sup> chunk (with <tt>n</tt> varying from 0 to 26). Therefore this table
will have 27 elements. Each element is a bitfield with the following meaning:
<ul>
  <li>bit 1 set: move to the <b>south</b> (+Z).
  <li>bit 2 set: move to the <b>east</b> (+X).
  <li>bit 3 set: move to the <b>north</b> (-Z).
  <li>bit 4 set: move to the <b>west</b> (-X).
  <li>bit 5 set: move to the <b>top</b> (+Y).
  <li>bit 6 set: move to the <b>bottom</b> (+Y).
</ul>

<p>That order (<tt>S, E, N, W, T, B</tt>) is used <b>extensively</b> throughout the engine (especially for generating
the mesh of a chunk) and as such there are a lot of helper functions that can use this bitfield directly.

<p>If the chunk is tagged by the bitfield, it is then added at the end of the visible list, to be
scanned later to see if we can reach new chunks from here. We continue then until the entire list
has been scanned.

<h3 id="edgecase" style="clear: both"><span>Edge cases</span></h3>

<p>This first version easily <b>covers around 90% to 99%</b> of the chunks we need to enumerate, but
it can miss some especially around the corners of frustum. This version also breaks down when the FOV
gets too small. Consider the following frustum:

<div class="image">
  <img src="images/fov10deg.png">
  <cap>Frustum with a 10&deg; FOV</cap>
</div>

<p>Technically, a frustum should be more of a trapezoidal shape, but the parameters used for the near and far plane in
<prod>MCEdit 2.0</prod> are respectively 0.1 and 1000, which gives almost a triangular shape.

<p>You can see here that none of the vertex from the corners of every chunks fit within the frustum. Yet, the frustum does indeed
cross some chunks. How do we enumerate these?

<p>For these, we can use the properties of homogeneous coordinates, when checking if a point is in the frustum: 

<pre>Vp is in frustum if:
	-V<sub>pw</sub> &lt;= V<sub>px</sub> and V<sub>px</sub> &lt;= V<sub>pw</sub> and
	-V<sub>pw</sub> &lt;= V<sub>py</sub> and V<sub>py</sub> &lt;= V<sub>pw</sub> and 
	-V<sub>pw</sub> &lt;= V<sub>pz</sub> and V<sub>pz</sub> &lt;= V<sub>pw</sub>
</pre>

<p>Each of these inequalities tells us on which side of each plane the point is. For example if <tt>V<sub>pz</sub> &lt; -V<sub>pw</sub></tt>
is true, that means the point is behind the near plane. Similarly, if <tt>V<sub>pz</sub> &gt; V<sub>pw</sub></tt> is true, the point is beyond the
far plane, and so on...

<h3 id="crossplane"><span>Cross-plane faces</span></h3>

<p>We can then keep track of which plane the point is outside of, using a bitfield. Since there are
6 planes, a single byte will be enough. That is the purpose of the <tt>outflags</tt> table in the
<tt><span class="t">struct</span> Chunk_t</tt> type: keep track of which planes the origin corner
of each sub-chunk (16x16x16 area, <tt><span class="t">struct</span> ChunkData_t</tt> in the
code) is outside of. The origin corner is the location of block 0, 0, 0 within the chunk.

<p>Therefore to get the <tt>outflags</tt> values of the 8 corners of a <tt>ChunkData</tt>, we will
have to extract them from the 4 neighbor chunks (<tt><span class="t">struct</span> Chunk_t</tt>):
for example the <tt>outflags</tt> value for the coordinate <tt>chunk.x + 16, chunk.y, chunk.z</tt>
is located in the chunk directly to the east of <tt>chunk</tt>: that is how we achieve one matrix
test per <tt>ChunkData</tt> (on average).

<p>For each <tt>ChunkData</tt> we want 8 <tt>outflags</tt> values: one per corner, that we
need to compute and/or extract from nearby chunks. Once we have this information, we can check if a
<b>face</b> of the <tt>ChunkData</tt>'s bounding box crosses two planes: each face is composed of 4
segments and given 2 points that form a segment, this segment crosses two planes if the corresponding
<tt>outflags</tt> value of these points have at least <b>2 bits</b> that differ. Using the C language,
this can be trivially done using a XOR operation:

<pre><span class="t">int</span>    pt1, pt2;      <span class="c">/* we'll see how to enumerate these in a bit */</span>
<span class="t">int8_t</span> flagsPt1 = outflags[pt1];
<span class="t">int8_t</span> flagsPt2 = outflags[pt2];

<span class="k">if</span> (popcount(flagsPt1 ^ flagsPt2) &gt;= <span class="o">2</span>)
{
	<span class="c">/* segment crosses more than 2 planes */</span>
}</pre>

<p><tt>popcount()</tt> is the typical function name for counting the number of 1 bits in an integer,
it is a shorthand for <b>pop</b>ulation <b>count</b>. Since we are using 6 bit integers, we could
have used another lookup table, but most CPU nowadays have a dedicated instruction for this,
which are even <a href="https://github.com/BartMassey/popcount">faster</a> than a lookup table.

<p>If just one segment from the face crosses two or more planes, we consider the entire face as crossing
them too.

<p>In the implementation, two tests were added to <b>eliminate as early as possible some degenerate cases</b>.
Even though the code down the line is able to eliminate those, we might as well remove them as early as possible,
since those tests are very cheap.

<p>The first test check if all the <tt>outflags</tt> of a given face have their coordinates
outside the frustum, using a test like this:
<pre>sector1*sector2*sector3*sector4 != <span class="o">0</span></pre>
<p>If one face has a coordinate inside the frustum (<tt>outflags == <span class="o">0</span></tt>),
the nearby chunk will already be added by the first pass of the algorithm. Then the second test is:
<pre>sector1&amp;sector2&amp;sector3&amp;sector4 == <span class="o">0</span></pre>
<p>This test ensure that not all the coordinates are on the same side of a plane. This happen
quite often at the starting chunk position: coordinates of a face are all to the left/right of a
plane, but also cross the top/bottom planes, therefore will be considered a cross-plane face and
an useless chunk will be added to the list. Not that much of a big deal, but since they are easy
to eliminate, might as well do it.


<h3 id="caveats"><span>Caveats</span></h3>

<p>These two passes will cover 99% of the use cases, even though there will still be cases where a
chunk will be included in the frustum, when it clearly does not belong. Consider the following example:

<div class="image">
  <img src="images/falsepositiv.png">
</div>

<p>The white square next to the starting chunk shouldn't be included in the visible list. What happened here,
is that the segment <tt>[0,2]</tt> crossed the left and right plane ... but outside the frustum. Because the
result of those inequalities we stored in the <tt>outflags</tt> table supposed that those planes extend to
infinity. Therefore point 0 will be considered <b>both</b> to be on left of the left plane <b>and</b> to the
right of the right plane.

<p>In practice, those false positives are quite rare, less than 1&permil;. It would be pointless to add extra
code to eliminate those. All the vertices from these chunks will be eliminated in the vertex shader, without
even reaching the fragment shader. As long as there aren't too many of these, performance loss will be negligible.

<h3 id="fakechunks"><span>Fake chunks</span></h3>

<p>But we are not done yet. A <prod>Minecraft</prod> map is composed of column of chunks. Those
columns are not all of equal height, far from it. Here's a XY slice view of a typical landscape:

<div class="image">
  <img src="images/sliceview.png">
</div>

<p>The yellow lines shows the sub-chunk boundaries, cyan chunks with no writings in it, indicate an
empty chunk: nothing is allocated for these, attempting to get a <tt>ChunkData</tt> for these will
return <tt class="o">NULL</tt>. Player is currently in one of those empty area, looking left, therefore
the algorithm will have no starting point, and as is, will generate an empty list of visible chunks.
Not good.

<p>If that's the case, a fake chunk will be created for the sole purpose of tracking where we are and
to check where we can go next. Those sub-chunks are actually cheap to allocate because we only need
a small subset of the fields contained in a <tt>ChunkData</tt> structure (we only need 2 actually,
about 20 bytes): those chunks are therefore allocated in batch of 32, with their memory layout
overlapping the fields we don't need.

<p>But to prevent allocating useless fake chunks, we only allocate one if it has a lower Y coordinate
than the previously visited. Fake chunks only have to be alloced above ground, therefore if we want
to find something to display, we need to go down (lower Y value). That's the purpose of <tt>cdIndex</tt>
field in a <tt>struct Chunk_t</tt>.

<h3 id="outside"><span>Outside bounds</span></h3>

<p>Fake chunks work fairly well as long as we remain within build limit. Even if the engine would allow
unlimited build height, it would be pointless to allocate a gigantic column of fake chunks just to reach
the ground level, because we can do this by using some simple geometry. And besides, a geometric
approach is required when the player is below the bottomest chunk (i.e.: <tt>Y &lt; 0</tt>).

<p>Again, the problem here is that the frustum culling won't have a starting point, worse: <b>it cannot
have one</b>, because there is no place in the <tt>Chunk</tt> structure to store a reference, even for a
fake chunk.

<p>/* ... */

<h3 id="cavecull"><span>Cave culling</span></h3>

<p>There is one last step that is done at (almost) the same time: cave culling, or removing chunks that
are completely hidden by nearer chunks. A good primer on how this algorithm works can be read from the
original <a href="https://tomcc.github.io/2014/08/31/visibility-1.html">author</a> that developed it
for Minecraft MCPE.

<h4 id="cavecullv1"><span>First attempt</span></h3>

<p>In the linked blog post, it was mentioned that they first tried to remove chunks that are completely
surrounded by opaque chunks (ie: where the outer face is completely made up of opaque quad). Unsurprisingly,
the results were disappointing: it only culled about 1% of total chunks.

<p>A simpler approach were attempted for this engine, because computing the visibility graph is actuatlly
not that cheap (although with that information, <b>you can cull a lot of chunks</b>).

<p>The slight improvement was to realize that <b>a cube viewed using a perspective projection
matrix has at most 3 faces visible</b>. Instead of checking all 6 faces, we only need to check at most 3.
Checking if a face is fully opaque is very simple and super cheap to compute.

<p>Sadly, the results for this method were also disappointing: it culled about 10% of the chunks in the
view frustum. Caves leave too many holes in chunks, which means finding an entire solid face is quite
rare in practice.

<p>This section is just a reminder to not waste any time with any of these techniques.

<h4 id="cavecullv2"><span>Second attempt</span></h3>

<p>Second attempt was based on the algorithm described in the link above: compute visibility graph of
connected chunks, and traverse that graph while attempting to mimic a raycasting traversal of that graph.
The traversal was changed quite a bit though: the one used in <prod>Minecraft</prod> is a bit too aggressive,
and tend to discard chunks that are clearly visible (as of v1.17 the results are a lot better since it
was introduced in 1.8).

<h5 id="cnxgraph"><span>Computing visibility graph</span></h3>

<p>Computing the visibility graph is not that hard: in this engine it is implemented in
<tt>mapUpdate.c</tt>: <tt>mapUpdateGetCnxGraph()</tt>. It uses a 3D flood fill (as described in the blog
post), using a ring buffer (to simulate recursion) and bit-vector to manage which voxel has been visited.
This sounds way more complicated than it really is: there is about 40 lines of code for this function
(comments included).

<p>A simplification was done though: we only start the scan at the edge of the chunk: because we only
need to know which faces can be reached from a given face. Knowing there is a hidden hole in the middle
of a chunk, is an information we don't care at all. That means if the outer layer of the chunk is
completely solid, the flood fill should be rather cheap to compute (and kind of expensive if the chunk
is mostly air).

<p>The visibility of faces is <b>stored in a bitfield</b>. Since there are 6 faces, there are <b>15</b>
possible connections:

<table class="hspace">
  <thead><tr><td><small>to &#x25ba;<br>from &#x25bc;</small><td><tt>S</tt><td><tt>E</tt><td><tt>N</tt><td><tt>W</tt><td><tt>T</tt><td><tt>B</tt>
  <tbody><tr><th><tt>S</tt><td class="XXX"><td>1<td>2<td>3<td>4<td>5
         <tr><th><tt>E</tt><td>1<td class="XXX"><td>6<td>7<td>8<td>9
         <tr><th><tt>N</tt><td>2<td>6<td class="XXX"><td>10<td>11<td>12
         <tr><th><tt>W</tt><td>3<td>7<td>10<td class="XXX"><td>13<td>14
         <tr><th><tt>T</tt><td>4<td>8<td>11<td>13<td class="XXX"><td>15
         <tr><th><tt>B</tt><td>5<td>9<td>12<td>14<td>15<td class="XXX">
</table>

<p>This table shows the connection bit used to encode all the connections there are in a sub-chunk.
The connections are stored in <tt>ChunkData.cnxGraph</tt>: it is a bitfield (<tt>1 &lt;&lt; connectID-1</tt>)
that indicates which face has a visible path to another face. If there are no paths, that means the
face is blocking the visibility of a chunk.

<h5 id="cnxgraph"><span>Graph traversal</span></h3>

<p>This is the part that differs significantly from the blog post: it uses a more conservative approach,
which results in more chunks being drawn, but should not leave any unfilled hole in the world.

<p>This is <b>done after the chunks have been culled from the frustum</b>. In MCPE, it was done before.
In this engine, it is not feasible because a given chunk can add up to 26 others. Graph traversal only
works with connected chunks (<tt>S, E, N, W, T, B</tt>). While technically, it is possible to make it
work, and have indeed been tried, in practice it adds way too much complexity compared to current
implementation (another advice to not waste any time with this idea).

<p>The way it is done, is actually pretty simple: since frustum culling orders chunks from near to far,
we then scan the chunks from beginning to the end of that list. From a given chunk, we check if there
is a path within the visibility graph that can reach a previously visible chunk.

<p>We also use the fact that a cube in 3d space only have, at most, 3 visible faces. Going through
hidden faces will add a significant amount of hidden chunks. Visibility of a face is done by computing
the dot product between the face normal and the vector from camera to one point of the face.

<p>This method is not as aggressive as the current version of <prod>Minecraft</prod>: it is far from
simulating a raycasting traversal, but can still easily cull 50% of chunks when above ground, and nearly
90% when underground. Still, way better than the first version.


<h2 id="blocks">Block API</h2>

<p>This section will describe how the block description table works (<tt>blocksTable.js</tt>). This
table describes all of the blocks recognized by this engine and their different states, along with
their custom models if any.

<p>This table does not cover 100% of use cases though: you cannot change it and expect to have a
completely different "game". Some special processing is hardcoded within the engine (like redstone
behavior, block with tile entities). Still, this table is used to define a huge chunk of the engine
behavior.

<p>This table uses the javascript object notation format. It is similar to the JSON format, with a few
changes: property names don't have to be enclosed in double quotes and property values can contain expressions.

<p>For the sake of simplifying the parsing, property names have to start with a <b>lower case letters</b>,
constants assigned to property must be spelled using only <b>uppercase letters</b>.

<p>This table contain <b>2 types of objects</b>:
<ol>
  <li><b>Block description</b>: contain generic information about the block, like its type, id,
  name, inventory category, inventory model, ... That information must remain true for all states.
  If that's not the case, some properties can also be declared at the state level.
  <li><b>State description</b>: also known as meta-data. Each block in the terrain can have up to 4bits
  of extra information, that can describe 16 different states. This is the purpose of these objects:
  provide a complete description of one state: custom mesh model and/or texture coordinate if block
  is completely solid. Not all 16 states have to be defined, but at least 1.
</ol>

<h3 id="blockdesc"><span>Block description</span></h3>

<p>A block description must contain the property <tt>id</tt> and be assigned to an integer. Here are the
possible properties:
<ul>
  <li><tt>id</tt>: the block ID as it is stored in the NBT table <tt>Sections/Blocks</tt> of a chunk.
  <li><tt>type</tt>: how the block will be rendered in the world. This field will constraint what is
  expected for state description. <b>This is a very important field</b>, you can choose one value among:
  <ul>
    <li><tt>INVIS</tt>: invisible. No mesh will be generated for these (typical use case: AIR).
    <li><tt>SOLID</tt>: a full 1x1x1 voxel cube. This engine is optimized to display these. They are
	cheap to process, cheap to render and cheap to define: just specify the texture of the 6 sides of
	the cube and that pretty much all there is to it.
	<p>Note: stairs and slab are considered SOLID blocks.

    <li><tt>TRANS</tt>: Similar to SOLID, they must be defined as a full unit cube. The difference is
	in the way hidden surface removal works: for SOLID blocks, all sides shared by any other solid block
	will be removed. For TRANS block, this check will only be done with the same block id (typical use
	case: glass or water).
    <li><tt>QUAD</tt>: for blocks that are a mix of flat quads that does not necessarily forms a cube.
	Typical use case: crops, grass or flowers.
    <li><tt>CUST</tt>: completely arbitrary shape, a custom model will be expected for each state
	description. Keep in mind that the model cannot exceed a 2x2x2 cube in size. If you need more,
	you will have to use an dedicated entity otherwise.
  </ul>
  <li><tt>name</tt>: a human readable name that will be displayed in various places of the engine.
  <li><tt>tech</tt>: the technical name stored in inventories. If the name is the same as the <tt>name</tt>
  field (but converted to lowercase and space replaced with underscore), you can omit that field.
  <li><tt>inv</tt>: how this block is going to represented in inventory menus. It is an enumeration
  value that can be assigned to one of the following values:
  <ul>
    <li><tt>CUBE</tt>: each individual states will have its own inventory item in the form of a cube. The
	textures used for the cubes will be described in the state description. In the screenshot below, cube
	inventory items have been highlighted with a green background.
    <li><tt>ITEM2D</tt>: each states will be represented as flat 2d texture (taken from state description).
	In the screenshot below, they have a gray background.
    <li><tt>MODEL</tt>: will use a custom model for their inventory. The model will be viewed at an angle
	using a orthographic projection (not a perspective one). You can provide a custom model to be used
	only in inventories, or you can reuse the ones defined in the state description. In the screenshot
	below, those items have been highlighted with a red background.
  </ul>
  <div class="image">
    <img src="images/inventory.png">
  </div>
  <li><tt>invstate</tt>: sometimes, you don't want to have one inventory item per state, but only one
  (typical use case: blocks that have an orientation). If this field is present, it must contain the
  state id (between 0 and 15) to use when displaying this item in inventories.
  <li><tt>cat</tt>: the creative menu is split into tabs. This field let you choose which one it will
  be in. If not specified, the item will appear in the "all" category (the tab with the compass, in the
  screenshot above). You can choose one value among;
  <ul>
    <li><tt>BUILD</tt>
	<li><tt>DECO</tt>
	<li><tt>REDSTONE</tt>
	<li><tt>CROPS</tt>
	<li><tt>RAILS</tt>
  </ul>
  <li><tt>special</tt>: special behavior to activate in the engine. Possible choices:
  <ul>
    <li><tt>CHEST</tt>: chest that can form a 2-wide entity. Therefore, that does not include ender chest.
    <li><tt>DOOR</tt>: behave like a door: 2 tall block with the same data values.
    <li><tt>NOSIDE</tt>: will generate a front and back face (typical use is for QUAD block type).
    <li><tt>HALF</tt>: half block: data values will encode placement.
    <li><tt>STAIRS</tt>: data value will encode orientation.
    <li><tt>GLASS</tt>: behave like a glass pane: automatically connect to nearby block with this
	special attribute set (like glass pane and iron bars).
    <li><tt>FENCE</tt>: wooden fences that connect with similar block.
    <li><tt>FENCE2</tt>: nether fence (does not connect with FENCE).
    <li><tt>WALL</tt>: cobblestone wall and variants: it connects with more block than FENCE or GLASS.
    <li><tt>RSWIRE</tt>: used for redstone wire only: wire model depends on nearby blocks.
    <li><tt>LEAVES</tt>: hidden surface must not be removed.
    <li><tt>LIQUID</tt>: water and lava.
    <li><tt>TALLFLOWER</tt>: need a special flag for these, because they are made of 2 blocks.
    <li><tt>RAILS</tt>: this flag is used when placing rails to know which neighbor to update.
    <li><tt>TRAPDOOR</tt>: block update from redstone/user.
    <li><tt>SIGN</tt>: they need special processing (allocate off-screen texture).
    <li><tt>PLATE</tt>: pressure plate (needed for redstone signal).
    <li><tt>SOLIDOUTER</tt>: only useful for <tt>CUST</tt> block type: the block model will be a mix
	of <tt>SOLID</tt> and <tt>CUBE</tt>: the outer layer of the model will use a unit textured cube,
	using the texture declared in the <tt>tex</tt> field of the state description. The purpose of
	this flag is to allow custom block model to benefit from ambient occlusion.
    <li><tt>BED</tt>: their models depend on tile entity.
  </ul>
  <p>Additionally, you can OR these values, with the following flags (ie: separated by |):
  <ul>
	<li><tt>CNXTEX</tt>: generate connected texture for all state description. Texture will be auto-generated
	from state description.
	<li><tt>NOCONNECT</tt>: don't generate connected info. Typical use case: fence gates. They connect
	with fences, and therefore have the FENCE flag, but don't have optional parts like fences.
  </ul>
  <li><tt>bbox</tt>: how the block can be targeted with the mouse. Enumeration value, with the following
  choices:
  <ul>
    <li><tt>NONE</tt>: this block cannot be targeted by user.
    <li><tt>AUTO</tt>: this mode will be automatically set for block type <tt>SOLID</tt>, <tt>TRANS</tt>
	and <tt>QUAD</tt>. Therefore, you can omit the <tt>bbox</tt> field for these types.
    <li><tt>MAX</tt>: this type is intended for <tt>CUST</tt> block type: <tt>MAX</tt> will compute
	the maximum axis-aligned box that covers the entire model.
    <li><tt>FULL</tt>: another mode for <tt>CUST</tt> block type: each individual part of a custom model
	will be used to check if the block is targeted. This type of collision test is very precise, but
	of course a bit more expensive to check.
  </ul>

  <li><tt>bboxPlayer</tt>: bounding box used for player/entity collision detection. The only supported
  value for this field is <tt>NONE</tt>. Otherwise, it will use the same value than the one specified in
  the <tt>bbox</tt> entry.

  <li><tt>orient</tt>: if block placement is orientation dependent, you can specify with this field
  how individual state description can be automatically chosen based on player orientation and/or block
  targeted:
  <ul>
    <li><tt>LOG</tt>: 3 possible orientation: E/W, N/S, or up right.
    <li><tt>FULL</tt>: 6 possible orientation: south, east, north, west, top, bottom.
    <li><tt>BED</tt>: 4 possible orientation, composed of 2 blocks.
    <li><tt>SLAB</tt>: 2 orientation: lower half, upper half.
    <li><tt>TORCH</tt>: 5 orientation: stick to wall or up right.
    <li><tt>STAIRS</tt>: 8 orientation.
    <li><tt>SENW</tt>: 4 orientation (typical: chest, furnace).
    <li><tt>SWNE</tt>: 4 orientation but different state description (typical: repeaters, comparators).
    <li><tt>DOOR</tt>: 8 orientation.
    <li><tt>SE</tt>: 2 orientation: E/W or N/S, typical use case: rails.
    <li><tt>LEVER</tt>: 8 possible orientation: used by lever and buttons.
  </ul>

  <li><tt>emitLight</tt>: if this block will emit block light, you can indicate a value between 1 and 15
  (0 being the default).

  <li><tt>opacSky</tt>: how much intensity of sky light it will absorb. Default is 15 for <tt>SOLID</tt>
  and 0 for everything else. Usual values are 1 for leaves and 3 for water.

  <li><tt>opacLight</tt>: same with block light. Note: block light decreases by 1 for every step away
  from a light source. Therefore if you want a more "absorbing" block, the minimum value should be 2.

  <li><tt>tile</tt>: will add a default tile entity when placed in the world. Needed by Minecraft, not
  necessary for this engine.

  <li><tt>invmodel</tt>: state id (between 0 and 15) where to copy model to be rendered in inventories.
  This particular block will have only one item in the creative menu (instead of one per state).

  <li><tt>rswire</tt>: indicates how redstone wire connects to this block. Possible values are:
  <ul>
    <li><tt>ALLDIR</tt>: all possible direction (S, E, N, W).
    <li><tt>FRONTBACK</tt>: can connect to the front and back of the block (repeaters).
    <li><tt>BACKONLY</tt>: only from back (observer).
  </ul>

  <li><tt>rsupdate</tt>: indicates if this block cares about redstone update. Enumeration that can
  have one of the following values:
  <ul>
    <li><tt>RECEIVE</tt>: block state will change when redstone signal change nearby.
    <li><tt>GENERATE</tt>: will generate the redstone signal.
    <li><tt>INOUT</tt>: will do both: update states with redstone signal and output a signal (ie: repeaters, comparators).
  </ul>  

  <li><tt>placement</tt>: constraint the block has to satisfy to be placed in the world. If those
  constraint were to be invalidated due to nearby update, the block will be automatically deleted.
  The field should be a string, described a list of constraints separated by commas. Each constraint
  can use the following keyword:
  <ul>
    <li><tt>ground</tt>: any type of solid flat ground.
    <li><tt>wall</tt>: any type of solid flat wall.
	<li><tt>solid</tt>: any solid face from a block.
	<li><em>techName</em>: that particular block.
  </ul>
  <p>Note: the block is considered correctly placed if one of the constraint is satisfied. "Solid"
  means a block that has been declared with the type <tt>SOLID</tt>. That excludes <tt>CUST</tt> and
  <tt>TRANS</tt>.

  <li><tt>particle</tt>: type of particles this block will emit constantly.

  <li><tt>invmodel</tt>: custom model to use when this block is displayed in inventories. Should only
  be necessary for block type <tt>CUST</tt>, even though nothing prevent you from using with any other
  type. The format of this field is a bit complicated and be explained in the <a href="#blockmodel">next section</a>.

  <li><tt>pushable</tt>: how this block is going to be affected if pushed/retracted by a piston. Enumeration
  value that can take one of the following value:
  <ul>
    <li><tt>NO</tt>: block can't be pushed, nor retracted (obsidian, chests, ...)
    <li><tt>YES</tt>: default value for all blocks except <tt>QUAD</tt>.
    <li><tt>PUSHONLY</tt>: can only be pushed, but not retracted (glazed terracotta).
    <li><tt>DESTROY</tt>: completely destroy the block if pushed (leaves, grass, ...): this is the
	default for <tt>QUAD</tt>.
    <li><tt>DROPITEM</tt>: remove the block, but create an item entity (flowers, ...).
  </ul>
  <p><b>Note</b>: this engine supports moving blocks containing tile entities (furnace, chests, ...),
  even though in the default block definition file (<tt>blocksTable.js</tt>), they have been marked
  as non-movable.

  <li><tt>gravity</tt>: integer that can be either <tt>0</tt> or <tt>1</tt>. If set to <tt>1</tt>, the
  block will be converted to a falling entity, if placed above air (be it manually or with pistons).

  <li><tt>keepModel</tt>: hack.
</ul>

<h3 id="statedesc"><span>State description</span></h3>

<p>An object declaration is recognized as a state declaration if it is contains a <tt>state</tt> property
with an integer assigned to it. Beside this property, you can also use these ones:
<ul>
  <li><tt>state</tt>: an integer between 0 and 15 that will be stored in <tt>Sections/Data</tt> table in a chunk.
  This table has only 4bits of information per block. More information can be stored using TileEntity.
  <li><tt>name</tt>: this field should describe a bit more in detail what the state is doing: for example,
  if the block is orientation dependent, you should include which way the state is pointing, or if the
  block has an opened/closed state, this is where it should be described...

  <p>Since this field will almost certainly have <b>a lot of redundant information</b>, there are a few
  facility to prevent you from repeating the same text over and over again: the less redundancy, the
  easier it will be to fix mistakes.

  <p>First, a state name can include an underscore (<tt>_</tt>) in the text. This character will
  act as a reference point for later names. The character itself will be replaced by a regular space.

  <p>Once you have a reference point, you can ask to include everything that was before using the <tt>+</tt>
  or <tt>-</tt> character, and then continue your text.

  <p>The text being appended will always be added with a parenthesis before (and a closing one if none
  are specified in the text), unless there was already an opening one in the text that was copied.

  <p>Here are a few examples:
  <table class="listview">
  <thead><tr><td class="nowrap">Block name<td>State name<td>Expanded into<td>Description
  <tbody>
    <tr><td rowspan="4"><tt>Log</tt><td><tt>+oak</tt><td><tt>Log (oak)</tt><td>Without any previous underscore, the whole text of block will be added.
    <tr><td><tt>+spruce</tt><td><tt>Log (spruce)</tt><td>Still no underscore specified, the reference point will remain the same on next line.
    <tr><td><tt class="nowrap">Bark (_oak)</tt><td><tt>Bark (oak)</tt><td>If the text does not include <tt>+</tt> or <tt>-</tt>, then it replaces everything. A new reference point is also set.
	<tr><td><tt>-spruce</tt><td><tt class="nowrap">Bark (spruce)</tt><td>The new reference point now point to a state description, instead of the block.
  </table>

  <li><tt>tex</tt>: texture coordinates to use to draw the faces of that block. Coordinates are actually
  tile coordinates: integers between 0 and 31 that will point to a texture tile in the file <a href="../resources/terrain.png">terrain.png</a>.
  That way the coordinates will work no matter what resolution the file is, the default tile set is 16x16px,
  but you can use whatever size you want (tiles needs to be square though). Although allowed, it is
  strongly discouraged to use a size that is not a power of 2, due to mipmapping (texture will "bleed"
  at the edge of tiles).

  <p>This field is expecting an array of integers. The number of coordinates will depend on the type of the block:
  <ul>
    <li><tt>SOLID</tt>, <tt>TRANS</tt>: 12 integers that form 6 pairs of U, V tile coordinates, one
	pair for each faces, specified in the order <tt>S,E,N,W,T,B</tt>. The coordinate must be specified
	relative to the top left corner of the tile you want to use for that face.
	<li><tt>QUAD</tt>: 2 integers: the tile texture to use for all quads (integer between 0 and 31).
	<li><tt>CUST</tt>: 8 integers: technically not required to render the block, since block model will
	provide their own texture coordinates, but this field will still be used for particles when this
	block is destroyed by the user. You don't have to specify the texture for the top and bottom face
	though, although it doesn't hurt to include them.
  </ul>

  <p>Filling those values manually is possible, albeit tedious and error prone. In the default <tt>blockTable.js</tt>
  field, all the values where filled with the help of <tt>TileFinder</tt>.
  
  <p>This field can include a 13th integer, that will be used to specify the <tt>rotate</tt>
  field (because <tt>TileFinder</tt> can read and write those 13 values at once).

  <li><tt>quad</tt>: an array of symbols indicating which quad to render for this block. Each symbol
  can be one of the following enumeration value:
  <ul>
    <li><tt>CROSS</tt>: used for crops, flower, grass, ...
    <li><tt>NORTH</tt>: attached to north of block (ladder, vines).
    <li><tt>SOUTH</tt>: attached to south face.
    <li><tt>EAST</tt>: east face.
    <li><tt>WEST</tt>: west face.
    <li><tt>BOTTOM</tt>: bottom of block (lily pad).
    <li><tt>ASCE</tt>: ascending from west to east (rails).
    <li><tt>ASCW</tt>: ascending from east to west.
    <li><tt>ASCN</tt>: ascending from south to north.
    <li><tt>ASCS</tt>: ascending from north to south.
  </ul>

  <li><tt>inv</tt>: this field can be used to override what has been specified at the block level.
  Remember, that the type of inventory item specified in the block will be applied to all state description.
  The typical use case is to prevent some states from appearing in the inventory (ie: <tt>NONE</tt>).

  <li><tt>model</tt>: an array of floating point numbers. This field is absolutely not intended to
  edited manually. The format will be described <a href="#blockmodel">below</a>, but even with this
  description, you'll have a hard time filling this field manually.
  <p>Instead, an external tool is almost required: <tt>TileFinder</tt>. You'll notice that all models
  are declared on their own lines (there no JSON tokens mix in those lines, besides what's required
  to make an array of numbers). The reason for this, is that those lines can be selected in a standard
  text editor, then copied and pasted inside <tt>TileFinder</tt> to see what the model looks like.
  You can also copy the model from <tt>TileFinder</tt> to the text file again, if you modify it later.

  <li><tt>rotate</tt>: rotate applied to texture coordinate, 6 groups of 2 bits. Rotation are ordered
  <tt>S,E,N,W,T,B</tt>. The texture will be rotated in multiple of 90&deg; clock-wise (when viewed
  in front), the multiple being the number encoded as 2bits.

  <li><tt>emit</tt>: where emitters are located in the model. An array containing one emitter location
  per entry. It can be one of the letter <tt>S,E,N,W,T,B</tt>, indicating that the entire face can emit
  particles (the location will be randomly selected when a particle is spawned). Or it can be a number:
  if the block has a custom model, this is the primitive number that will be used as location.
</ul>

<h3 id="blockmodel"><span>Block models</span></h3>

<p>Custom models that don't fit <tt>QUAD</tt> or <tt>SOLID</tt> can still use arbitrary shapes using
the property <tt>model</tt> on a state description object. All the models has been filled using using
an external application: <tt>TileFinder</tt>. This section will describe how the models are encoded,
but be warned that this format has not been designed to be manually edited.

<p>Contrary to typical models description format (like <tt>.obj</tt>) which usually only contains
triangles, this format uses cubes/boxes as basic primitives, where each face can be selectively
hidden or textured. You can also apply rotation, scaling, translation to each individual box and
by grouping multiple boxes, you get a model.

<p>Each lines usually represent a primitives (ie: box), even though to keep line length under control,
some might have been wrapped. The first number is a bit field encoding quite a few parameters:
<ul>
  <li><tt>bit0~5</tt>: faces activated for this box, bitfield ordered <tt>S,E,N,W,T,B</tt>. Faces not
  activated will have no triangles generated for them at all.
  <li><tt>bit6</tt>: normals are inverted: ie: if south face is active, it should use normal for the
  north face.
  <li><tt>bit7</tt>: texture should be applied using a cube map. Texture coordinates refer to a
  tile in the main texture file, but should be reduced according to the face size/position.
  <li><tt>bit8</tt>: if set, it means there are more primitives following this one.
  <li><tt>bit9~10</tt>: model needs to be rotated by 90 degrees increment CCW (ie: trigonometric rotation).
  Careful though: normals will need to be readjusted. This field is carried to next primitives if any,
  therefore should only be set on the first one.
  <li><tt>bit11~16</tt>: detail face: <tt>S,E,N,W,T,B</tt> bitfield indicating faces for which an exact
  texture coordinate will be provided, instead of a cube map. Usually <tt>bit7</tt> is also set when
  using these.
  <li><tt>bit17~...</tt>: face ID: used for models that have optional parts (fences, glass panes, iron bar, restone
  dust, ...). More on this field later.
</ul>

<p>After that, numbers are a bit more straightforward:
<ul>
  <li><b>3 floats</b>: size of the box, in 1/16 units (ie: 16 = a full voxel), specified in X, Y, Z order.
  Can be fractional if needed. Model can have size of up to <tt>112x112x112</tt> (7 voxels). Although,
  due to frustum culling, it is advised to keep them below 16x16x16 (1 voxel).
  <li><b>3 floats</b>: translation to apply, also in 1/16 unit, that will be applied to the X, Y, Z axis.
  <li><b>3 floats</b>: rotation in degrees, CCW (trigonometric rotation) on the X, Y, Z axis.
  <li><b>3 floats</b>: rotation in degrees, CCW. The difference with the previous 3 numbers, is that
  these rotations will be carried onto the next primitives.
</ul>

<p>At last, these number can be followed by up to 24 integers which represent the UV coordinates of
the texture to use for the faces defined for this box. There are 4 numbers per face. The number of
faces is the number of bits activated in the first number (ie: <tt>popcount((int) model[0] & 63) * 4</tt>).

<p>Each number must encode a <tt>UV</tt> coordinate as two integers. <tt>U</tt> can vary from 0 to 512,
and <tt>V</tt> from 0 to 1024. <tt>U</tt> can therefore address 513 numbers, thus the formula for each
number is <tt>U + V * 513</tt>.


<h2 id="opengl">Advanced OpenGL</h2>

<p>This section will explain some aspects of rendering pipeline.

<h3 id="translucency"><span>Handling translucent blocks</span></h3>

<p>That part was probably one of the biggest <b>crap shoot to implement</b>. 2 attempts were tried
(depth peeling and fragment sorting on the GPU), but ultimately were entirely discarded because of
serious shortcomings in the way they inherently work. Therefore the first 2 sections are a reminder
to not waste your time with these techniques.

<h4 id="oit"><span>Fragment sorting on GPU (Order Independent Transparency)</span></h4>

<p>In the OpenGL red book ninth edition, there is a fully working example for handling alpha transparency
in a <b>completely generic and 100% accurate way</b>, for any type of geometry, entirely on the GPU. The
implementation seemed elegant, not very intrusive, therefore rather easy to integrate, and indeed handle
absolutely all use cases.

<p>The basic idea with this technique is this:

<blockquote>
<p>Instead of writing translucent fragment directly in the main framebuffer, within the fragment shader,
you write them in a (very big) linked list. Thanks to OpenGLv4 atomic types and counters, this can be
achieved rather easily.

<p>The linked list is implemented using 2 textures: one texture the size of the framebuffer, where each
pixel will actually store the head of the linked list as a 32bit integer. The second texture will contain
the fragments (unsorted). For each element in this texture, we need: the RGBA color (32bit int),
the depth value (32bit float) and the next fragment in the list (32bit int), therefore 12 bytes per
translucent fragment.

<p>Once all fragments has been written in that list, you start a second pass to write them in the
framebuffer, by using the head texture to get all translucent fragment at given position, sort them
by decreasing depth, combining them using pre-multiplied alpha and finally writing the result into
the framebuffer (ie: returning the final color from the fragment shader).
</blockquote>

<p>That technique works indeed fine, except for a few use cases where <b>performance can suffer
massively</b>: a simple way to push this technique to its limit, is simply to have 2 quads, one
behind the other, very close to the camera. In that case, this is what will happen (supposing a
framebuffer of <tt>1920x1080px</tt>):
<ul>
  <li>Each pixel of the framebuffer will have to write 2 fragments in the linked list.
  <li><tt>2</tt> fragments times <tt>1920px</tt> times <tt>1080px</tt> times <tt>16</tt> bytes (12 bytes
  per fragment + 4 bytes for head of linked list) times <tt>60</tt> (frame per second) = a little bit
  under 4 Gb / second. That is going to saturate the memory bandwidth of all but high-end configuration.
  <li>To add insult to injury, if you were to sort those quads using the CPU, it would be just a few
  hundreds <b>of bytes</b> to move around each second.
</ul>

<p>In conclusion: <b>for a voxel engine, it is not advised to rely on this technique alone</b>.

<h4 id="depthpeel"><span>Depth peeling</span></h4>

<p>This is another technique to handle alpha transparency in a <b>completely generic</b> way, with 100%
accuracy, and <em>mostly</em> handled by the GPU. The idea behind this technique is as follows:

<blockquote>
<p>Once again instead of writing the fragments directly in the main framebuffer, you write them into
another one (that has one color and <b>two</b> depth buffers). Obviously on that framebuffer, you will
have to manage both depth buffers on your own. The first depth buffer needs to be initialized to the min
value, and the second to the max value.

<p>On the CPU side, you start a loop with the number of "peel" of transparency you want to uncover.
There is a technique to get the exact number of loop, but as a starting point use an arbitrary number,
like 2 or 3.

<p>In the fragment shader handling translucent triangles, you overwrite the color only if the depth of the
fragment is higher than the value currently stored in the first depth buffer (ie: farther) and lower
than the second one (ie: nearer). If the fragment passes both tests, update the <b>first</b> depth buffer
to the depth of the fragment. If outside of that range, discard the fragment.

<p>Doing so, you just extracted the first layer of the farthest translucent fragments. You can now merge
the color buffer with the main framebuffer, using a trivial shader and a quad covering the entire screen.

<p>You might think that the first depth buffer could be managed by OpenGL using a depth test set to
<tt>GL_GREATER</tt>, but we will need the result of that test later.

<p>Next step is to swap the first and second depth buffer, initialize the (new) first depth buffer to
the min value, clear the color buffer and continue with the next iteration of the loop.

<p>On the second iteration, you'll have extracted the second farthest layer of translucent fragments.
</blockquote>

<p>The <b>main problem with this approach</b> is getting the exact number of loops required to draw all the
transparent fragments: if you do too little, some geometry will be missing and if you do too many loops,
you are going to waste time doing completely unnecessary work. But, due to the asynchronous nature of
GPUs, this value is not that trivial to get without stalling the pipeline.

<p>One way to do this, is to use a generic buffer accessed through an atomic operator, like <tt>atomicOr()</tt>,
to be called whenever at least one fragment is <b>discarded</b> due to the being replaced by a farther
fragment, that is testing against the first depth buffer. If the fragment is discarded when tested against
the second depth buffer, that means this fragment has already been processed, and therefore should not
update the flag buffer. If at the end of a loop this buffer contains a non-zero value, it means there
are fragments that still need processing.

<p>Sadly, once your loop is done, you cannot read the content of the buffer, to know if you should continue
or stop. Due to the asynchronous nature of OpenGL, the only moment where it is safe to do so, is when
swapping the back/front framebuffer (ie: <tt>SDL_GL_SwapBuffers()</tt>). At this point you know that, the GPU
is done with the previous frame, and the content of the buffer is accurate now.

<p>Worse: if there was not enough loops, at this point you can only increase the number of loops by one.
If your scene just switched from one layer of transparency to one containing a lot, even at 60 frames per
second, you'll be able to see the translucent layers being peeled frame per frame, as the number of loops
is increased one by one. This is going to be particularly jarring to see because layers are extracted
from <B>back to front</b>.

<p>This is far from ideal in practice, and this technique has somewhat the same problem than the linked
list of fragments: it requires too much bandwidth and/or up to date OpenGL implementation, which makes it
particularly annoying to debug when something goes wrong (usually due to buggy driver).


<h4 id="cpusort"><span>Triangles sorting on CPU</span></h4>

<p>The technique that is ultimately used in this engine is simply <b>sorting the triangles from farthest
to nearest</b>. As with the previous 2 techniques, it has its own shortcomings: it is not 100% accurate
(typical use case where it fails: 2 intersecting triangles/quads), and since the sorting is done on
the CPU, it is going to lag the rendering whenever there are too many triangles to sort.

<p>It has its advantages though:
<ul>
  <li>It is very straightforward to implement and <b>debug</b> (well, compared to hardware accelerated sorting).
  <li>A voxel engine has a lot of tricks you can use to considerably reduce the amount of sorting needed.
</ul>

<p>In this engine, the sorting is actually <b>divided in 2 parts</b>. All sorting algorithms
have to assume that one of the operations necessary to sort items is going to be cheap: either comparison
or moving memory (ideally both). In this case, neither of them are particularly cheap if we were to use
the vertex data as direct source. That's why we create a first array which is both cheap to move its
individual items around (just 8 bytes per item) and to compare those items (subtract two 32bit integers).

<p>Once this array has been sorted, we use it to move vertex data. Thanks to the information stored
in that secondary array, each quads from the vertex array has to be moved at most 2 times (and most of
the time, data will be copied from one place of the array to another, ie: using one <tt>memcpy</tt>).

<p>Triangles are sorted by whole quads (ie: 6 vertices at a time, ie: 2 triangles), because the meshing
phase actually only generates quads. The distance used to sort triangles is actually the distance from
the camera <b>to the center of the whole quad</b>, that distance being converted to fixed point.

<p>The sorting itself is handled by the good old libc <tt>qsort()</tt>.

<p>To reduce the amount of sorting needed, a few tricks are used:
<ul>
  <li><b>Chunks are sorted by the frustum culling</b>: the frustum culling function already builds a list
  of chunk that are roughly sorted from front to back. It is not perfect, but as far as alpha transparency
  is concerned, it is good enough. Which means:

  <li><b>Vertex sorted per chunk</b>: we only have to sort the alpha triangles on a per chunk basis. Which
  means all the chunks hidden by frustum/caves don't have to be processed whatsoever. Also since vertex data
  is already stored per chunk, usually in non-contiguous memory segment, it would have been a <b>major
  inconvenience</b> to have to sort them globally.

  <li><b>Viewing angles threshold</b>: the list of visible chunks can change every time the model-view
  matrix is changed (which is to say quite often). Still, it is not required to sort the triangles
  every time the yaw/pitch/position are changed.

  <p>For the yaw/pitch, their values are stored in a chunk at the time of sorting. If these values change
  later, the sorting will be redone only if one of angles differ for more than 45&deg;.

  <p>The position is only taken in account for the chunk the player currently is. Consider the following
  situation:
  <div class="image">
    <img src="images/sortedalpha.png">
  </div>
  <p>The plus sign marks the player position: the <b>yellow block is the closest</b> (therefore drawn
  last), while the <b>purple and green are farther</b> (therefore drawn first). If the player were to
  move in the direction pointed by the arrow, at some point, the yellow block will become farther than
  the purple, therefore the draw order needs to be changed. That's why the current chunk is reordered
  whenever the player position changes.
</ul>

<h3 id="gpubanks"><span>Managing chunks on the GPU</span></h3>

<p>Chunks are rendered using instance rendering, which helps reduce the overhead of OpenGL draw calls,
at the price of a bit more work on the CPU side in order for the GPU to do its work.

<p>In a nutshell, chunks are stored in banks, which are pretty big memory segments (or vertex buffer
objects) stored on the GPU (as of writing this, there are 20Mb in size). This segment are then managed
using a custom allocator, where the meta-data used to track free/used memory is of course stored on
the CPU.

<h4 id="vtxbuffers">Vertex buffers</h4>

<p>The code is located in <tt>render.c:renderStoreArrays()</tt> and <tt>render.c:renderFreeArray()</tt>,
and their sole purpose is to behave like a custom <tt>malloc()</tt> and <tt>free()</tt>. The only
difference is that the actual memory is owned by the GPU.

<p>To achieve this, there are 2 main datatypes:
<ul>
  <li><tt>GPUBank</tt>: this is the datatype used to manage an entire segment. Segments cannot be
  reallocated (or at least, it is not advised to do it), therefore to allocate more memory, we'll have
  to create more of these segments. OpenGL draw commands can only deal with one primary segment (or
  VBO) at a time (VAO can deal with multiple VBO source, but they are processed in parallel, here
  we would need a serial access). Therefore to draw the geometry of a scene, we'll need at least as
  many draw commands as there are <tt>GPUBank</tt> involved in that scene (in practice, it will be
  a lot more of course).

  <li><tt>GPUMem</tt>: this datatype will track one allocation in a bank: the entire mesh of chunk
  will be stored here. That includes opaque and translucent triangles. The memory segment will be
  divided in 2: opaque triangles are stored at the start, followed by the translucent ones. This
  information is actually stored at the <tt>ChunkData</tt> level (<tt>glSize</tt>: total size in
  bytes of vertex data, <tt>glAlpha</tt>: size of alpha triangles in bytes, located at the end):
  the reason is because that information is needed in a few places, and the GPU datatypes are
  private to the render module.
</ul>

<p>Frustum culling will give us a list of <tt>ChunkData</tt> to render. The only thing to do is to
"sort" them by <tt>GPUBank</tt> and fill-in the <tt>glMultiDrawArraysIndirect()</tt> data structures.
There are 2: one for the indirect command (16 bytes per chunk) and one for model data (12 bytes per
chunk, ie: 3 floats). This VBO model is part of the VAO of the <tt>GPUBank</tt>, but has a <tt>glVertexAttribDivisor()</tt>
set to 1 (ie: only grab one vertex data per instance). It simply contains the position to offset all
the triangles of that <tt>ChunkData</tt>.

<p>There is one particular parameter that is critical to track though: it is the number of commands
that will be issued in a single <tt>glMultiDrawArraysIndirect()</tt> call (<tt>vtxSize</tt>). Keep in
mind that opaque and translucent meshes will be stored in the same buffer commands: therefore if a
chunk has both an opaque and an alpha mesh, that number will be increased by 2.

<p>Knowing the total number of draw commands is critical in setting up the <tt>glMultiDrawArraysIndirect()</tt>
command buffer, particularly the <tt>baseInstance</tt> field. Translucent chunk commands need to be
filled from end to start in this buffer (because frustum culling sort them from front to back). If that
<tt>vtxSize</tt> is incorrect, <tt>baseInstance</tt> will be off, and translucent fragment will not
appear where they should.


<h4 id="vtxdata">Vertex data</h4>

<p>This section will describe how vertex data are stored on the GPU. Being the central piece of any
voxel engine, this part had a decent amount of thoughts put into it (and quite a few refactoring).

<p>Terrain meshes <b>only need quads to be rendered</b> (not necessarily axis aligned), and since there
are a lot of them you might want to store them efficiently: a typical <prod>Minecraft</prod> world with
16 chunks loaded surrounding the player (that is an area of 32x32 chunks) usually contains around 2,000,000
quads (not all of them will be rendered at once), or 8M vertices (12M using newer OpenGL API, because
<tt>GL_QUAD</tt> was deprecated).

<p>If you were to store the vertex data (coordinates, texture UV and some meta data) as floats, that
would required about 400 Mb of data. While even a GPU from 2010 can easily handle this kind of load,
reducing the amount of data means we could push the render distance way farther than this.

<p>This engine manage to compress each quad down to 28 bytes (stored as 7 32bit unsigned integer),
that means viewing a world on a far render distance (16 chunks) usually requires about 50Mb of memory
on the GPU side: that's actually not very much. The vertex data is processed as <tt>GL_POINTS</tt>,
and split into <tt>GL_TRIANGLE_STRIP</tt> in a geometry shader.

<p>The format of each quad is as follows (stored in VBO as 7 <tt class="t">uint32_t</tt>):

<bits>
  <brow><hdr>0: </hdr><bitpart class="sz16" bit="32">16: <em>Y1</em></bitpart><bitpart class="sz16" bit="16">16: <em>X1</em></bitpart><bitpart class="sz0" bit="0"><em>&nbsp;</em></bitpart></brow>

  <brow><hdr>1: </hdr><bitpart class="sz2" bit="32"><em>Vhi</em></bitpart><bitpart class="sz14" bit="30">14: <em>DX2</em></bitpart><bitpart class="sz16" bit="16">16: <em>Z1</em></bitpart><bitpart class="sz0" bit="0"><em>&nbsp;</em></bitpart></brow>

  <brow><hdr>2: </hdr><bitpart class="sz4" bit="32">4: <em>ext</em></bitpart><bitpart class="sz14" bit="28">14: <em>DZ2</em></bitpart><bitpart class="sz14" bit="14">14: <em>DY2</em></bitpart><bitpart class="sz0" bit="0"><em>&nbsp;</em></bitpart></brow>

  <brow><hdr>3: </hdr><bitpart class="sz4" bit="32">4:  <em>ext</em></bitpart><bitpart class="sz14" bit="28">14: <em>DY3</em></bitpart><bitpart class="sz14" bit="14">14: <em>DX3</em></bitpart><bitpart class="sz0" bit="0"><em>&nbsp;</em></bitpart></brow>

  <brow><hdr>4: </hdr><bitpart class="sz9" bit="32">9: <em>Vlo</em></bitpart><bitpart class="sz9" bit="23">9: <em>U</em></bitpart><bitpart class="sz14" bit="14">14: <em>DZ3</em></bitpart><bitpart class="sz0" bit="0"><em>&nbsp;</em></bitpart></brow>

  <brow><hdr>5: </hdr><bitpart class="sz8" bit="32">8: <em>Vsz</em></bitpart><bitpart class="sz8" bit="24">8: <em>Usz</em></bitpart><bitpart class="sz3" bit="16">&nbsp;</bitpart><bitpart class="sz1"><em>X</em></bitpart><bitpart class="sz3" bit="12">3: <em>N</em></bitpart><bitpart class="sz9" bit="9">9: <em>OCS</em></bitpart><bitpart class="sz0" bit="0"><em>&nbsp;</em></bitpart></brow>

  <brow><hdr>6: </hdr><bitpart class="sz8" bit="32">8: <em>Sky/Block</em></bitpart><bitpart class="sz8" bit="24">8: <em>Sky/Block</em></bitpart><bitpart class="sz8" bit="16">8: <em>Sky/Block</em></bitpart><bitpart class="sz8" bit="8">8: <em>Sky/Block</em></bitpart><bitpart class="sz0" bit="0"><em>&nbsp;</em></bitpart></brow>
</bits>

<p>As of writing this, there are still some space left in the data: 3bits to be precise, which is not
very much. Each field has the following meaning:

<ul>
  <li><tt>X<sub>i</sub></tt>, <tt>Y<sub>i</sub></tt>, <tt>Z<sub>i</sub></tt>: to represent a <tt>QUAD</tt>, you need
  at least 3 coordinates. <tt>QUAD</tt> are not necessarily axis aligned, otherwise you could get away
  with only 2 points.
  <p>The coordinates are encoded as a fixed point number on 16bits. Because some models slightly exceed
  their voxel space, and as such can also exceed a chunk bounding box (like torches attached to wall).
  Therefore, the minimum range of coordinates should be between -0.5 and 16.5, but to make computation
  easier, the range of values is between -8 and 24.

  <p>Each voxel cube is therefore divided in 65536 / 32 = 2048 parts, which is largely enough
  to accomodate all the models that are not a full block from <prod>Minecraft</prod> 1.12. To convert
  from fixed to floating point, the formula is: <pre>vec3 position = (fixed - 16384) * (1 / 2048.)</pre>

  <p>Sadly, there is not enough space to store the 3 needed coordinates as 16bits fixed point. That's
  why the 2<sup>nd</sup> and 3<sup>rd</sup> points are stored as relative to the first vertex. Since
  models (for terrain) should never exceed a voxel unit, you know that each coordinates are at most at
  +/- 2048 units apart on each axis, which is 12 bits (including sign). We add 2 more bits of precision
  for a bit of safety, and that's why the last 2 points uses 14bits of precision per axis.

  <li><tt>U</tt>, <tt>V</tt>: coordinates of the <b>top left corner</b> of the texture to use for this <tt>QUAD</tt>
  (vertex V2, see below). <tt>V</tt> coordinate is split into 2 because there wasn't enough space left on
  the 4<sup>th</sup> word.

  <li><tt>Usz</tt>, <tt>Vsz</tt>: 2nd coordinate. These numbers are relative to <tt>U</tt> and <tt>V</tt>
  respectively, minus 128. This correspond to the texture coordinate for vertex V3 (see below). ie:
  <pre>vec2 texV3 = vec2(U + Usz - 128, V + Vsz - 128);</pre>

  <li><tt>X</tt>: knowing the texture coordinate of 2 vertices is not enough to fully find all the
  coordinates of the 2 remaining vertices. At this point there are 2 possibilities: keep U or V coordinate
  for V2 and V1. This is the purpose of this bit: if set to one, keep X for V1.

  <li><tt>OCS</tt>: ambient occlusion value for 4 vertices, each value being encoded on 2bits.

  <li><tt>ext</tt>: 8bits of extra data split into 2 due to lack of space (it was added very late).
  This and the <tt>OCS</tt> fields are way too complicated to be explained here. They will be described
  in the mesh generation chapter.

  <li><tt>N</tt>: normal of the face, encoded as <tt>0</tt>: south, <tt>1</tt>: east, <tt>2</tt>: north,
  <tt>3</tt>: west, <tt>4</tt>:top, <tt>5</tt>: bottom, <tt>6</tt>: recompute from vertices. The vast
  majority of quads are axis-aligned, and therefore unnecessary to recompute the normal. Those that are
  not will have their normal recomputed and shading per face adjusted accordingly.

  <li><tt>Sky</tt> / <tt>Block</tt>: a direct dump of the NBT tables <tt>Skylight</tt> and <tt>BlockLight</tt>.
  Obviously used for lighting purpose: 1 value per vertex, same order as OCS/texure U, V.
</ul>

<p>In the geometry shader, this is the information that will be sent to the fragment shader:
<div class="photo">
  <img src="images/quad.png">
</div>

<p>Two triangles will be constructed out of the 4 vertices: V1 - V2 - V3 and V3 - V2 - V4. Then,
each face will be decomposed like this:

<div class="photo" id="quadface">
  <img src="images/quad_face.png">
</div>

<p>This shows how each face is constructed from the cube vertices. <b>The arrow inside</b> the face
shows how the OCS/Sky/Block values are extracted: from least significant bits to most significant,
with start of arrow = first item, arrow end = last item, 4 values in total. <b>The axis</b> shows
where the 0, 0, 0 coordinates are (if the cube were to be rendered at 0, 0, 0) and where they
increase with positive values.

<hr>

<p id="vtx10bytes">However, this vertex format is <b>not easy to work with</b>: it involves a lot of tedious bit shifting
and code logic to extract all the information about a quad. The mesh of objects have to be analyzed for
generating bounding box and face visibility for example. That's why this engine uses another <b>vertex data</b>
format. It is actually used by everything, but terrain information: custom block models, inventory models,
entities models, bounding boxes, ...

<bits>
  <brow><hdr>0: </hdr><bitpart class="sz16" bit="16">16: <em>X</em></bitpart><bitpart class="sz0" bit="0"><em>&nbsp;</em></bitpart></brow>
  <brow><hdr>1: </hdr><bitpart class="sz16" bit="16">16: <em>Y</em></bitpart><bitpart class="sz0" bit="0"><em>&nbsp;</em></bitpart></brow>
  <brow><hdr>2: </hdr><bitpart class="sz16" bit="16">16: <em>Z</em></bitpart><bitpart class="sz0" bit="0"><em>&nbsp;</em></bitpart></brow>
  <brow><hdr>3: </hdr><bitpart class="sz7" bit="16">7: <em>Vhi</em></bitpart><bitpart class="sz9" bit="9">9: <em>U</em></bitpart><bitpart class="sz0" bit="0"><em>&nbsp;</em></bitpart></brow>
  <brow><hdr>4: </hdr><bitpart class="sz8" bit="16">8: <em>Sky/Block</em></bitpart><bitpart class="sz2" bit="8"><em><small>ocs</small></em></bitpart><bitpart class="sz3" bit="6">3: <em>N</em></bitpart><bitpart class="sz3" bit="3"><em>Vlo</em></bitpart><bitpart class="sz0" bit="0"><em>&nbsp;</em></bitpart></brow>
</bits>

<p>Although this is only 10 bytes (5 <tt class="t">uint16_t</tt>), this only encodes a single vertex.
You need 6 of these to form a quad, that is 60 bytes per <tt>GL_QUAD</tt>. At some point in time, the
terrain data was also based on this vertex data. Given how tedious it was to adapt all the rendering
code to the 28 bytes per quad version, it was decided to keep the compressed data for terrain only.

<h2 id="mesh">Mesh generation</h2>

<p>Welcome to <b>look-up table hell</b>.

<p>This engine supports 3 major types of voxel elements that can be converted into meshes. Each <b>have
their pros and cons</b>:

<ol>
  <li><tt>SOLID</tt>: these are the <b>bread and butter of a voxel engine</b>: a block that occupies the full
  space of a voxel. It can have arbitrary textures on all 6 sides, hidden faces can be culled easily and
  efficiently, and have a precise lighting model (including skylight, blocklight and ambient occlusion).

  <p>The <b>native "resolution"</b> of this engine is actually "half" a voxel: i.e.: a full voxel that
  has been split in half on the X, Y and Z axis. Which means a full voxel is made of 8 sub-voxels
  (i.e: you can, for example, render all kind of slabs with this: vertical, horizontal, 2x1, ...).

  <p>A typical map is usually composed of 80% of these blocks, therefore they require quite a bit of
  work (thus, will need <b>a lot</b> of look-up tables).

  <li><tt>CUST</tt>: voxels that can have an <b>arbirary shape</b> and have a much greater precision than half-blocks.
  The major drawback with these is that their <b>lighting model is greatly simplified</b>: for example, they
  don't generate any ambient occlusion. Also the same skylight and blocklight is applied to the entire
  model: if you were to generate a floor out of these with a block light nearby, you would be able to
  see that the transition between light values is not smooth at all (and have that <prod>Minecraft</prod>
  alpha feels).

  <p>Hidden face culling is still performed aggressively on these: a full voxel model will therefore
  be culled the same way as a <tt>SOLID</tt> block.

  <p>This type includes blocks like fences, glass panes, pistons, torches, chests, doors, ...
  
  <p>Note: this type of blocks also includes what is known as "chiseled" blocks: slab and detailed blocks
  (X, Y, Z split by 8).

  <li><tt>QUAD</tt>: this is a <b>very simple voxel to process</b>: only a handful of combination exists
  and all of them are trivial to process compared to the previous two. The typical use case for these
  are flowers, crops, grass, rails...

  <p>Like <tt>CUST</tt>, they use a simplified lighting model: single skylight/blocklight value for
  the entire model, and no ambient occlusion. Technically, they could be handled as <tt>CUST</tt>, but
  specifying a custom model each time they are needed is way too tedious.
</ol>

<p>Note: keep in mind that all blocks must be aligned inside the voxel grid. Technically, it is possible
to generate triangles at arbirary position, but the voxel manipulation functions won't be able to handle
it. To place a model at a truly arbitrary position, you need to use entities: this will be covered in the
next section (and have their own pros and cons).

<h3 id="meshsolid"><span><tt>SOLID</tt> voxel</span></h3>

<p>These blocks requires quite a bit of work to be converted into meshes. First, keep
<a href="#quadface">this picture</a> in mind, its information will be used <b>extensively</b>
in the entire meshing phase.

<h4 id="vtxtex"><span>Vertex and texture coordinates</span></h4>

<p>Converting a full solid voxel into a pseudo quad (technically a <tt>GL_POINT</tt>, that will be transformed
into 2 triangles in the geometry shader to a form a <tt>GL_QUAD</tt>), you need just a couple of look-up tables:

<pre style="font-size: 0.8em"><span class="t">uint8_t</span> vertex[<v>3</v>*<v>8</v>] = { <span class="c">/* 8 vertices of a 1x1x1 cube */</span>
    <v>0</v>,<v>0</v>,<v>1</v>,  <v>1</v>,<v>0</v>,<v>1</v>,  <v>1</v>,<v>1</v>,<v>1</v>,  <v>0</v>,<v>1</v>,<v>1</v>,
    <v>0</v>,<v>0</v>,<v>0</v>,  <v>1</v>,<v>0</v>,<v>0</v>,  <v>1</v>,<v>1</v>,<v>0</v>,  <v>0</v>,<v>1</v>,<v>0</v>,
};
<span class="t">uint8_t</span> cubeIndices[<v>6</v>*<v>4</v>] = { <span class="c">/* face (quad) of cube: S, E, N, W, T, B */</span>
    <v>9</v>, <v>0</v>, <v>3</v>, <v>6</v>,    <v>6</v>, <v>3</v>, <v>15</v>, <v>18</v>,     <v>18</v>, <v>15</v>, <v>12</v>, <v>21</v>,     <v>21</v>, <v>12</v>, <v>0</v>, <v>9</v>,    <v>21</v>, <v>9</v>, <v>6</v>, <v>18</v>,      <v>0</v>, <v>12</v>, <v>15</v>, <v>3</v>
<span class="c">/*  3, 0, 1, 2,    2, 1,  5,  6,      6,  5,  4,  7,      7,  4, 0, 3,     7, 3, 2,  6,      0,  4,  5, 1 */</span>
};
<span class="t">uint8_t</span> texCoord[] = { <span class="c">/* tex coord for each face: each line is a rotation, indexed by (Block.rotate&amp;3)*8 */</span>
    <v>0</v>,<v>0</v>,    <v>0</v>,<v>1</v>,    <v>1</v>,<v>1</v>,    <v>1</v>,<v>0</v>,
    <v>0</v>,<v>1</v>,    <v>1</v>,<v>1</v>,    <v>1</v>,<v>0</v>,    <v>0</v>,<v>0</v>,
    <v>1</v>,<v>1</v>,    <v>1</v>,<v>0</v>,    <v>0</v>,<v>0</v>,    <v>0</v>,<v>1</v>,
    <v>1</v>,<v>0</v>,    <v>0</v>,<v>0</v>,    <v>0</v>,<v>1</v>,    <v>1</v>,<v>1</v>,
};
</pre>

<p>It is as simple as it gets: <tt>vertex</tt> refers to the coordinates in world space (if the cube were
to be rendered at 0,0,0) of each corner, then to get the 4 coordinates of a given face <tt>cubeIndices</tt>
are indices within <tt>vertex[]</tt> array. The indices are pre-multiplied by 3, to avoid doing it in
the <b>many places</b> this array is used. The order/orientation is described in <a href="#quadface">this
picture</a>.

<p>In case you are wondering, the vertices and face order have no particular meaning nor does them
enable special tricks. All of this was chosen kind of arbitrarily very early in the development and
turned out to be OK: neither particularly good, nor bad.

<p>Keep in mind that coordinates for the mesh will be relative to the sub-chunk origin (a 16x16x16
chunk of terrain). In the vertex shader, each sub-chunk will receive a <tt>vec3</tt> offset that
will be added to every vertices.

<p><b>The order in which vertices of a face are enumerated</b> has a meaning though: it is done so that
all the remaining information (texture coordinates, lighting, ambient occlusion) can be applied the
same way on all faces.

<p>The <tt>texCoord</tt> array encodes 4 different rotations of a texture:

<div class="image">
  <img src="images/tex-rotate.png">
</div>

<p>Since there are 6 faces and you need 2 bits to encode each rotation, the <tt>BlockState_t.rotate</tt>
field contains 12bits of information. You cannot mirror a texture though, for this you'll need to a <tt>CUST</tt> voxel.

<h4 id="skyblock"><span>Block and sky light</span></h4>

<p>Each of the 24 vertices of a cube can have an independant block and sky light value, so that values
can be smoothly interpolated across a face. Each vertex will depend on 4 sky/block light: the 4 voxels
that share the vertex in the direction of the face normal. This is the purpose of the <tt>skyBlockOffset[]</tt>
table (it contains too many numbers to be displayed here).

<p>Each number in this table refers to a voxel, that is using the same coordinate system than the one
used in the <a jref="#cube3x3">frustum culling</a>:

<p><img src="images/quad_face.png" style="width: 66%; float: right">

<table class="skewed">
<tr><td>18<td>19<td>20
<tr><td>21<td>22<td>23
<tr><td>24<td>25<td>26
</table>

<table class="skewed">
<tr><td>9<td>10<td>11
<tr><td>12<td><span class="o">13</span><td>14
<tr><td>15<td>16<td>17
</table>

<table class="skewed">
<tr><td>0<td>1<td>2
<tr><td>3<td>4<td>5
<tr><td>6<td>7<td>8
</table>

<p>Whenever a <tt>SOLID</tt> block has at least one face visible, we extract the 26 surrounding voxels:
block ID and data value (in the array <tt>blockIds3x3[]</tt>) as well as block light and sky light
(in the array <tt>skyBlock[]</tt>). Each of these two arrays have 27 elements, ordered like in the table
above.

<p><tt>skyBlockOffset[]</tt> then encodes the 4 values we need per vertex: 4 vertex per face, that means
16 values per face, 96 items in total. For block light, we take the maximum among the 4 values, for
skylight we take the minimum if the value is not 0.

<p>For example, the south face has the values <tt class="o">15</tt>, <tt class="o">16</tt>, <tt class="o">24</tt>,
<tt class="o">25</tt> for the first vertex. If you look at the face order schema, the first vertex of
the south face is vertex 3 (arrow inside the square shows the order). There are 8 voxels that share
this vertex, but we only take the 4 that are in the direction of the face's normal (otherwise there
are too many).

<h4 id="cnxtex"><span>Connected textures</span></h4>

<p>Connected texture only applies to full block. More complex models like glass pane uses a different
approach (and will be described in the <tt>CUST</tt> section).

<p>For full blocks, the base model of its texture will be used to generate all the variations. Since
there are 4 sides, it means there are 16 possible combinations. As of writing this, this is done by removing
a one pixel line from a given side. These are generated in <tt>blocks.c:blockPostProcessTexture()</tt>.
This is for example, what it looks like for the glass texture:

<div class="photo">
  <img src="images/cnxtex.png" style="background-color: black; border: 5px solid black; width: 512px">
</div>

<p>To know which texture to use, you just need to set a bitfield if the block on top (bit1), right (bit2),
bottom (bit3) or left (bit4) "connects" with the current voxel. By default, U texture coordinate is
set to 0, therefore, you just have to shift it by <tt>bitfield * 16</tt> to simulate a connection.

<p>Left, right, top and bottom are relative to a face, therefore a new look-up table is needed:
<tt>offsetConnected[]</tt>. It encodes the 4 blocks to look for connection in the <tt>blockIds3x3[]</tt>
table (24 elements in total). Each group of 4 elements is of course ordered top, right, bottom and left.

<h4 id="meshhalf"><span>Half-block</span></h4>

<p>Half-block is actually the native "resolution" of this engine. Seems simple enough and you might wonder
what the big deal with these ? Well, you'll have a glimpse as to why Mojang has not added vertical slab to
<prod>Minecraft</prod> yet (as of writingthis, in august 2021): they introduce <b>a lot</b> of edge cases,
and sadly, it means <b>lots of look-up tables</b>.

<p>The first thing to keep in mind with half-block is, that <prod>MinecrafT</prod> treat them as if they were
a <tt>SOLID</tt> voxel: they completely block sky light and block light no matter what their orientation
is. If you attempt to get block or sky light at their coordinate, you'll get 0.

<p>The way half-blocks are meshed is a bit different from full voxel though. In case it wasn't clear up
until now, the chunk meshing for full voxel does not attempt to merge adjacent quads that share the same
properties (note: it should though).

<p>For half-slab though, the engine tries way harder. This is the gist of the meshing phase: whenever
a sub-face (ie: 0.5 x 0.5 in size) is detected as being visible, we check in the 2 directions perpendicular
to the normal if the size can be extended, and generate a quad of this size instead. This is done in
the function <tt>halfBlockGenMesh()</tt> in <tt>halfBlocks.c</tt>.


<h4 id="ocs"><span>Ambient occlusion</span></h4>

<p>/* ... */

<h3 id="meshcust"><span><tt>CUST</tt> voxel</span></h3>

<p>Custom voxels are blocks that cannot be represented as a <tt>SOLID</tt> voxel. They can have an
arbitrary shape, but their lighting is quite simplified compared to <tt>SOLID</tt>. For example they
usually do not generate ambient occlusion, unless one of their face line up with the voxel grid.

<p>Mesh data is stored in memory and read from the main block description table (<tt>blocksTable.js</tt>).
These models use the <a href="#vtx10bytes">10 bytes per voxel</a> vertex data. In the meshing phase
they are converted to 28 bytes per quad. This conversion is pretty straightforward, albeit a bit messy
to look at with all these bit twiddling hacks.

<p>There is one aspect that is not that trivial to handle though: <b>connected models</b>.

<h4 id="cnxmodels"><span>Connected models</span></h4>

<p>Some models <b>can have optional parts</b> that can be removed based on nearby voxels. The overtypical
example being fences:
<div class="image">
  <img src="images/cnxmodels.png">
</div>

<p>Yet, if you look at the model definition for every type of fence, you'll see <b>only one model</b>
being defined for each. The way it is handled is this engine is by tagging each vertex by an integer.
In the model <a href="#vtx10bytes">vertex data</a>, this ID is stored in the sky/block light information,
using 5 bits out of the 8 available (lighting information make no sense at this point, that's why it is
perfectly safe to repurpose those fields). That means each models can have up to <b>32 different connected
parts</b>. As of writing this, the models that have the most parts are glass panes with 18 parts.

<p>In case of fences, they only have 4 different parts: the 4 extensions around the center piece. In the
meshing phase we check for blocks around the custom model if those optional parts can connect to. This
is done in the function <tt>blockGetConnect()</tt>: the return value will be a bitfield of the parts
that should be included in the chunk's mesh.

<p>Then, in the chunk mesh generation, the unused parts are filtered using this simple test:
<pre><span class="k">if</span> (faceId &gt; <span class="o">0</span> &amp;&amp; (connect &amp; (<span class="o">1</span> &lt;&lt; (faceId-<span class="o">1</span>))) == <span class="o">0</span>)
{
	<span class="k">continue</span>;
}
</pre>

<p>Here, <tt>connect</tt> is the bitfield encoding the parts that should be included in the mesh. Since
it is a 32bits integer, that's where the limit of 32 optional parts comes from. An ID of 0 for a face
means that the face will always be included (like the central piece of a fence).


<p>/* ... */

<h2 id="nbt2">NBT API</h2>

<p>NBT API in this engine does not exactly follow a traditional API you might expect for manipulating
a tree of arbitrary data types. The main problem that this API was trying to solve is to keep 
everything related to an NBT tree as close as possible in memory, to benefit from cache locality.

<p>This is actually the main focus of this API: it <b>strongly</b> favors read over write access. The
rationale for this choice being that most chunks in a map will never be modified at all, and for those
that will, most of time it is simply a matter of overwriting some tables (<tt>BlockLight</tt>,
<tt>Blocks</tt>, <tt>Data</tt>, ...).

<p>There are a few lists (<tt>TileEntities</tt>, <tt>Entities</tt>, <tt>TileTicks</tt>, ...) where the
content can change significantly, and this is where this API will be a bit more tedious to use than other
APIs.

<p>The gist of how this API works is to serialize the content of a NBT file into a <b>single memory
block</b>. This block will be reallocated if the first allocation was not enough, but <b>everything</b>
will be kept into a contiguous block of memory. Therefore the binary representation of the NBT structure
in memory will actually be <b>very close</b> to how it is stored on disk (if it were uncompressed): save
a few memory alignment constraints and byte ordering, and you could write the buffer almost directly
to disk.

<p>Sadly, that also means, in order to use this API, you'll need to have a pretty good understanding
on how NBT is structured on disk, because that API is a very shallow abstraction over that. A refresher
will be available in the next section.

<p>NBT files usually contains lots of small blocks, that would be spread all over the memory if allocated
inidvidually. This API is also particularly efficient with memory when you need a small NBT fragment
(around hundreds of bytes): it is possible to only use stack memory and therefore perform no allocations.

<h3 id="nbtread"><span>NBT structure</span></h3>

<p>This section is a quick refresher on how NBT is structured (uncompressed). This format can store
arbitrary data types, in a tree-like format with branch nested as deep as you want.

<p>NBT supports <b>3 major families of types</b>:
<ol>
  <li><b>Scalar</b>: designate an imeediate value, which can be an integer (1, 2, 4 or 8 bytes), a
  floating point number (32 or 64bits) or a string.
  <li><b>List</b>: contains a finite number of scalar and/or compound.
  <li><b>Compound</b>: an arbitrary number of scalar, one after the other: a field terminator is used
  to mark the end of the block.
</ol>

<h3 id="nbtread"><span>Basic reading functions</span></h3>

<h3 id="nbtinc"><span>Incremental write</span></h3>

<h3 id="nbtfrag"><span>Edit NBT fragment</span></h3>

<h3 id="nbtpost"><span>Branch post-processing</span></h3>

<p>/* ... */

<h2 id="entities">Entities</h2>

<p>Entities in this engine refer to a model that is not aligned to the voxel grid: it can have arbitrary
position and/or rotation.

<p>This part will describe <b>how entities</b> (mobs, block moved by piston, dropped items, paintings, ...)
<b>are managed</b> within this engine. This part is not trivial just by looking at the source code, since
there are a lot of moving parts, with lots of datatypes:

<h3 id="structure"><span>Data structures</span></h3>

<p>There are 6 datatypes used to manage entities:

<ul>
  <li><tt>struct Entity_t</tt> : represents an entity from within the world, as such, they have
  a NBT record associated.

  <li><tt>struct EntityBuf_t</tt> : <tt>struct Entity_t</tt> are allocated in batch (<tt>ENTITY_BATCH</tt>
  count). It is easier to handle entities if pointers are not reallocated, so that reference can be held
  within datatypes. Allocating them in batch, will somewhat keep those entities close in memory.

  <li><tt>struct EntityBank_t</tt> : hold model data that will be used to render entities: we'll use
  one model per entity, so that they can be drawn in a single call to <tt>glMultiDrawArraysIndirect()</tt>.

  <p>This API will need a command buffer (vboMDAI) and a per instance info (vboLoc). This list will
  be rebuild with minimal changes whenever a entity is added or removed, which means a few more boilerplate
  tables to track usage (most notable one being <tt>mdaiUsage</tt>).

  <p>Assumption is made that entities around the player is rather low (less than 1000). Aas such, we
  don't care about frustum culling, we let the vertex shader do the work.

  <p>Once added, an entity model will remain in the VBO (there are no ways to remove models). A model
  represent a complete entity, like for example: item frame and their item are one model. Block 36 is
  one model...

  <p>Models will be rendered on demand: there are way too many to generate them all at startup.

  <p>Banks will hold a fixed number of vertices data: if that buffer is full or close to, a new bank
  will be allocated.

  <li><tt>struct EntityModel_t</tt> : describe what's in all the VBOs: since VBO are only stream
  of bytes, but we also need to know the vertex location, size, and bounding box.

  <li><tt>struct EntityEntry_t</tt> : given an entity, we want to know if its model is already available
  in one bank.
</ul>

<h3 id="collision"><span>Collision detection/correction</span></h3>

<p>Collision detection is implemented using a swept AABB algorithm and correction is done through sliding
adjustment.

<p>/* ... */


</div>

</body>
</html>
